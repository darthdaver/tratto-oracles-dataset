[ {
  "id" : 3894,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */",
  "methodSourceCode" : "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException{\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "2.3", "double" ], [ "2.3", "double" ], [ "76", "int" ], [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "2.0", "double" ] ],
  "tokensMethodArguments" : [ [ "serializableObject", "java.io", "Serializable" ], [ "options", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "length", "java.lang", "String", "public int length()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3900,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */",
  "methodSourceCode" : "public static String encodeBytes(byte[] source, int options) throws java.io.IOException{\n    return encodeBytes(source, 0, source.length, options);\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "76", "int" ], [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "2.3", "double" ], [ "2.3", "double" ], [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "2.0", "double" ] ],
  "tokensMethodArguments" : [ [ "source", "", "byte[]" ], [ "options", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3905,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws IllegalArgumentException if source array, offset, or length are invalid",
  "methodJavadoc" : "    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */",
  "methodSourceCode" : "public static String encodeBytes(byte[] source, int off, int len){\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "2.3", "double" ], [ "2.3", "double" ], [ "64", "int" ], [ "1.4", "double" ] ],
  "tokensMethodArguments" : [ [ "source", "", "byte[]" ], [ "off", "", "int" ], [ "len", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3912,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws IllegalArgumentException if source array, offset, or length are invalid",
  "methodJavadoc" : "    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */",
  "methodSourceCode" : "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException{\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "76", "int" ], [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "2.3", "double" ], [ "2.3", "double" ], [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "2.0", "double" ] ],
  "tokensMethodArguments" : [ [ "source", "", "byte[]" ], [ "off", "", "int" ], [ "len", "", "int" ], [ "options", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3919,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@return The Base64-encoded data as a String",
  "methodJavadoc" : "    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */",
  "methodSourceCode" : "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException{\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "2.3", "double" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "source", "", "byte[]" ], [ "off", "", "int" ], [ "len", "", "int" ], [ "options", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3920,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */",
  "methodSourceCode" : "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException{\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "2.3", "double" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "source", "", "byte[]" ], [ "off", "", "int" ], [ "len", "", "int" ], [ "options", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3921,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws IllegalArgumentException if source array, offset, or length are invalid",
  "methodJavadoc" : "    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */",
  "methodSourceCode" : "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException{\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "64", "int" ], [ "64", "int" ], [ "2.3", "double" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "source", "", "byte[]" ], [ "off", "", "int" ], [ "len", "", "int" ], [ "options", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3929,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws IllegalArgumentException if srcOffset or destOffset are invalid\n        or there is not enough room in the array.",
  "methodJavadoc" : "    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */",
  "methodSourceCode" : "private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset, int options){\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Source array was null.\");\n    }\n    // end if\n    if (destination == null) {\n        throw new NullPointerException(\"Destination array was null.\");\n    }\n    // end if\n    if (srcOffset < 0 || srcOffset + 3 >= source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset));\n    }\n    // end if\n    if (destOffset < 0 || destOffset + 2 >= destination.length) {\n        throw new IllegalArgumentException(String.format(\"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset));\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Example: Dk==\n    if (source[srcOffset + 2] == EQUALS_SIGN) {\n        // Two ways to do the same thing. Don't know which way I like best.\n        //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n        //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n        int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);\n        destination[destOffset] = (byte) (outBuff >>> 16);\n        return 1;\n    } else // Example: DkL=\n    if (source[srcOffset + 3] == EQUALS_SIGN) {\n        // Two ways to do the same thing. Don't know which way I like best.\n        //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n        //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n        //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n        int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);\n        destination[destOffset] = (byte) (outBuff >>> 16);\n        destination[destOffset + 1] = (byte) (outBuff >>> 8);\n        return 2;\n    } else // Example: DkLE\n    {\n        // Two ways to do the same thing. Don't know which way I like best.\n        //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n        //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n        //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n        //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n        int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF));\n        destination[destOffset] = (byte) (outBuff >> 16);\n        destination[destOffset + 1] = (byte) (outBuff >> 8);\n        destination[destOffset + 2] = (byte) (outBuff);\n        return 3;\n    }\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "4", "int" ], [ "3", "int" ], [ "64", "int" ], [ "1.3", "double" ] ],
  "tokensMethodArguments" : [ [ "source", "", "byte[]" ], [ "srcOffset", "", "int" ], [ "destination", "", "byte[]" ], [ "destOffset", "", "int" ], [ "options", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3940,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException If there is a problem",
  "methodJavadoc" : "    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */",
  "methodSourceCode" : "public static byte[] decode(String s) throws java.io.IOException{\n    return decode(s, NO_OPTIONS);\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "1.4", "double" ] ],
  "tokensMethodArguments" : [ [ "s", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "length", "java.lang", "String", "public int length()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3944,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */",
  "methodSourceCode" : "public static byte[] decode(String s, int options) throws java.io.IOException{\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "1.4", "double" ] ],
  "tokensMethodArguments" : [ [ "s", "java.lang", "String" ], [ "options", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "length", "java.lang", "String", "public int length()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3947,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is a general error",
  "methodJavadoc" : "    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */",
  "methodSourceCode" : "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException{\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "64", "int" ], [ "1.5", "double" ] ],
  "tokensMethodArguments" : [ [ "encodedObject", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3948,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws ClassNotFoundException if the decoded object is of a\n        class that cannot be found by the JVM",
  "methodJavadoc" : "    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */",
  "methodSourceCode" : "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException{\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "64", "int" ], [ "1.5", "double" ] ],
  "tokensMethodArguments" : [ [ "encodedObject", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3953,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is a general error",
  "methodJavadoc" : "    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */",
  "methodSourceCode" : "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException{\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "64", "int" ], [ "2.3", "double" ], [ "4", "int" ] ],
  "tokensMethodArguments" : [ [ "encodedObject", "java.lang", "String" ], [ "options", "", "int" ], [ "loader", "java.lang", "ClassLoader" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "length", "java.lang", "String", "public int length()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "getDefinedPackage", "java.lang", "ClassLoader", "public final Package getDefinedPackage(String arg0)" ], [ "findLoadedClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> findLoadedClass(String arg0)" ], [ "loadClass", "java.lang", "ClassLoader", "public Class<? extends Object> loadClass(String arg0) throws ClassNotFoundException" ], [ "getUnnamedModule", "java.lang", "ClassLoader", "public final Module getUnnamedModule()" ], [ "findClass", "java.lang", "ClassLoader", "protected Class<? extends Object> findClass(String arg0) throws ClassNotFoundException" ], [ "resources", "java.lang", "ClassLoader", "public Stream<URL> resources(String arg0)" ], [ "definePackage", "java.lang", "ClassLoader", "protected Package definePackage(String arg0, String arg1, String arg2, String arg3, String arg4, String arg5, String arg6, URL arg7)" ], [ "isAncestor", "java.lang", "ClassLoader", "boolean isAncestor(ClassLoader arg0)" ], [ "definePackage", "java.lang", "ClassLoader", "Package definePackage(String arg0, Module arg1)" ], [ "loadClass", "java.lang", "ClassLoader", "final Class<? extends Object> loadClass(Module arg0, String arg1)" ], [ "getResources", "java.lang", "ClassLoader", "public Enumeration<URL> getResources(String arg0) throws IOException" ], [ "name", "java.lang", "ClassLoader", "final String name()" ], [ "findClass", "java.lang", "ClassLoader", "protected Class<? extends Object> findClass(String arg0, String arg1)" ], [ "definePackage", "java.lang", "ClassLoader", "Package definePackage(Class<? extends Object> arg0)" ], [ "findLibrary", "java.lang", "ClassLoader", "protected String findLibrary(String arg0)" ], [ "createOrGetClassLoaderValueMap", "java.lang", "ClassLoader", "ConcurrentHashMap<? extends Object, ? extends Object> createOrGetClassLoaderValueMap()" ], [ "getResourceAsStream", "java.lang", "ClassLoader", "public InputStream getResourceAsStream(String arg0)" ], [ "findResources", "java.lang", "ClassLoader", "protected Enumeration<URL> findResources(String arg0) throws IOException" ], [ "getParent", "java.lang", "ClassLoader", "public final ClassLoader getParent()" ], [ "desiredAssertionStatus", "java.lang", "ClassLoader", "boolean desiredAssertionStatus(String arg0)" ], [ "findResource", "java.lang", "ClassLoader", "protected URL findResource(String arg0, String arg1) throws IOException" ], [ "packages", "java.lang", "ClassLoader", "Stream<Package> packages()" ], [ "getPackage", "java.lang", "ClassLoader", "protected Package getPackage(String arg0)" ], [ "findResource", "java.lang", "ClassLoader", "protected URL findResource(String arg0)" ], [ "getResource", "java.lang", "ClassLoader", "public URL getResource(String arg0)" ], [ "nameAndId", "java.lang", "ClassLoader", "String nameAndId()" ], [ "isRegisteredAsParallelCapable", "java.lang", "ClassLoader", "public final boolean isRegisteredAsParallelCapable()" ], [ "loadClass", "java.lang", "ClassLoader", "protected Class<? extends Object> loadClass(String arg0, boolean arg1) throws ClassNotFoundException" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(String arg0, ByteBuffer arg1, ProtectionDomain arg2) throws ClassFormatError" ], [ "findSystemClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> findSystemClass(String arg0) throws ClassNotFoundException" ], [ "getName", "java.lang", "ClassLoader", "public String getName()" ], [ "getPackages", "java.lang", "ClassLoader", "protected Package[] getPackages()" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(byte[] arg0, int arg1, int arg2) throws ClassFormatError" ], [ "getClassLoadingLock", "java.lang", "ClassLoader", "protected Object getClassLoadingLock(String arg0)" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(String arg0, byte[] arg1, int arg2, int arg3, ProtectionDomain arg4) throws ClassFormatError" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(String arg0, byte[] arg1, int arg2, int arg3) throws ClassFormatError" ], [ "getDefinedPackages", "java.lang", "ClassLoader", "public final Package[] getDefinedPackages()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3957,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */",
  "methodSourceCode" : "public static void encodeToFile(byte[] dataToEncode, String filename) throws java.io.IOException{\n    if (dataToEncode == null) {\n        throw new NullPointerException(\"Data to encode was null.\");\n    }\n    // end iff\n    Base64.OutputStream bos = null;\n    try {\n        bos = new Base64.OutputStream(new java.io.FileOutputStream(filename), Base64.ENCODE);\n        bos.write(dataToEncode);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw to execute finally{} block\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "2.3", "double" ], [ "2.3", "double" ], [ "64", "int" ], [ "2.1", "double" ] ],
  "tokensMethodArguments" : [ [ "dataToEncode", "", "byte[]" ], [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "length", "java.lang", "String", "public int length()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3960,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */",
  "methodSourceCode" : "public static void decodeToFile(String dataToDecode, String filename) throws java.io.IOException{\n    Base64.OutputStream bos = null;\n    try {\n        bos = new Base64.OutputStream(new java.io.FileOutputStream(filename), Base64.DECODE);\n        bos.write(dataToDecode.getBytes(PREFERRED_ENCODING));\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw to execute finally{} block\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "2.3", "double" ], [ "2.3", "double" ], [ "64", "int" ], [ "2.1", "double" ] ],
  "tokensMethodArguments" : [ [ "dataToDecode", "java.lang", "String" ], [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3963,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */",
  "methodSourceCode" : "public static byte[] decodeFromFile(String filename) throws java.io.IOException{\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "2.3", "double" ], [ "2.3", "double" ], [ "2.1", "double" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3966,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */",
  "methodSourceCode" : "public static String encodeFromFile(String filename) throws java.io.IOException{\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "64", "int" ], [ "2.3", "double" ], [ "2.3", "double" ], [ "64", "int" ], [ "2.1", "double" ] ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "length", "java.lang", "String", "public int length()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3969,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */",
  "methodSourceCode" : "public static void encodeFileToFile(String infile, String outfile) throws java.io.IOException{\n    String encoded = Base64.encodeFromFile(infile);\n    java.io.OutputStream out = null;\n    try {\n        out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n        // Strict, 7-bit output.\n        out.write(encoded.getBytes(\"US-ASCII\"));\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            out.close();\n        } catch (Exception ex) {\n        }\n    }\n    // end finally\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "2.2", "double" ] ],
  "tokensMethodArguments" : [ [ "infile", "java.lang", "String" ], [ "outfile", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "length", "java.lang", "String", "public int length()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3972,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "Base64",
  "javadocTag" : "@throws java.io.IOException if there is an error",
  "methodJavadoc" : "    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */",
  "methodSourceCode" : "public static void decodeFileToFile(String infile, String outfile) throws java.io.IOException{\n    byte[] decoded = Base64.decodeFromFile(infile);\n    java.io.OutputStream out = null;\n    try {\n        out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n        out.write(decoded);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            out.close();\n        } catch (Exception ex) {\n        }\n    }\n    // end finally\n}",
  "classJavadoc" : "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "2.2", "double" ] ],
  "tokensMethodArguments" : [ [ "infile", "java.lang", "String" ], [ "outfile", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "length", "java.lang", "String", "public int length()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3981,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.netstream.packing",
  "className" : "NetStreamUnpacker",
  "javadocTag" : "@return",
  "methodJavadoc" : "    /**\n\t * Unpacks the data necessary to decode a 4 bytes integer that indicates the size of the following message. \n\t * \n\t * The given buffer's position may be important for the unpacker to work. This method may also change the given bytebuffer's position attribute. \n\t * \n\t * @param buffer The byteBuffer who's content has the encoded value of the needed  size integer.\n\t * @return\n\t */",
  "methodSourceCode" : "public abstract int unpackMessageSize(ByteBuffer buffer);",
  "classJavadoc" : "/**\n * \n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pigné      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n\nimport java.nio.ByteBuffer;\n\n/**\n * \n */\npublic abstract class NetStreamUnpacker {\n\t\n\t/**\n\t * An unpacker has to be abble to indicated what is the size of an int after being packed.\n\t * @return\n\t */\n\tpublic abstract int sizeOfInt();\n\t\n\t/**\n\t * Unpack the given ByteBuffer from startIndex to endIdex \n\t * @param buffer The buffer to unpack/decode\n\t * @param startIndex the index at which the decoding starts in the buffer\n\t * @param endIndex the index at which the decoding stops\n\t * @return a ByteBuffer that is the unpacked version of the input one. It may not have the same size.\n\t */\n\tpublic abstract ByteBuffer unpackMessage(ByteBuffer buffer, int startIndex, int endIndex);\n\n\t/**\n\t * Unpack the given ByteBuffer \n\t * @param buffer The buffer to unpack/decode\n\t * @return a ByteBuffer that is the unpacked version of the input one. It may not have the same size.\n\t */\n\tpublic ByteBuffer unpackMessage(ByteBuffer buffer){\n\t\treturn this.unpackMessage(buffer, 0, buffer.capacity());\n\t}\n\n\t/**\n\t * Unpacks the data necessary to decode a 4 bytes integer that indicates the size of the following message. \n\t * \n\t * The given buffer's position may be important for the unpacker to work. This method may also change the given bytebuffer's position attribute. \n\t * \n\t * @param buffer The byteBuffer who's content has the encoded value of the needed  size integer.\n\t * @return\n\t */\n\tpublic abstract int unpackMessageSize(ByteBuffer buffer);\n\t\n\t\n\t\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "4", "int" ], [ "\"s position may be important for the unpacker to work. This method may also change the given bytebuffer\"", "String" ] ],
  "tokensMethodArguments" : [ [ "buffer", "java.nio", "ByteBuffer" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "unpackMessage", "org.graphstream.stream.netstream.packing", "NetStreamUnpacker", "public abstract ByteBuffer unpackMessage(ByteBuffer buffer, int startIndex, int endIndex)" ], [ "sizeOfInt", "org.graphstream.stream.netstream.packing", "NetStreamUnpacker", "public abstract int sizeOfInt()" ], [ "unpackMessage", "org.graphstream.stream.netstream.packing", "NetStreamUnpacker", "public ByteBuffer unpackMessage(ByteBuffer buffer)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "unpackMessageSize", "org.graphstream.stream.netstream.packing", "NetStreamUnpacker", "public abstract int unpackMessageSize(ByteBuffer buffer)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.nio", "ByteBuffer", "public boolean equals(Object arg0)" ], [ "put", "java.nio", "ByteBuffer", "public abstract ByteBuffer put(byte arg0)" ], [ "putShort", "java.nio", "ByteBuffer", "public abstract ByteBuffer putShort(short arg0)" ], [ "putDouble", "java.nio", "ByteBuffer", "public abstract ByteBuffer putDouble(int arg0, double arg1)" ], [ "putDouble", "java.nio", "ByteBuffer", "public abstract ByteBuffer putDouble(double arg0)" ], [ "mismatch", "java.nio", "ByteBuffer", "public int mismatch(ByteBuffer arg0)" ], [ "getDouble", "java.nio", "ByteBuffer", "public abstract double getDouble(int arg0)" ], [ "isDirect", "java.nio", "ByteBuffer", "public abstract boolean isDirect()" ], [ "get", "java.nio", "ByteBuffer", "public ByteBuffer get(byte[] arg0)" ], [ "putInt", "java.nio", "ByteBuffer", "public abstract ByteBuffer putInt(int arg0)" ], [ "position", "java.nio", "ByteBuffer", "public ByteBuffer position(int arg0)" ], [ "arrayOffset", "java.nio", "ByteBuffer", "public final int arrayOffset()" ], [ "put", "java.nio", "ByteBuffer", "public abstract ByteBuffer put(int arg0, byte arg1)" ], [ "compact", "java.nio", "ByteBuffer", "public abstract ByteBuffer compact()" ], [ "getInt", "java.nio", "ByteBuffer", "public abstract int getInt(int arg0)" ], [ "getChar", "java.nio", "ByteBuffer", "public abstract char getChar(int arg0)" ], [ "put", "java.nio", "ByteBuffer", "public ByteBuffer put(byte[] arg0, int arg1, int arg2)" ], [ "asFloatBuffer", "java.nio", "ByteBuffer", "public abstract FloatBuffer asFloatBuffer()" ], [ "put", "java.nio", "ByteBuffer", "public ByteBuffer put(int arg0, byte[] arg1)" ], [ "getLong", "java.nio", "ByteBuffer", "public abstract long getLong()" ], [ "get", "java.nio", "ByteBuffer", "public ByteBuffer get(byte[] arg0, int arg1, int arg2)" ], [ "rewind", "java.nio", "ByteBuffer", "public ByteBuffer rewind()" ], [ "putChar", "java.nio", "ByteBuffer", "public abstract ByteBuffer putChar(char arg0)" ], [ "reset", "java.nio", "ByteBuffer", "public ByteBuffer reset()" ], [ "getFloat", "java.nio", "ByteBuffer", "public abstract float getFloat(int arg0)" ], [ "asIntBuffer", "java.nio", "ByteBuffer", "public abstract IntBuffer asIntBuffer()" ], [ "get", "java.nio", "ByteBuffer", "public ByteBuffer get(int arg0, byte[] arg1)" ], [ "getFloat", "java.nio", "ByteBuffer", "public abstract float getFloat()" ], [ "alignedSlice", "java.nio", "ByteBuffer", "public final ByteBuffer alignedSlice(int arg0)" ], [ "hasArray", "java.nio", "ByteBuffer", "public final boolean hasArray()" ], [ "put", "java.nio", "ByteBuffer", "public ByteBuffer put(int arg0, ByteBuffer arg1, int arg2, int arg3)" ], [ "flip", "java.nio", "ByteBuffer", "public ByteBuffer flip()" ], [ "duplicate", "java.nio", "ByteBuffer", "public abstract ByteBuffer duplicate()" ], [ "slice", "java.nio", "ByteBuffer", "public abstract ByteBuffer slice(int arg0, int arg1)" ], [ "get", "java.nio", "ByteBuffer", "public abstract byte get()" ], [ "put", "java.nio", "ByteBuffer", "public ByteBuffer put(ByteBuffer arg0)" ], [ "get", "java.nio", "ByteBuffer", "public abstract byte get(int arg0)" ], [ "get", "java.nio", "ByteBuffer", "public ByteBuffer get(int arg0, byte[] arg1, int arg2, int arg3)" ], [ "asLongBuffer", "java.nio", "ByteBuffer", "public abstract LongBuffer asLongBuffer()" ], [ "asShortBuffer", "java.nio", "ByteBuffer", "public abstract ShortBuffer asShortBuffer()" ], [ "put", "java.nio", "ByteBuffer", "public final ByteBuffer put(byte[] arg0)" ], [ "compareTo", "java.nio", "ByteBuffer", "public int compareTo(ByteBuffer arg0)" ], [ "put", "java.nio", "ByteBuffer", "public ByteBuffer put(int arg0, byte[] arg1, int arg2, int arg3)" ], [ "order", "java.nio", "ByteBuffer", "public final ByteOrder order()" ], [ "mark", "java.nio", "ByteBuffer", "public ByteBuffer mark()" ], [ "getChar", "java.nio", "ByteBuffer", "public abstract char getChar()" ], [ "hashCode", "java.nio", "ByteBuffer", "public int hashCode()" ], [ "getInt", "java.nio", "ByteBuffer", "public abstract int getInt()" ], [ "putFloat", "java.nio", "ByteBuffer", "public abstract ByteBuffer putFloat(float arg0)" ], [ "limit", "java.nio", "ByteBuffer", "public ByteBuffer limit(int arg0)" ], [ "putInt", "java.nio", "ByteBuffer", "public abstract ByteBuffer putInt(int arg0, int arg1)" ], [ "getShort", "java.nio", "ByteBuffer", "public abstract short getShort(int arg0)" ], [ "putLong", "java.nio", "ByteBuffer", "public abstract ByteBuffer putLong(long arg0)" ], [ "putShort", "java.nio", "ByteBuffer", "public abstract ByteBuffer putShort(int arg0, short arg1)" ], [ "getShort", "java.nio", "ByteBuffer", "public abstract short getShort()" ], [ "asDoubleBuffer", "java.nio", "ByteBuffer", "public abstract DoubleBuffer asDoubleBuffer()" ], [ "putChar", "java.nio", "ByteBuffer", "public abstract ByteBuffer putChar(int arg0, char arg1)" ], [ "array", "java.nio", "ByteBuffer", "public final byte[] array()" ], [ "base", "java.nio", "ByteBuffer", "Object base()" ], [ "order", "java.nio", "ByteBuffer", "public final ByteBuffer order(ByteOrder arg0)" ], [ "asCharBuffer", "java.nio", "ByteBuffer", "public abstract CharBuffer asCharBuffer()" ], [ "slice", "java.nio", "ByteBuffer", "public abstract ByteBuffer slice()" ], [ "asReadOnlyBuffer", "java.nio", "ByteBuffer", "public abstract ByteBuffer asReadOnlyBuffer()" ], [ "getDouble", "java.nio", "ByteBuffer", "public abstract double getDouble()" ], [ "putLong", "java.nio", "ByteBuffer", "public abstract ByteBuffer putLong(int arg0, long arg1)" ], [ "alignmentOffset", "java.nio", "ByteBuffer", "public final int alignmentOffset(int arg0, int arg1)" ], [ "toString", "java.nio", "ByteBuffer", "public String toString()" ], [ "getLong", "java.nio", "ByteBuffer", "public abstract long getLong(int arg0)" ], [ "clear", "java.nio", "ByteBuffer", "public ByteBuffer clear()" ], [ "putFloat", "java.nio", "ByteBuffer", "public abstract ByteBuffer putFloat(int arg0, float arg1)" ], [ "limit", "java.nio", "Buffer", "public final int limit()" ], [ "clear", "java.nio", "Buffer", "public Buffer clear()" ], [ "isDirect", "java.nio", "Buffer", "public abstract boolean isDirect()" ], [ "limit", "java.nio", "Buffer", "public Buffer limit(int arg0)" ], [ "hasArray", "java.nio", "Buffer", "public abstract boolean hasArray()" ], [ "remaining", "java.nio", "Buffer", "public final int remaining()" ], [ "flip", "java.nio", "Buffer", "public Buffer flip()" ], [ "position", "java.nio", "Buffer", "public Buffer position(int arg0)" ], [ "slice", "java.nio", "Buffer", "public abstract Buffer slice()" ], [ "array", "java.nio", "Buffer", "public abstract Object array()" ], [ "slice", "java.nio", "Buffer", "public abstract Buffer slice(int arg0, int arg1)" ], [ "capacity", "java.nio", "Buffer", "public final int capacity()" ], [ "reset", "java.nio", "Buffer", "public Buffer reset()" ], [ "mark", "java.nio", "Buffer", "public Buffer mark()" ], [ "nextPutIndex", "java.nio", "Buffer", "final int nextPutIndex(int arg0)" ], [ "isReadOnly", "java.nio", "Buffer", "public abstract boolean isReadOnly()" ], [ "hasRemaining", "java.nio", "Buffer", "public final boolean hasRemaining()" ], [ "base", "java.nio", "Buffer", "abstract Object base()" ], [ "checkIndex", "java.nio", "Buffer", "final int checkIndex(int arg0)" ], [ "scope", "java.nio", "Buffer", "final ScopedMemoryAccess.Scope scope()" ], [ "nextPutIndex", "java.nio", "Buffer", "final int nextPutIndex()" ], [ "rewind", "java.nio", "Buffer", "public Buffer rewind()" ], [ "nextGetIndex", "java.nio", "Buffer", "final int nextGetIndex(int arg0)" ], [ "nextGetIndex", "java.nio", "Buffer", "final int nextGetIndex()" ], [ "markValue", "java.nio", "Buffer", "final int markValue()" ], [ "arrayOffset", "java.nio", "Buffer", "public abstract int arrayOffset()" ], [ "checkIndex", "java.nio", "Buffer", "final int checkIndex(int arg0, int arg1)" ], [ "position", "java.nio", "Buffer", "public final int position()" ], [ "duplicate", "java.nio", "Buffer", "public abstract Buffer duplicate()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "hb", "java.nio", "ByteBuffer", "final byte[] hb;" ], [ "offset", "java.nio", "ByteBuffer", "final int offset;" ], [ "isReadOnly", "java.nio", "ByteBuffer", "boolean isReadOnly;" ], [ "bigEndian", "java.nio", "ByteBuffer", "boolean bigEndian;" ], [ "nativeByteOrder", "java.nio", "ByteBuffer", "boolean nativeByteOrder;" ], [ "address", "java.nio", "Buffer", "long address;" ], [ "segment", "java.nio", "Buffer", "final MemorySegmentProxy segment;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]