[ {
  "id" : 10031,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "MathMDE",
  "javadocTag" : "@param y second operand",
  "methodJavadoc" : "    /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */",
  "methodSourceCode" : "public static int logicalAnd(int x, int y){\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}",
  "classJavadoc" : "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
  "classSourceCode" : "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "1", "int" ], [ "0", "int" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "x", "", "int" ], [ "y", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10046,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "MathMDE",
  "javadocTag" : "@param x first operand",
  "methodJavadoc" : "    /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */",
  "methodSourceCode" : "public static int logicalOr(int x, int y){\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}",
  "classJavadoc" : "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
  "classSourceCode" : "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "1", "int" ], [ "0", "int" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "x", "", "int" ], [ "y", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10048,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "MathMDE",
  "javadocTag" : "@param x first operand",
  "methodJavadoc" : "    /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */",
  "methodSourceCode" : "public static long logicalOr(long x, long y){\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}",
  "classJavadoc" : "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
  "classSourceCode" : "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "1", "int" ], [ "0", "int" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "x", "", "long" ], [ "y", "", "long" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10054,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "MathMDE",
  "javadocTag" : "@return base to the expt power",
  "methodJavadoc" : "    /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */",
  "methodSourceCode" : "public static int pow(int base, int expt) throws ArithmeticException{\n    return pow_fast(base, expt);\n}",
  "classJavadoc" : "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
  "classSourceCode" : "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "base", "", "int" ], [ "expt", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10057,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "MathMDE",
  "javadocTag" : "@return base to the expt power",
  "methodJavadoc" : "    /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */",
  "methodSourceCode" : "public static long pow(long base, long expt) throws ArithmeticException{\n    return pow_fast(base, expt);\n}",
  "classJavadoc" : "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
  "classSourceCode" : "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "base", "", "long" ], [ "expt", "", "long" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10083,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "MathMDE",
  "javadocTag" : "@param itor iterator of operands",
  "methodJavadoc" : "    /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */",
  "methodSourceCode" : "public static int[] modulus_int(Iterator<Integer> itor){\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}",
  "classJavadoc" : "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
  "classSourceCode" : "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "3", "int" ] ],
  "tokensMethodArguments" : [ [ "itor", "java.util.Iterator", "Iterator<Integer>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hasNext", "java.util", "Iterator", "public abstract boolean hasNext()" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10113,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "MathMDE",
  "javadocTag" : "@param nums the list of operands",
  "methodJavadoc" : "    /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */",
  "methodSourceCode" : "public static long[] nonmodulus_strict_long(Iterator<Long> nums){\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}",
  "classJavadoc" : "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
  "classSourceCode" : "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "nums", "java.util.Iterator", "Iterator<Long>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "hasNext", "java.util", "Iterator", "public abstract boolean hasNext()" ], [ "equals", "", "long[]", "public boolean equals(Object);" ], [ "toString", "", "long[]", "public String toString()" ], [ "hashCode", "", "long[]", "public native int hashCode()" ], [ "getClass", "", "long[]", "public final native Class getClass();" ], [ "clone", "", "long[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "long[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10122,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "Digest",
  "javadocTag" : "@return the bytes equivalent to the input String",
  "methodJavadoc" : "    /**\n   * A convenience method to convert from a string\n   * of hexadecimal digits to an array of bytes.\n   * This method is the reverse of {@link #hexEncode(byte[])}.\n   * @param s the String to convert to an array of bytes\n   * @return the bytes equivalent to the input String\n   */",
  "methodSourceCode" : "public static byte[] hexDecode(String s) throws IllegalArgumentException{\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9')) {\n                digit1 -= '0';\n            } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n                digit1 -= 'a' - 10;\n            }\n            if ((digit2 >= '0') && (digit2 <= '9')) {\n                digit2 -= '0';\n            } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n                digit2 -= 'a' - 10;\n            }\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}",
  "classJavadoc" : "/**\n * Computes a message digest for a file.  The primary entry point into this\n * class is {@link #getFileDigest(String,MessageDigest)}.\n */",
  "classSourceCode" : "// This code is lifted from examples/Manifest.java.\n\npackage plume;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.DigestInputStream;\nimport java.security.MessageDigest;\n\n/**\n * Computes a message digest for a file.  The primary entry point into this\n * class is {@link #getFileDigest(String,MessageDigest)}.\n */\npublic final class Digest {\n\n  /** This class is a collecton of methods; it does not represent anything. */\n  private Digest() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  /**\n   * This convenience method is used by both create() and verify().  It\n   * reads the contents of a named file and computes a message digest\n   * for it, using the specified MessageDigest object.\n   * @param filename the file to read\n   * @param md the MessageDigest\n   * @return the message digest\n   * @throws IOException if there is a problem reading the file\n   */\n  public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n\n    // Read to the end of the file, discarding everything we read. {\n    // The DigestInputStream automatically passes all the bytes read to\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) {\n      /* do nothing */\n    }\n\n    // Finally, compute and return the digest value.\n    byte[] result = md.digest();\n    in.close();\n    return result;\n  }\n\n  /** This static buffer is used by {@link #getFileDigest}. */\n  private static byte[] buffer = new byte[4096];\n\n  /** This array is used to convert from bytes to hexadecimal numbers. */\n  private static final char[] digits = {\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n  };\n\n  /**\n   * A convenience method to convert an array of bytes to a String.  We do\n   * this simply by converting each byte to two hexadecimal digits.  Something\n   * like Base 64 encoding is more compact, but harder to encode.\n   * @param bytes the bytes to convert to a String\n   * @return a String representation of the input bytes\n   */\n  public static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n      byte b = bytes[i];\n      s.append(digits[(b & 0xf0) >> 4]);\n      s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n  }\n\n  /**\n   * A convenience method to convert from a string\n   * of hexadecimal digits to an array of bytes.\n   * This method is the reverse of {@link #hexEncode(byte[])}.\n   * @param s the String to convert to an array of bytes\n   * @return the bytes equivalent to the input String\n   */\n  public static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n      int len = s.length();\n      byte[] r = new byte[len / 2];\n      for (int i = 0; i < r.length; i++) {\n        int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n        if ((digit1 >= '0') && (digit1 <= '9')) {\n          digit1 -= '0';\n        } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n          digit1 -= 'a' - 10;\n        }\n        if ((digit2 >= '0') && (digit2 <= '9')) {\n          digit2 -= '0';\n        } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n          digit2 -= 'a' - 10;\n        }\n        r[i] = (byte) ((digit1 << 4) + digit2);\n      }\n      return r;\n    } catch (Exception e) {\n      throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "s", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "length", "java.lang", "String", "public int length()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "equals", "", "byte[]", "public boolean equals(Object);" ], [ "toString", "", "byte[]", "public String toString()" ], [ "hashCode", "", "byte[]", "public native int hashCode()" ], [ "getClass", "", "byte[]", "public final native Class getClass();" ], [ "clone", "", "byte[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "byte[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]