[
    {
        "id": 10031,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "plume-lib-1.1.0",
        "packageName": "plume",
        "className": "MathMDE",
        "javadocTag": "@param y second operand",
        "methodJavadoc": "    /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */",
        "methodSourceCode": "public static int logicalAnd(int x, int y){\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}",
        "classJavadoc": "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
        "classSourceCode": "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "FileIOException",
                "plume"
            ],
            [
                "MathMDE",
                "plume"
            ],
            [
                "DeterministicObject",
                "plume"
            ],
            [
                "Digest",
                "plume"
            ],
            [
                "StringBuilderDelimited",
                "plume"
            ],
            [
                "OrderedPairIterator",
                "plume"
            ],
            [
                "CountingPrintWriter",
                "plume"
            ],
            [
                "MultiVersionControl",
                "plume"
            ],
            [
                "WeakIdentityHashMap",
                "plume"
            ],
            [
                "IterableIterator",
                "plume"
            ],
            [
                "Lookup",
                "plume"
            ],
            [
                "Pair",
                "plume"
            ],
            [
                "FileCompiler",
                "plume"
            ],
            [
                "MultiRandSelector",
                "plume"
            ],
            [
                "RandoopMappedCalls",
                "plume"
            ],
            [
                "Stopwatch",
                "plume"
            ],
            [
                "TaskManager",
                "plume"
            ],
            [
                "WeakHasherMap",
                "plume"
            ],
            [
                "ClassFileVersion",
                "plume"
            ],
            [
                "WeakIdentityPair",
                "plume"
            ],
            [
                "OptionsDoclet",
                "plume"
            ],
            [
                "DeclarationAnnotations",
                "plume"
            ],
            [
                "Option",
                "plume"
            ],
            [
                "RegexUtil",
                "plume"
            ],
            [
                "JWhich",
                "plume"
            ],
            [
                "TimeLimitProcess",
                "plume"
            ],
            [
                "Intern",
                "plume"
            ],
            [
                "GraphMDE",
                "plume"
            ],
            [
                "HtmlPrettyPrint",
                "plume"
            ],
            [
                "SimpleLog",
                "plume"
            ],
            [
                "OptionGroup",
                "plume"
            ],
            [
                "ICalAvailable",
                "plume"
            ],
            [
                "RandomSelector",
                "plume"
            ],
            [
                "BCELUtil",
                "plume"
            ],
            [
                "UtilMDE",
                "plume"
            ],
            [
                "Hasher",
                "plume"
            ],
            [
                "BibtexClean",
                "plume"
            ],
            [
                "LimitedSizeIntSet",
                "plume"
            ],
            [
                "Partitioner",
                "plume"
            ],
            [
                "Triple",
                "plume"
            ],
            [
                "Options",
                "plume"
            ],
            [
                "ArraysMDE",
                "plume"
            ],
            [
                "StrTok",
                "plume"
            ],
            [
                "Unpublicized",
                "plume"
            ],
            [
                "TestPlume",
                "plume"
            ],
            [
                "LimitedSizeSet",
                "plume"
            ],
            [
                "EntryReader",
                "plume"
            ],
            [
                "Filter",
                "plume"
            ],
            [
                "FuzzyFloat",
                "plume"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "negate",
                "plume",
                "MathMDE",
                "///\n/// Function versions of Java operators\n///\n/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static int negate(int a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static long negate(long a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static double negate(double a) {\n    return -a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static int bitwiseComplement(int a) {\n    return ~a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static long bitwiseComplement(long a) {\n    return ~a;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static int mul(int x, int y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static long mul(long x, long y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static double mul(double x, double y) {\n    return x * y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static int div(int x, int y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static long div(long x, long y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static double div(double x, double y) {\n    return x / y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static int mod(int x, int y) {\n    return x % y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static long mod(long x, long y) {\n    return x % y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static int lshift(int x, int y) {\n    return x << y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static long lshift(long x, long y) {\n    return x << y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static int rshiftSigned(int x, int y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static long rshiftSigned(long x, long y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static int bitwiseAnd(int x, int y) {\n    return x & y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static long bitwiseAnd(long x, long y) {\n    return x & y;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static int logicalAnd(int x, int y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static long logicalAnd(long x, long y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static int bitwiseXor(int x, int y) {\n    return x ^ y;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static long bitwiseXor(long x, long y) {\n    return x ^ y;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static int logicalXor(int x, int y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static long logicalXor(long x, long y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static int bitwiseOr(int x, int y) {\n    return x | y;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static long bitwiseOr(long x, long y) {\n    return x | y;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static int logicalOr(int x, int y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static long logicalOr(long x, long y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "sign",
                "plume",
                "MathMDE",
                "///\n/// sign\n///\n/**\n * Returns the sign of its argument.  The result is always -1, 0, or 1.\n * @param a value to have its sign taken\n * @return the sign of a: -1, 0, or 1\n */\npublic static int sign(int a) {\n    if (a == 0) {\n        return 0;\n    } else if (a > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "///\n/// exponentiation\n///\n/**\n * Returns of value of the first argument raised to the\n * power of the second argument.  The arguments are integers.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "/**\n * Returns of value of the first argument raised to the\n * power of the second argument.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "///\n/// gcd\n///\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static int gcd(int a, int b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        int tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/// gcd -- version for manipulating long (rather than int) values\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static long gcd(long a, long b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static double gcd(double a, double b) {\n    if (a == Double.POSITIVE_INFINITY || a == Double.NEGATIVE_INFINITY || Double.isNaN(a) || b == Double.POSITIVE_INFINITY || b == Double.NEGATIVE_INFINITY || Double.isNaN(b)) {\n        return Double.NaN;\n    }\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        double tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "///\n/// Modulus\n///\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nint mod_positive(int x, /*@PolyUpperBound*/\nint y) {\n    int result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static int[] modulus(int[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new int[] { remainder, modulus };\n}"
            ],
            [
                "modulus_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(int[])\n */\npublic static int[] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static int[] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    int modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(int[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().intValue();\n    }\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().intValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "/// modulus for long (as opposed to int) values\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nlong mod_positive(long x, /*@PolyUpperBound*/\nlong y) {\n    long result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static long[] modulus(long[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new long[] { remainder, modulus };\n}"
            ],
            [
                "modulus_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(long[])\n */\npublic static long[] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        long i = itor.next().longValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static long[] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    long modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(long[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().longValue();\n    }\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().longValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "///\n/// Non-Modulus\n///\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] missing_numbers(int[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length - 1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static int[] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   int range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2);\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = mod_positive(nums[i], m);\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new int[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "/// non-modulus for long (as opposed to int) values\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] missing_numbers(long[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length - 1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static long[] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   long range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2)));\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = ((int) (mod_positive(nums[i], m)));\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new long[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "getFileDigest",
                "plume",
                "Digest",
                "/**\n * This convenience method is used by both create() and verify().  It\n * reads the contents of a named file and computes a message digest\n * for it, using the specified MessageDigest object.\n * @param filename the file to read\n * @param md the MessageDigest\n * @return the message digest\n * @throws IOException if there is a problem reading the file\n */\npublic static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    // Read to the end of the file, discarding everything we read. {\n    // The DigestInputStream automatically passes all the bytes read to\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) {\n        /* do nothing */\n    }\n    // Finally, compute and return the digest value.\n    byte[] result = md.digest();\n    in.close();\n    return result;\n}"
            ],
            [
                "hexEncode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert an array of bytes to a String.  We do\n * this simply by converting each byte to two hexadecimal digits.  Something\n * like Base 64 encoding is more compact, but harder to encode.\n * @param bytes the bytes to convert to a String\n * @return a String representation of the input bytes\n */\npublic static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}"
            ],
            [
                "hexDecode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert from a string\n * of hexadecimal digits to an array of bytes.\n * This method is the reverse of {@link #hexEncode(byte[])}.\n * @param s the String to convert to an array of bytes\n * @return the bytes equivalent to the input String\n */\npublic static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9')) {\n                digit1 -= '0';\n            } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n                digit1 -= 'a' - 10;\n            }\n            if ((digit2 >= '0') && (digit2 <= '9')) {\n                digit2 -= '0';\n            } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n                digit2 -= 'a' - 10;\n            }\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}"
            ],
            [
                "dirToCheckoutHg",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".hg\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutHg(File hgDir, File dir) {\n    String repository = null;\n    File hgrcFile = new File(hgDir, \"hgrc\");\n    Ini ini;\n    // There also exist Hg commands that will do this same thing.\n    if (hgrcFile.exists()) {\n        try {\n            ini = new Ini(new FileReader(hgrcFile));\n        } catch (IOException e) {\n            throw new Error(\"Problem reading file \" + hgrcFile);\n        }\n        Ini.Section pathsSection = ini.get(\"paths\");\n        if (pathsSection != null) {\n            repository = pathsSection.get(\"default\");\n            if (repository != null && repository.endsWith(\"/\")) {\n                repository = repository.substring(0, repository.length() - 1);\n            }\n        }\n    }\n    return new Checkout(RepoType.HG, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutGit",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".git\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutGit(File gitDir, File dir) {\n    String repository = UtilMDE.backticks(\"git\", \"config\", \"remote.origin.url\");\n    return new Checkout(RepoType.GIT, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutSvn",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory that contains a .svn subdirectory, create a\n * corresponding Checkout object.\n * Returns null if this is not possible.\n */\nstatic /*@Nullable*/\nCheckout dirToCheckoutSvn(File dir) {\n    // For SVN, do\n    //   svn info\n    // and grep out these lines:\n    //   URL: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository/trunk/www\n    //   Repository Root: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository\n    // Use SVNKit?\n    // Con: introduces dependency on external library.\n    // Pro: no need to re-implement or to call external process (which\n    //   might be slow for large checkouts).\n    // unannotated library: SVNKit\n    @SuppressWarnings(\"nullness\")\n    SVNWCClient wcClient = new SVNWCClient((/*@Nullable*/\n    ISVNAuthenticationManager) null, null);\n    SVNInfo info;\n    try {\n        info = wcClient.doInfo(new File(dir.toString()), SVNRevision.WORKING);\n    } catch (SVNException e) {\n        // throw new Error(\"Problem in dirToCheckoutSvn(\" + dir + \"): \", e);\n        System.err.println(\"Problem in dirToCheckoutSvn(\" + dir + \"): \" + e.getMessage());\n        if (e.getMessage() != null && e.getMessage().contains(\"This client is too old\")) {\n            System.err.println(\"plume-lib needs a newer version of SVNKit.\");\n        }\n        return null;\n    }\n    // getFile is null when operating on a working copy, as I am\n    // String relativeFile = info.getPath(); // relative to repository root -- can use to determine root of checkout\n    // getFile is just the (absolute) local file name for local items -- same as \"dir\"\n    // File relativeFile = info.getFile();\n    SVNURL url = info.getURL();\n    // This can be null (example: dir /afs/csail.mit.edu/u/m/mernst/.snapshot/class/6170/2006-spring/3dphysics).  I don't know under what circumstances.\n    SVNURL repoRoot = info.getRepositoryRootURL();\n    if (repoRoot == null) {\n        System.err.println(\"Problem:  old svn working copy in \" + dir.toString());\n        System.err.println(\"Check it out again to get a 'Repository Root' entry in the svn info output.\");\n        System.err.println(\"  repoUrl = \" + url);\n        System.exit(2);\n    }\n    if (debug) {\n        System.out.println();\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"     dir = \" + dir.toString());\n    }\n    // Strip common suffix off of local dir and repo url.\n    Pair<File, File> /*@Nullable*/\n    /*@Nullable*/\n    stripped = removeCommonSuffixDirs(dir, new File(url.getPath()), new File(repoRoot.getPath()), \".svn\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n        System.out.printf(\"dir (%s) is parent of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    if (stripped.b == null) {\n        System.out.printf(\"dir (%s) is child of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    String pathInRepoAtCheckout = stripped.b.toString();\n    try {\n        url = url.setPath(pathInRepoAtCheckout, false);\n    } catch (SVNException e) {\n        throw new Error(e);\n    }\n    if (debug) {\n        System.out.println(\"stripped: \" + stripped);\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"    cDir = \" + cDir.toString());\n    }\n    assert url.toString().startsWith(repoRoot.toString()) : \"repoRoot=\" + repoRoot + \", url=\" + url;\n    return new Checkout(RepoType.SVN, cDir, url.toString(), null);\n    /// Old implementation\n    // String module = url.toString().substring(repoRoot.toString().length());\n    // if (module.startsWith(\"/\")) {\n    //   module = module.substring(1);\n    // }\n    // if (module.equals(\"\")) {\n    //   module = null;\n    // }\n    // return new Checkout(RepoType.SVN, cDir, repoRoot.toString(), module);\n}"
            ],
            [
                "removeCommonSuffixDirs",
                "plume",
                "MultiVersionControl",
                "/**\n * Strip identical elements off the end of both paths, and then return\n * what is left of each.  Returned elements can be null!  If p2_limit is\n * non-null, then it should be a parent of p2, and the stripping stops\n * when p2 becomes p2_limit.  If p1_contains is non-null, then p1 must\n * contain a subdirectory of that name.\n */\nstatic Pair</*@Nullable*/\nFile, /*@Nullable*/\nFile> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains) {\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\", p1, p2, p2_limit, p1_contains);\n    }\n    // new names for results, because we will be side-effecting them\n    File r1 = p1;\n    File r2 = p2;\n    while (r1 != null && r2 != null && (p2_limit == null || !r2.equals(p2_limit)) && r1.getName().equals(r2.getName())) {\n        if (p1_contains != null && !new File(r1.getParentFile(), p1_contains).isDirectory()) {\n            break;\n        }\n        r1 = r1.getParentFile();\n        r2 = r2.getParentFile();\n    }\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs => %s %s%n\", r1, r2);\n    }\n    return Pair.of(r1, r2);\n}"
            ],
            [
                "eq",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Check for equality of non-null reference x and possibly-null y.  Uses\n * identity equality.\n */\n/*@Pure*/\nstatic boolean eq(Object x, /*@Nullable*/\nObject y) {\n    return x == y;\n}"
            ],
            [
                "hasher",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return the hash code for x\n */\n/*@Pure*/\nstatic int hasher(Object x) {\n    return System.identityHashCode(x);\n}"
            ],
            [
                "indexFor",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return index for hash code h.\n */\n/*@Pure*/\nstatic int indexFor(int h, int length) {\n    return h & (length - 1);\n}"
            ],
            [
                "old_get_entry",
                "plume",
                "Lookup",
                "/**\n * Returns the next entry.  If no more entries are available, returns null.\n * @param reader where to read the entry from\n * @return the next entry, or null\n * @throws IOException if there is a problem reading a file\n */\npublic static /*@Nullable*/\nEntry old_get_entry(EntryReader reader) throws IOException {\n    try {\n        // Skip any preceeding blank lines\n        String line = reader.readLine();\n        while ((line != null) && (line.trim().length() == 0)) {\n            line = reader.readLine();\n        }\n        if (line == null) {\n            return (null);\n        }\n        Entry entry = null;\n        String filename = reader.getFileName();\n        long line_number = reader.getLineNumber();\n        // If this is a long entry\n        if (line.startsWith(\">entry\")) {\n            // Get the current filename\n            String current_filename = reader.getFileName();\n            // Remove '>entry' from the line\n            line = line.replaceFirst(\"^>entry *\", \"\");\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find the termination of the entry\n            while ((line != null) && !line.startsWith(\">entry\") && !line.equals(\"<entry\") && current_filename.equals(reader.getFileName())) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            // If this entry was terminated by the start of the next one,\n            // put that line back\n            if ((line != null) && (line.startsWith(\">entry\") || !current_filename.equals(reader.getFileName()))) {\n                reader.putback(line);\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, false);\n        } else {\n            // blank separated entry\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find another blank line\n            while ((line != null) && (line.trim().length() != 0)) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, true);\n        }\n        return (entry);\n    } catch (FileNotFoundException e) {\n        System.out.printf(\"Error: Can't read %s at line %d in file %s%n\", e.getMessage(), reader.getLineNumber(), reader.getFileName());\n        System.exit(254);\n        return (null);\n    }\n}"
            ],
            [
                "first_line",
                "plume",
                "Lookup",
                "/**\n * Returns the first line of entry.\n * @param entry the entry whose first line to return\n * @return the first line of entry\n */\npublic static String first_line(String entry) {\n    int ii = entry.indexOf(lineSep);\n    if (ii == -1) {\n        return entry;\n    }\n    return entry.substring(0, ii);\n}"
            ],
            [
                "of",
                "plume",
                "Pair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a pair of the values (a, b)\n */\npublic static <A extends /*@Nullable*/\nObject, B extends /*@Nullable*/\nObject> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "short_str",
                "plume",
                "TaskManager",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "short_str",
                "plume",
                "Task",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "versionNumbers",
                "plume",
                "ClassFileVersion",
                "/**\n * Return an array of the major vernios, minor version, and JDK version\n * of the class read from the input stream.\n * Return null if there is an error or the input isn't a class file.\n * @param is input stream from which to read a class\n * @return array of three version numbers\n */\npublic static double[] versionNumbers(InputStream is) {\n    try {\n        DataInputStream dis = new DataInputStream(is);\n        int magic = dis.readInt();\n        if (magic != 0xcafebabe) {\n            return null;\n        }\n        double minor = dis.readShort();\n        double major = dis.readShort();\n        double jdkVersion;\n        if (major < 48) {\n            // really 1.3.1\n            jdkVersion = 1.3;\n        } else if (major == 48) {\n            // really 1.4.2\n            jdkVersion = 1.4;\n        } else if (major == 49) {\n            jdkVersion = 1.5;\n        } else if (major == 50) {\n            jdkVersion = 6;\n        } else {\n            jdkVersion = 7;\n        }\n        return new double[] { major, minor, jdkVersion };\n    } catch (IOException e) {\n        return null;\n    }\n}"
            ],
            [
                "of",
                "plume",
                "WeakIdentityPair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a WeakIdentityPair of (a, b)\n */\npublic static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b) {\n    return new WeakIdentityPair<A, B>(a, b);\n}"
            ],
            [
                "start",
                "plume",
                "OptionsDoclet",
                "// Doclet-specific methods\n/**\n * Entry point for the doclet.\n * @param root the root document\n * @return true if processing completed without an error\n */\npublic static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n        // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n        // returns a fully qualified name.  I do not know a good way to convert\n        // between these two name formats.  For now, we simply ignore inner\n        // classes.  This limitation can be removed when we figure out a better\n        // way to go from ClassDoc to Class<?>.\n        if (doc.containingClass() != null) {\n            continue;\n        }\n        Class<?> clazz;\n        try {\n            // Javadoc source code is not yet annotated\n            @SuppressWarnings(\"signature\")\n            String /*@BinaryNameForNonArray*/\n            className = doc.qualifiedName();\n            clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        }\n        if (needsInstantiation(clazz)) {\n            try {\n                Constructor<?> c = clazz.getDeclaredConstructor();\n                c.setAccessible(true);\n                objs.add(c.newInstance(new Object[0]));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            objs.add(clazz);\n        }\n    }\n    if (objs.isEmpty()) {\n        System.out.println(\"Error: no classes found\");\n        return false;\n    }\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n        System.out.println(\"Error: no @Option-annotated fields found\");\n        return false;\n    }\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n        o.write();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "optionLength",
                "plume",
                "OptionsDoclet",
                "/**\n * Given a command-line option of this doclet, returns the number of\n * arguments you must specify on the command line for the given option.\n * Returns 0 if the argument is not recognized.  This method is\n * automatically invoked.\n *\n * @param option the command-line option\n * @return the number of command-line arguments needed when using the option\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n        System.out.printf(USAGE);\n        return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n        return 1;\n    }\n    if (option.equals(\"-docfile\") || option.equals(\"-outfile\") || option.equals(\"-format\") || option.equals(\"-d\")) {\n        return 2;\n    }\n    return 0;\n}"
            ],
            [
                "validOptions",
                "plume",
                "OptionsDoclet",
                "/**\n * Tests the validity of command-line arguments passed to this doclet.\n * Returns true if the option usage is valid, and false otherwise.  This\n * method is automatically invoked.\n *\n * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n * @param reporter where to report errors\n * @return true iff the command-line options are valid\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            if (hasDocFile) {\n                reporter.printError(\"-docfile option specified twice\");\n                return false;\n            }\n            File f = new File(os[1]);\n            if (!f.exists()) {\n                reporter.printError(\"-docfile file not found: \" + os[1]);\n                return false;\n            }\n            docFile = os[1];\n            hasDocFile = true;\n        }\n        if (opt.equals(\"-outfile\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-outfile option specified twice\");\n                return false;\n            }\n            if (inPlace) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            outFile = os[1];\n            hasOutFile = true;\n        }\n        if (opt.equals(\"-i\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            inPlace = true;\n        }\n        if (opt.equals(\"-format\")) {\n            if (hasFormat) {\n                reporter.printError(\"-format option specified twice\");\n                return false;\n            }\n            if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n                reporter.printError(\"unrecognized output format: \" + os[1]);\n                return false;\n            }\n            hasFormat = true;\n        }\n        if (opt.equals(\"-d\")) {\n            if (hasDestDir) {\n                reporter.printError(\"-d specified twice\");\n                return false;\n            }\n            hasDestDir = true;\n        }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n        reporter.printError(\"docfile must be different from outfile\");\n        return false;\n    }\n    if (inPlace && docFile == null) {\n        reporter.printError(\"-i supplied but -docfile was not\");\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "javadocToHtml",
                "plume",
                "OptionsDoclet",
                "/**\n * Replace the @link tags and block @see tags in a Javadoc comment with\n * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n * comment while still being presentable. <p>\n *\n * This is only a temporary solution.  Ideally, @link/@see tags would be\n * converted to HTML links that point to actual documentation.\n *\n * @param doc a Javadoc comment to convert to HTML\n * @return HTML version of doc\n */\npublic static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n        if (tag instanceof SeeTag) {\n            b.append(\"<code>\" + tag.text() + \"</code>\");\n        } else {\n            b.append(tag.text());\n        }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n        b.append(\" See: \");\n        {\n            StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n            for (SeeTag tag : seetags) {\n                bb.append(\"<code>\" + tag.text() + \"</code>\");\n            }\n            b.append(bb);\n        }\n        b.append(\".\");\n    }\n    return b.toString();\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param s string to check for being a regular expression\n * @return true iff s is a regular expression\n */\n/*@Pure*/\n/*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\npublic static boolean isRegex(String s) {\n    return isRegex(s, 0);\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression with at least the given number of groups.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return true iff s is a regular expression with groups groups\n */\n// RegexUtil; for purity, catches an exception\n@SuppressWarnings({ \"regex\", \"deterministic\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(String s, int groups) {\n    Pattern p;\n    try {\n        p = Pattern.compile(s);\n    } catch (PatternSyntaxException e) {\n        return false;\n    }\n    return getGroupCount(p) >= groups;\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param c char to check for being a regular expression\n * @return true iff c is a regular expression\n */\n@SuppressWarnings({ \"regex\", \"purity.not.deterministic.call\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(char c) {\n    return isRegex(Character.toString(c));\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a string describing why the argument is\n * not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nString regexError(String s) {\n    return regexError(s, 0);\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns\n * a string describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil;\n@SuppressWarnings({ \"regex\", \"not.sef\" })\npublic static /*@Nullable*/\nString regexError(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return regexErrorMessage(s, groups, actualGroups);\n        }\n    } catch (PatternSyntaxException e) {\n        return e.getMessage();\n    }\n    return null;\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a PatternSyntaxException describing\n * why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s) {\n    return regexException(s, 0);\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns a\n * PatternSyntaxException describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return new PatternSyntaxException(regexErrorMessage(s, groups, actualGroups), s, -1);\n        }\n    } catch (PatternSyntaxException pse) {\n        return pse;\n    }\n    return null;\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex String} if it is a regex,\n * otherwise throws an error. The purpose of this method is to suppress Regex\n * Checker warnings. It should be very rarely needed.\n * @param s string to check for being a regular expression\n * @return its argument\n * @throws Error if argument is not a regex\n */\n/*@SideEffectFree*/\n// The return type annotation is a conservative bound.\npublic static /*@Regex*/\nString asRegex(String s) {\n    return asRegex(s, 0);\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex(groups) String} if it is a regex\n * with at least the given number of groups, otherwise throws an error. The\n * purpose of this method is to suppress Regex Checker warnings. It should\n * be very rarely needed.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return its argument\n * @throws Error if argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Regex*/\nString asRegex(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            throw new Error(regexErrorMessage(s, groups, actualGroups));\n        }\n        return s;\n    } catch (PatternSyntaxException e) {\n        throw new Error(e);\n    }\n}"
            ],
            [
                "findClass",
                "plume",
                "JWhich",
                "/**\n * Returns the URL of the resource denoted by the specified\n * class name, as prescribed by the class path.\n *\n * @param className name of the class\n * @return class URL, or null of the class was not found\n */\npublic static /*@Nullable*/\nURL findClass(final String className) {\n    return JWhich.class.getResource(asResourceName(className));\n}"
            ],
            [
                "asResourceName",
                "plume",
                "JWhich",
                "protected static String asResourceName(String resource) {\n    if (!resource.startsWith(\"/\")) {\n        resource = \"/\" + resource;\n    }\n    resource = resource.replace('.', '/');\n    resource = resource + \".class\";\n    return resource;\n}"
            ],
            [
                "getClasspath",
                "plume",
                "JWhich",
                "/**\n * Return the classpath.\n * @return the classpath\n */\n/*@EnsuresNonNull(\"CLASSPATH\")*/\nprotected static String getClasspath() {\n    if (CLASSPATH == null) {\n        String classpath = System.getProperty(\"java.class.path\");\n        setClasspath(classpath);\n    }\n    return CLASSPATH;\n}"
            ],
            [
                "internStrings",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Strings\n///\n/**\n * Replace each element of the array by its interned version.\n * Side-effects the array, but also returns it.\n * @param a the array whose elements to intern in place\n * @return an interned version of a\n * @see String#intern\n */\n// side-effects the array in place (dangerous, but convenient)\n@SuppressWarnings(\"interning\")\npublic static String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] != null) {\n            a[i] = a[i].intern();\n        }\n    }\n    return a;\n}"
            ],
            [
                "isInterned",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Testing interning\n///\n/**\n * Return true if the argument is interned (is canonical among all\n * objects equal to itself).\n * @param value the value to test for interning\n * @return true iff value is interned\n */\n// interning implementation\n@SuppressWarnings(\"interning\")\npublic static /*@Pure*/\nboolean isInterned(/*@Nullable*/\nObject value) {\n    if (value == null) {\n        // nothing to do\n        return true;\n    } else if (value instanceof String) {\n        return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n        return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n        return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n        return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n        return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n        return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n        return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n        return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n        return (value == intern((Object[]) value));\n    } else {\n        // Nothing to do, because we don't intern other types.\n        // System.out.println(\"What type? \" + value.getClass().getName());\n        return true;\n    }\n}"
            ],
            [
                "numIntegers",
                "plume",
                "Intern",
                "// For testing only\npublic static int numIntegers() {\n    return internedIntegers.size();\n}"
            ],
            [
                "numLongs",
                "plume",
                "Intern",
                "public static int numLongs() {\n    return internedLongs.size();\n}"
            ],
            [
                "numIntArrays",
                "plume",
                "Intern",
                "public static int numIntArrays() {\n    return internedIntArrays.size();\n}"
            ],
            [
                "numLongArrays",
                "plume",
                "Intern",
                "public static int numLongArrays() {\n    return internedLongArrays.size();\n}"
            ],
            [
                "numDoubles",
                "plume",
                "Intern",
                "public static int numDoubles() {\n    return internedDoubles.size();\n}"
            ],
            [
                "numDoubleArrays",
                "plume",
                "Intern",
                "public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n}"
            ],
            [
                "numStringArrays",
                "plume",
                "Intern",
                "public static int numStringArrays() {\n    return internedStringArrays.size();\n}"
            ],
            [
                "numObjectArrays",
                "plume",
                "Intern",
                "public static int numObjectArrays() {\n    return internedObjectArrays.size();\n}"
            ],
            [
                "integers",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nInteger> integers() {\n    return internedIntegers.keySet().iterator();\n}"
            ],
            [
                "longs",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nLong> longs() {\n    return internedLongs.keySet().iterator();\n}"
            ],
            [
                "intArrays",
                "plume",
                "Intern",
                "public static Iterator<int[]> intArrays() {\n    return internedIntArrays.keySet().iterator();\n}"
            ],
            [
                "longArrays",
                "plume",
                "Intern",
                "public static Iterator<long[]> longArrays() {\n    return internedLongArrays.keySet().iterator();\n}"
            ],
            [
                "doubles",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nDouble> doubles() {\n    return internedDoubles.keySet().iterator();\n}"
            ],
            [
                "doubleArrays",
                "plume",
                "Intern",
                "public static Iterator<double[]> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n}"
            ],
            [
                "stringArrays",
                "plume",
                "Intern",
                "public static Iterator<String[]> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n}"
            ],
            [
                "objectArrays",
                "plume",
                "Intern",
                "public static Iterator<Object[]> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a String.\n * Delegates to the builtin String.intern() method.\n * Provided for completeness.\n * @param a the string to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static /*@Interned*/\n/*@PolyNull*/\nString intern(/*@PolyNull*/\nString a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n        return null;\n    }\n    return a.intern();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a long.\n * A no-op.  Provided for completeness.\n * @param l the long to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static long intern(long l) {\n    return l;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a double\n * A no-op.  Provided for completeness.\n * @param d the double to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static double intern(double d) {\n    return d;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Integer.\n * Return a canonical representation for the Integer.\n * @param a an Integer to canonicalize\n * @return a canonical representation for the Integer\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Intern.valueOf is intended to promise\n// the same).  This does not currently take advantage of that.\n// interning implementation\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nInteger intern(Integer a) {\n    WeakReference<Integer> /*@Interned*/\n    lookup = internedIntegers.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Integer /*@Interned*/\n        result = (/*@Interned*/\n        Integer) a;\n        internedIntegers.put(result, new WeakReference</*@Interned*/\n        Integer>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nInteger internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value parsed from the string.\n * @param s the string to parse\n * @return an interned Integer parsed from s\n */\npublic static /*@Interned*/\nInteger internedInteger(String s) {\n    return intern(Integer.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Long.\n * Return a canonical representation for the Long.\n * @param a the value to intern\n * @return a canonical representation for the Long\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Long.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nLong intern(Long a) {\n    WeakReference<Long> /*@Interned*/\n    lookup = internedLongs.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Long /*@Interned*/\n        result = (/*@Interned*/\n        Long) a;\n        internedLongs.put(result, new WeakReference</*@Interned*/\n        Long>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nLong internedLong(long i) {\n    return intern(Long.valueOf(i));\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value parsed from the string.\n * @param s the string to parse\n * @return an interned Long parsed from s\n */\npublic static /*@Interned*/\nLong internedLong(String s) {\n    return intern(Long.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) an int[].\n * Return a canonical representation for the int[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the int[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static int[] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        int[] /*@Interned*/\n        result = (int[]) a;\n        internedIntArrays.put(result, new WeakReference<int[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a long[].\n * Return a canonical representation for the long[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the long[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static long[] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        long[] /*@Interned*/\n        result = (long[]) a;\n        internedLongArrays.put(result, new WeakReference<long[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Double.\n * Return a canonical representation for the Double.\n * @param a the Double to canonicalize\n * @return a canonical representation for the Double\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Double.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nDouble intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n        return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) {\n        // catches both positive and negative zero\n        return internedDoubleZero;\n    }\n    WeakReference<Double> /*@Interned*/\n    lookup = internedDoubles.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Double /*@Interned*/\n        result = (/*@Interned*/\n        Double) a;\n        internedDoubles.put(result, new WeakReference</*@Interned*/\n        Double>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value i.\n * @param d the value to intern\n * @return an interned Double with value d\n */\npublic static /*@Interned*/\nDouble internedDouble(double d) {\n    return intern(Double.valueOf(d));\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value parsed from the string.\n * @param s the string to parse\n * @return an interned Double parsed from s\n */\npublic static /*@Interned*/\nDouble internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) a double[].\n * Return a canonical representation for the double[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the double[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static double[] intern(double[] a) {\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        double[] /*@Interned*/\n        result = (double[]) a;\n        internedDoubleArrays.put(result, new WeakReference<double[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an String[].\n * Return a canonical representation for the String[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the String[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static String[] intern(/*@PolyNull*/\n/*@Interned*/\nString[] a) {\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n        assert a[k] == Intern.intern(a[k]);\n    }\n    WeakReference<String[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    String[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (String[]) a;\n        internedStringArrays.put(result, new WeakReference<String[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    String[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Object[].\n * Return a canonical representation for the Object[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the Object[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static Object[] intern(/*@PolyNull*/\n/*@Interned*/\nObject[] a) {\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    WeakReference<Object[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    Object[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (Object[]) a;\n        internedObjectArrays.put(result, new WeakReference<Object[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    Object[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Convenince method to intern an Object when we don't know its\n * runtime type.  Its runtime type must be one of the types for\n * which we have an intern() method, else an exception is thrown.\n * If the argument is an array, its elements should themselves be\n * interned.\n * @param a an Object to canonicalize\n * @return a canonical version of a\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Interned*/\n/*@PolyNull*/\nObject intern(/*@PolyNull*/\nObject a) {\n    if (a == null) {\n        return null;\n    } else if (a instanceof String) {\n        return intern((String) a);\n    } else if (a instanceof String[]) {\n        @SuppressWarnings(\"interning\")\n        String[] /*@Interned*/\n        asArray = (String[]) a;\n        return intern(asArray);\n    } else if (a instanceof Integer) {\n        return intern((Integer) a);\n    } else if (a instanceof Long) {\n        return intern((Long) a);\n    } else if (a instanceof int[]) {\n        return intern((int[]) a);\n    } else if (a instanceof long[]) {\n        return intern((long[]) a);\n    } else if (a instanceof Double) {\n        return intern((Double) a);\n    } else if (a instanceof double[]) {\n        return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n        @SuppressWarnings(\"interning\")\n        Object[] /*@Interned*/\n        asArray = (Object[]) a;\n        return intern(asArray);\n    } else {\n        throw new IllegalArgumentException(\"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * Return the subsequence of seq from start (inclusive) to end\n * (exclusive) that is interned.  What's different about this method\n * from manually finding the subsequence and interning the\n * subsequence is that if the subsequence is already interned, we\n * can avoid having to compute the sequence.  Since derived\n * variables in Daikon compute the subsequence many times, this\n * shortcut saves quite a bit of computation.  It saves even more\n * when there may be many derived variables that are non-canonical,\n * since they are guaranteed to be ==.\n * <p>\n * Requires that seq is already interned.\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n */\npublic static int[] internSubsequence(int[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int[]> /*@Interned*/\n    sai = new SequenceAndIndices<int[]>(seq, start, end);\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n        int[] /*@Interned*/\n        subseq = Intern.intern(subseqUninterned);\n        internedIntSequenceAndIndices.put(sai, new WeakReference<int[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static long[] internSubsequence(long[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long[]> /*@Interned*/\n    sai = new SequenceAndIndices<long[]>(seq, start, end);\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        long[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedLongSequenceAndIndices.put(sai, new WeakReference<long[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static double[] internSubsequence(double[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double[]> /*@Interned*/\n    sai = new SequenceAndIndices<double[]>(seq, start, end);\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        double[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedDoubleSequenceAndIndices.put(sai, new WeakReference<double[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static Object[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nObject[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<Object[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedObjectSequenceAndIndices.put(sai, new WeakReference<Object[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static String[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nString[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<String[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedStringSequenceAndIndices.put(sai, new WeakReference<String[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "dominators",
                "plume",
                "GraphMDE",
                "// Algorithms for computing dominators:\n//\n// Wikipedia:\n//  // dominator of the start node is the start itself\n//  Dom(n_0) = {n_0}\n//  // for all other nodes, set all nodes as the dominators\n//  for each n in N - {n_0}\n//      Dom(n) = N;\n//  // iteratively eliminate nodes that are not dominators\n//  while changes in any Dom(n)\n//      for each n in N - {n_0}:\n//          Dom(n) = {n} union with intersection over all p in pred(n) of Dom(p)\n//\n// Cooper/Harvey/Kennedy:\n//  for all nodes, n\n//    DOM[n] := {1 . . .N}\n//  Changed := true\n//  while (Changed)\n//    Changed := false\n//    for all nodes, n, in reverse postorder\n//      new_set := (Intersect_{p:=preds(n)} DOM[p]) union {n}\n//      if (new_set != DOM[n])\n//        DOM[n] := new_set\n//        Changed := true\n// The two algorithms are essentially the same; this implementation\n// follows the Wikipedia one.\n/**\n * Computes, for each node in the graph, its set of (pre-)dominators.\n * Supply a successor graph if you want post-dominators.\n * @param <T> type of the graph nodes\n * @param predecessors a graph, represented as a predecessor map\n * @return a map from each node to a list of its pre-dominators\n */\npublic static <T> Map<T, List<T>> dominators(Map<T, List</*@KeyFor(\"#1\")*/\nT>> predecessors) {\n    // Map</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>> dom = new HashMap</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>>();\n    Map<T, List<T>> dom = new HashMap<T, List<T>>();\n    // every element of pred's value will be a key for dom\n    @SuppressWarnings(\"keyfor\")\n    Map<T, List<T>> /*@KeyFor({\"dom\"})*/\n    preds = predecessors;\n    List<T> nodes = new ArrayList<T>(preds.keySet());\n    // Compute roots & non-roots, for convenience\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    roots = new ArrayList<T>();\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    non_roots = new ArrayList<T>();\n    // Initialize result:  for roots just the root, otherwise everything\n    for (T node : preds.keySet()) {\n        if (preds.get(node).isEmpty()) {\n            // This is a root.  Its only dominator is itself.\n            Set<T> set = Collections.singleton(node);\n            dom.put(node, new ArrayList<T>(set));\n            roots.add(node);\n        } else {\n            // Initially, set all nodes as dominators;\n            // will later remove nodes that aren't dominators.\n            dom.put(node, new ArrayList<T>(nodes));\n            non_roots.add(node);\n        }\n    }\n    assert roots.size() + non_roots.size() == nodes.size();\n    // Invariants:\n    // preds and dom have the same keyset.\n    // All of the following are keys for both preds and dom:\n    //  * every key in pred\n    //  * elery element of every pred value\n    //  * every key in dom\n    //  * elery element of every dom value\n    // So, the type of pred is now\n    //\n    // rather than its original type\n    //   Map<T,List</*@KeyFor(\"preds\")*/ T>> preds\n    boolean changed = true;\n    while (changed) {\n        changed = false;\n        for (T node : non_roots) {\n            List<T> new_doms = null;\n            assert preds.containsKey(node);\n            for (T pred : preds.get(node)) {\n                assert dom.containsKey(pred);\n                /*@NonNull*/\n                List<T> dom_of_pred = dom.get(pred);\n                if (new_doms == null) {\n                    // make copy because we may side-effect new_doms\n                    new_doms = new ArrayList<T>(dom_of_pred);\n                } else {\n                    new_doms.retainAll(dom_of_pred);\n                }\n            }\n            assert new_doms != null : \"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\";\n            new_doms.add(node);\n            assert dom.containsKey(node);\n            if (!dom.get(node).equals(new_doms)) {\n                dom.put(node, new_doms);\n                changed = true;\n            }\n        }\n    }\n    for (T node : preds.keySet()) {\n        // TODO: The following two assert statements would be easier to read\n        // than the one combined one, but a bug (TODO:  Jonathan will add a\n        // bug number) prevents it from type-checking.\n        // assert dom.containsKey(node);\n        // assert dom.get(node).contains(node);\n        assert dom.containsKey(node) && dom.get(node).contains(node);\n    }\n    return dom;\n}"
            ],
            [
                "canonicalizeTimezone",
                "plume",
                "ICalAvailable",
                "static String canonicalizeTimezone(String timezone) {\n    String result = canonicalTimezones.get(timezone.toLowerCase());\n    return (result == null) ? timezone : result;\n}"
            ],
            [
                "printedTimezone",
                "plume",
                "ICalAvailable",
                "/*@Pure*/\nstatic String printedTimezone(TimeZone tz) {\n    String tzString = tz.getDisplayName();\n    String result = printedTimezones.get(tzString);\n    return (result == null) ? tzString : result;\n}"
            ],
            [
                "parseTime",
                "plume",
                "ICalAvailable",
                "// Parse a time like \"9:30pm\"\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nDateTime parseTime(String time) {\n    Matcher m = timeRegexp.matcher(time);\n    if (!m.matches()) {\n        System.err.println(\"Bad time: \" + time);\n        System.exit(1);\n    }\n    @SuppressWarnings(// Regex Checker imprecision:  matches() guarantees that group 1 exists in regexp\n    \"nullness\")\n    String /*@NonNull*/\n    hourString = m.group(1);\n    String minuteString = m.group(3);\n    String ampmString = m.group(4);\n    int hour = Integer.parseInt(hourString);\n    if ((ampmString != null) && ampmString.toLowerCase().equals(\"pm\")) {\n        hour += 12;\n    }\n    int minute = 0;\n    if (minuteString != null) {\n        minute = Integer.parseInt(minuteString);\n    }\n    DateTime result = new DateTime();\n    result.setTimeZone(tz1);\n    result.setHours(hour);\n    result.setMinutes(minute);\n    result.setSeconds(0);\n    return result;\n}"
            ],
            [
                "rangeString",
                "plume",
                "ICalAvailable",
                "static String rangeString(Period p, TimeZone tz) {\n    tf.setTimeZone(tz);\n    DateTime pstart = p.getStart();\n    DateTime pend = p.getEnd();\n    String rangeString = tf.format(pstart) + \" to \" + tf.format(pend);\n    rangeString = rangeString.replace(\" AM\", \"am\");\n    rangeString = rangeString.replace(\" PM\", \"pm\");\n    return rangeString;\n}"
            ],
            [
                "periodListString",
                "plume",
                "ICalAvailable",
                "static String periodListString(PeriodList pl, TimeZone tz) {\n    tf.setTimeZone(tz);\n    StringBuilder result = new StringBuilder();\n    // \"Object\" because PeriodList extends TreeSet, but it really ought to\n    // extend TreeSet</*@NonNull*/ Period>\n    for (Object p : pl) {\n        assert p != null : \"@AssumeAssertion(nullness): non-generic container class; elements are non-null\";\n        result.append(rangeString((Period) p, tz) + \"\\n\");\n    }\n    return result.toString();\n}"
            ],
            [
                "mergeDateAndTime",
                "plume",
                "ICalAvailable",
                "/**\n * Creates a new DateTime with date taken from the first argument and\n * time taken from the second argument.\n * @return the merged DateTime\n */\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic DateTime mergeDateAndTime(DateTime date, DateTime time) {\n    if (!date.getTimeZone().equals(time.getTimeZone())) {\n        throw new Error(String.format(\"non-matching timezones: %s %s\", date.getTimeZone(), time.getTimeZone()));\n    }\n    DateTime result = new DateTime(date);\n    result.setHours(time.getHours());\n    result.setMinutes(time.getMinutes());\n    result.setSeconds(time.getSeconds());\n    return result;\n}"
            ],
            [
                "oneDayAvailable",
                "plume",
                "ICalAvailable",
                "// TODO:  don't propose times that are before the current moment.\n// Process day-by-day because otherwise weekends and evenings are included.\n// for iCal4j\n@SuppressWarnings(\"unchecked\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nList<Period> oneDayAvailable(DateTime day, List<Calendar> calendars) {\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...)%n\", day);\n    }\n    List<Period> result = new ArrayList<Period>();\n    // for iCal4j\n    @SuppressWarnings(\"deprecation\")\n    int dayOfWeek = day.getDay();\n    if (!businessDays.contains(dayOfWeek)) {\n        return result;\n    }\n    for (Period bh : businessHours) {\n        DateTime start = mergeDateAndTime(day, bh.getStart());\n        DateTime end = mergeDateAndTime(day, bh.getEnd());\n        VFreeBusy request = new VFreeBusy(start, end, new Dur(0, 0, 0, 1));\n        if (debug) {\n            System.out.println(\"Request = \" + request);\n        }\n        ComponentList busyTimes = new ComponentList();\n        // Problem:  any all-day events will be treated as UTC.\n        // Instead, they should be converted to local time (tz1).\n        // But VFreeBusy does not support this, so I may need to convert\n        // daily events into a different format before inserting them.\n        for (Calendar calendar : calendars) {\n            // getComponents() returns a raw ArrayList.  Expose its element type.\n            ArrayList<Component> /*@NonNull*/\n            clist = calendar.getComponents();\n            for (Component c : clist) {\n                if (c instanceof VEvent) {\n                    VEvent v = (VEvent) c;\n                    DtStart dts = v.getStartDate();\n                    Parameter dtsValue = dts.getParameter(\"VALUE\");\n                    boolean allDay = (dtsValue != null) && dtsValue.getValue().equals(\"DATE\");\n                    // TODO: convert to the proper timezone.\n                    // Tricky: must deal with the possibility of RRULE:FREQ=\n                }\n                busyTimes.add(c);\n            }\n        }\n        VFreeBusy response = new VFreeBusy(request, busyTimes);\n        if (debug) {\n            System.out.println(\"Response = \" + response);\n        }\n        FreeBusy freefb = (FreeBusy) response.getProperty(\"FREEBUSY\");\n        if (freefb == null) {\n            if (debug) {\n                System.out.println(\"FREEBUSY property is null\");\n            }\n            continue;\n        }\n        // interned fields from a library, but not annotated so\n        @SuppressWarnings(\"interning\")\n        boolean isFree = (freefb.getParameter(Parameter.FBTYPE) == FbType.FREE);\n        assert isFree;\n        PeriodList freePeriods = freefb.getPeriods();\n        if (debug) {\n            System.out.printf(\"Free periods: %n%s%n\", periodListString(freePeriods, tz1));\n        }\n        result.addAll(freePeriods);\n    }\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...) => %s elements%n\", day, result.size());\n    }\n    return result;\n}"
            ],
            [
                "parseDate",
                "plume",
                "ICalAvailable",
                "/**\n * Parses a date when formatted in several common formats.\n * @return a Date read from the given string\n * @see dateFormats\n */\nstatic java.util.Date parseDate(String strDate) throws ParseException {\n    if (Pattern.matches(\"^[0-9][0-9]?/[0-9][0-9]?$\", date)) {\n        // for iCal4j\n        @SuppressWarnings(\"deprecation\")\n        int year = new Date().getYear() + 1900;\n        strDate = strDate + \"/\" + year;\n    }\n    for (DateFormat this_df : dateFormats) {\n        this_df.setLenient(false);\n        try {\n            java.util.Date result = this_df.parse(strDate);\n            return result;\n        } catch (ParseException e) {\n            // Try the next format in the list.\n        }\n    }\n    throw new ParseException(\"bad date \" + strDate, 0);\n}"
            ],
            [
                "formatDate",
                "plume",
                "ICalAvailable",
                "static String formatDate(DateTime d, TimeZone tz) {\n    df.setTimeZone(tz);\n    String result = df.format(d);\n    // Don't remove trailing year; it's a good double-check.\n    // Remove trailing year, such as \", 1952\".\n    // result = result.substring(0, result.length() - 6);\n    // Prepend day of week.\n    result = dffull.format(d).substring(0, 3) + \" \" + result;\n    return result;\n}"
            ],
            [
                "get_method_declaration",
                "plume",
                "BCELUtil",
                "/**\n * Returns a string describing a method declaration. It contains the access\n * flags (public, private, static, etc), the return type, the method name, and\n * the types of each of its arguments.\n * @param m the method\n * @return a string describing the method declaration\n */\npublic static String get_method_declaration(Method m) {\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n        f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n}"
            ],
            [
                "get_access_flags",
                "plume",
                "BCELUtil",
                "/**\n * Return a string representation of the access flags of method m.\n * @param m the method whose access flags to retrieve\n * @return a string representation of the access flags of method m\n */\nstatic String get_access_flags(Method m) {\n    int flags = m.getAccessFlags();\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n        if ((flags & pow) != 0) {\n            if (buf.length() > 0) {\n                buf.append(\" \");\n            }\n            if (i < Const.ACCESS_NAMES_LENGTH) {\n                buf.append(Const.getAccessName(i));\n            } else {\n                buf.append(String.format(\"ACC_BIT %x\", pow));\n            }\n        }\n        pow <<= 1;\n    }\n    return (buf.toString());\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a) {\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "get_constant_str",
                "plume",
                "BCELUtil",
                "/**\n * Returns the constant string at the specified offset.\n * @param pool the constant pool\n * @param index the index in the constant pool\n * @return the constant string at the specified offset in the constant pool\n */\npublic static String get_constant_str(ConstantPool pool, int index) {\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n        return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n        ConstantClass cc = (ConstantClass) c;\n        return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n        throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param mg the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param m the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param mg the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param m the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param gen the class to test\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in the format of Class.getName();\n *   the class should not be an array\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(/*@ClassGetName*/\nString classname) {\n    return classname.startsWith(\"java.\") || classname.startsWith(\"com.\") || classname.startsWith(\"javax.\") || classname.startsWith(\"org.\") || classname.startsWith(\"sun.\") || classname.startsWith(\"sunw.\");\n}"
            ],
            [
                "in_jdk_internalform",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in internal form\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk_internalform(/*@InternalForm*/\nString classname) {\n    return classname.startsWith(\"java/\") || classname.startsWith(\"com/\") || classname.startsWith(\"javax/\") || classname.startsWith(\"org/\") || classname.startsWith(\"sun/\") || classname.startsWith(\"sunw/\");\n}"
            ],
            [
                "instruction_descr",
                "plume",
                "BCELUtil",
                "// TODO: write Javadoc\n@SuppressWarnings(\"rawtypes\")\npublic static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n        @SuppressWarnings(// BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n        \"nullness\")\n        InstructionHandle /*@NonNull*/\n        handle = (InstructionHandle) i.next();\n        out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n}"
            ],
            [
                "local_var_descr",
                "plume",
                "BCELUtil",
                "/**\n * Return a description of the local variables (one per line).\n * @param mg the method whose local variables to describe\n * @return a description of the local variables (one per line)\n */\npublic static String local_var_descr(MethodGen mg) {\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n        for (LocalVariableGen lvg : lvgs) {\n            out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n        }\n    }\n    return (out.toString());\n}"
            ],
            [
                "is_local_variable_type_table",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the specified attribute is a local variable type\n * table.\n * @param a the attribute\n * @param pool the constant pool\n * @return true iff the attribute is a local variable type table\n */\npublic static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @param pool the constant pool\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "is_main",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not this is a standard main method (static,\n * name is 'main', and one argument of string array).\n * @param mg the method to check\n * @return true iff the method is a main method\n */\npublic static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic() && mg.getName().equals(\"main\") && (arg_types.length == 1) && arg_types[0].equals(string_array));\n}"
            ],
            [
                "type_to_classgetname",
                "plume",
                "BCELUtil",
                "/**\n * Returns the Java class name, in the format of {@link Class#getName()},\n * that corresponds to type.\n * @param type the type\n * @return the Java classname that corresponds to type\n */\npublic static /*@ClassGetName*/\nString type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n}"
            ],
            [
                "type_to_class",
                "plume",
                "BCELUtil",
                "/**\n * Returns the class that corresponds to type.\n * @param type the type\n * @return the Java class that corresponds to type\n */\npublic static Class<?> type_to_class(Type type) {\n    String classname = type_to_classgetname(type);\n    try {\n        Class<?> c = UtilMDE.classForName(classname);\n        return c;\n    } catch (Exception e) {\n        throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n}"
            ],
            [
                "add_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type added to the end of types.\n * @param types the array to extend\n * @param new_type the element to add to the end of the types array\n * @return the array (or a new one), with new_type at the end\n */\npublic static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "insert_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type inserted at the beginning.\n * @param types the array to extend\n * @param new_type the element to add to the beginning of the types array\n * @return the array (or a new one), with new_type at the beginning\n */\npublic static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "classname_to_type",
                "plume",
                "BCELUtil",
                "/**\n * Return the type corresponding to a given class name.\n * @param classname the class to convert to a type\n * @return the type corresponding to the given class name\n */\npublic static Type classname_to_type(String classname) {\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n        classname = classname.substring(0, classname.length() - 2);\n        array_depth++;\n    }\n    classname = classname.intern();\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") {\n        // interned\n        t = Type.INT;\n    } else if (classname == \"boolean\") {\n        // interned\n        t = Type.BOOLEAN;\n    } else if (classname == \"byte\") {\n        // interned\n        t = Type.BYTE;\n    } else if (classname == \"char\") {\n        // interned\n        t = Type.CHAR;\n    } else if (classname == \"double\") {\n        // interned\n        t = Type.DOUBLE;\n    } else if (classname == \"float\") {\n        // interned\n        t = Type.FLOAT;\n    } else if (classname == \"long\") {\n        // interned\n        t = Type.LONG;\n    } else if (classname == \"short\") {\n        // interned\n        t = Type.SHORT;\n    } else {\n        // must be a non-primitive\n        t = new ObjectType(classname);\n    }\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n        t = new ArrayType(t, array_depth);\n    }\n    return t;\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Array\n///\n// For arrays, see ArraysMDE.java.\n///////////////////////////////////////////////////////////////////////////\n/// BitSet\n///\n/**\n * Returns true if the cardinality of the intersection of the two\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b) >= i);\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "/**\n * Returns true if the cardinality of the intersection of the three\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b intersect c) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        intersection.and(c);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the two BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @return size(a intersect b)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the three BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @return size(a intersect b intersect c)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n}"
            ],
            [
                "fileInputStream",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// BufferedFileReader\n///\n// Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n/**\n * Returns an InputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStream for file\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            in = new GZIPInputStream(new FileInputStream(file));\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        in = new FileInputStream(file);\n    }\n    return in;\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return an InputStream for filename\n * @throws IOException if there is trouble reading the file\n * @throws FileNotFoundException if the file is not found\n */\npublic static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName null, or the name of a Charset to use when reading the file\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibility-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a LineNumberReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return a LineNumberReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedWriter appends to the end\n * of the file instead of the beginning\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\n// Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\npublic static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n        file_writer = new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n        file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n}"
            ],
            [
                "bufferedFileOutputStream",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedOutputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedOutputStream appends to the end\n * of the file instead of the beginning\n * @return a BufferedOutputStream for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}"
            ],
            [
                "isSubtype",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Class\n///\n/**\n * Return true iff sub is a subtype of sup.\n * If sub == sup, then sub is considered a subtype of sub and this method\n * returns true.\n * @param sub class to test for being a subtype\n * @param sup class to test for being a supertype\n * @return true iff sub is a subtype of sup\n */\n/*@Pure*/\npublic static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n        return true;\n    }\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n        return true;\n    }\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n        if (ifc == sup || isSubtype(ifc, sup)) {\n            return true;\n        }\n    }\n    return false;\n}"
            ],
            [
                "classForName",
                "plume",
                "UtilMDE",
                "/**\n * Like {@link Class#forName(String)}, but also works when the string\n * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n * <p>\n * If the given name can't be found, this method changes the last '.'  to\n * a dollar sign ($) and tries again.  This accounts for inner classes\n * that are incorrectly passed in in fully-qualified format instead of\n * binary format.\n * <p>\n * Recall the rather odd specification for {@link Class#forName(String)}:\n * the argument is a binary name for non-arrays, but a field descriptor\n * for arrays.  This method uses the same rules, but additionally handles\n * primitive types and, for non-arrays, fully-qualified names.\n * @param className name of the class\n * @return the Class corresponding to className\n * @throws ClassNotFoundException if the class is not found\n */\n// The annotation encourages proper use, even though this can take a\n// fully-qualified name (only for a non-array).\npublic static Class<?> classForName(/*@ClassGetName*/\nString className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n        return result;\n    } else {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            int pos = className.lastIndexOf('.');\n            if (pos < 0) {\n                throw e;\n            }\n            // checked below & exception is handled\n            @SuppressWarnings(\"signature\")\n            String /*@ClassGetName*/\n            inner_name = className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n            try {\n                return Class.forName(inner_name);\n            } catch (ClassNotFoundException ee) {\n                throw e;\n            }\n        }\n    }\n}"
            ],
            [
                "binaryNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a binary name to a field descriptor.\n * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n * or \"int\" to \"I\".\n * @param classname name of the class, in binary class name format\n * @return name of the class, in field descriptor format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@FieldDescriptor*/\nString binaryNameToFieldDescriptor(/*@BinaryName*/\nString classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n        dims++;\n        sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n        result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n        result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n}"
            ],
            [
                "primitiveTypeNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n * a field descriptor (e.g., \"I\", \"D\", etc.).\n * @param primitive_name name of the type, in Java format\n * @return name of the type, in field descriptor format\n * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n */\npublic static /*@FieldDescriptor*/\nString primitiveTypeNameToFieldDescriptor(String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n        throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n}"
            ],
            [
                "binaryNameToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a BinaryName to the format of {@link Class#getName()}.\n * @param bn the binary name to convert\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString binaryNameToClassGetName(/*BinaryName*/\nString bn) {\n    if (bn.endsWith(\"[]\")) {\n        return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n        return bn;\n    }\n}"
            ],
            [
                "fieldDescriptorToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n * @param fd the class, in field descriptor format\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString fieldDescriptorToClassGetName(/*FieldDescriptor*/\nString fd) {\n    if (fd.startsWith(\"[\")) {\n        return fd.replace('/', '.');\n    } else {\n        return fieldDescriptorToBinaryName(fd);\n    }\n}"
            ],
            [
                "arglistToJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert a fully-qualified argument list from Java format to JVML format.\n * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n * @param arglist an argument list, in Java format\n * @return argument list, in JVML format\n */\npublic static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n        // substring\n        @SuppressWarnings(\"signature\")\n        String /*@BinaryName*/\n        arg = args_tokenizer.nextToken().trim();\n        result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n}"
            ],
            [
                "fieldDescriptorToBinaryName",
                "plume",
                "UtilMDE",
                "// does not convert \"V\" to \"void\".  Should it?\n/**\n * Convert a field descriptor to a binary name.\n * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n * or \"I\" to \"int\".\n * @param classname name of the type, in JVML format\n * @return name of the type, in Java format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@BinaryName*/\nString fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n        throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n        dims++;\n        classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n        result = classname.substring(1, classname.length() - 1);\n    } else {\n        result = primitiveClassesFromJvm.get(classname);\n        if (result == null) {\n            throw new Error(\"Malformed base class: \" + classname);\n        }\n    }\n    for (int i = 0; i < dims; i++) {\n        result += \"[]\";\n    }\n    return result.replace('/', '.');\n}"
            ],
            [
                "arglistFromJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert an argument list from JVML format to Java format.\n * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n * @param arglist an argument list, in JVML format\n * @return argument list, in Java format\n */\npublic static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n        if (pos > 1) {\n            result += \", \";\n        }\n        int nonarray_pos = pos;\n        while (arglist.charAt(nonarray_pos) == '[') {\n            nonarray_pos++;\n        }\n        char c = arglist.charAt(nonarray_pos);\n        if (c == 'L') {\n            int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n            result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n            pos = semi_pos + 1;\n        } else {\n            String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n            if (maybe == null) {\n                // return null;\n                throw new Error(\"Malformed arglist: \" + arglist);\n            }\n            result += maybe;\n            pos = nonarray_pos + 1;\n        }\n    }\n    return result + \")\";\n}"
            ],
            [
                "defineClassFromFile",
                "plume",
                "UtilMDE",
                "/**\n * Converts the bytes in a file into an instance of class Class, and\n * resolves (links) the class.\n * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n * file name rather than an array of bytes as an argument, and also resolves\n * (links) the class.\n * @see ClassLoader#defineClass(String,byte[],int,int)\n * @param className the name of the class to define, or null if not known\n * @param pathname the pathname of a .class file\n * @return a Java Object corresponding to the Class defined in the .class file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\n// Also throws UnsupportedClassVersionError and some other exceptions.\npublic static Class<?> defineClassFromFile(/*@BinaryName*/\nString className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n}"
            ],
            [
                "count_lines",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// File\n///\n/**\n * Count the number of lines in the specified file.\n * @param filename file whose size to count\n * @return number of lines in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n        while (reader.readLine() != null) {\n            count++;\n        }\n    }\n    return count;\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param filename the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param file the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n        int unix = 0;\n        int dos = 0;\n        int mac = 0;\n        while (true) {\n            String s = r.readLine();\n            if (s == null) {\n                break;\n            }\n            if (s.endsWith(\"\\r\\n\")) {\n                dos++;\n            } else if (s.endsWith(\"\\r\")) {\n                mac++;\n            } else if (s.endsWith(\"\\n\")) {\n                unix++;\n            } else {\n                // This can happen only if the last line is not terminated.\n            }\n        }\n        if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n            return \"\\r\\n\";\n        }\n        if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n            return \"\\r\";\n        }\n        if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n            return \"\\n\";\n        }\n        // The two non-preferred line endings are tied and have more votes than\n        // the preferred line ending.  Give up and return the line separator\n        // for the system on which Java is currently running.\n        return lineSep;\n    }\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @return true iff the files have the same contents\n */\n/*@Pure*/\npublic static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff the files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @param trimLines if true, call String.trim on each line before comparing\n * @return true iff the files have the same contents\n */\n// reads files, side effects local state\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2)) {\n        String line1 = reader1.readLine();\n        String line2 = reader2.readLine();\n        while (line1 != null && line2 != null) {\n            if (trimLines) {\n                line1 = line1.trim();\n                line2 = line2.trim();\n            }\n            if (!(line1.equals(line2))) {\n                return false;\n            }\n            line1 = reader1.readLine();\n            line2 = reader2.readLine();\n        }\n        if (line1 == null && line2 == null) {\n            return true;\n        }\n        return false;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}"
            ],
            [
                "canCreateAndWrite",
                "plume",
                "UtilMDE",
                "/**\n * Returns true\n *  if the file exists and is writable, or\n *  if the file can be created.\n * @param file the file to create and write\n * @return true iff the file can be created and written\n */\npublic static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n        return file.canWrite();\n    } else {\n        File directory = file.getParentFile();\n        if (directory == null) {\n            directory = new File(\".\");\n        }\n        // Does this test need \"directory.canRead()\" also?\n        return directory.canWrite();\n    }\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n}"
            ],
            [
                "createTempDir",
                "plume",
                "UtilMDE",
                "///\n/// Directories\n///\n/**\n * Creates an empty directory in the default temporary-file directory,\n * using the given prefix and suffix to generate its name. For example,\n * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n * someString is internally generated to ensure no temporary files of the\n * same name are generated.\n * @param prefix the prefix string to be used in generating the file's\n *  name; must be at least three characters long\n * @param suffix the suffix string to be used in generating the file's\n *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n *  An abstract pathname denoting a newly-created empty file\n * @return a File representing the newly-created temporary directory\n * @throws IllegalArgumentException If the prefix argument contains fewer\n *  than three characters\n * @throws IOException If a file could not be created\n * @throws SecurityException If a security manager exists and its\n *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n *  file to be created\n * @see java.io.File#createTempFile(String, String, File)\n */\npublic static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dirName and all its files.\n * @param dirName the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dir and all its files.\n * @param dir the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n        return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    return dir.delete();\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name file whose name to expand\n * @return file with expanded file\n */\npublic static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n        return new File(newname);\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name filename to expand\n * @return expanded filename\n */\npublic static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n        return (name.replace(\"~\", userHome));\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "java_source",
                "plume",
                "UtilMDE",
                "/**\n * Return a string version of the name that can be used in Java source.\n * On Windows, the file will return a backslash separated string.  Since\n * backslash is an escape character, it must be quoted itself inside\n * the string.\n * <p>\n * The current implementation presumes that backslashes don't appear\n * in filenames except as windows path separators.  That seems like a\n * reasonable assumption.\n *\n * @param name file to quote\n * @return a string version of the name that can be used in Java source\n */\npublic static String java_source(File name) {\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n}"
            ],
            [
                "readObject",
                "plume",
                "UtilMDE",
                "/**\n * Reads an Object from a File.\n * @param file the file from which to read\n * @return the object read from the file\n * @throws IOException if there is trouble reading the file\n * @throws ClassNotFoundException if the object's class cannot be found\n */\npublic static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            istream = new GZIPInputStream(istream);\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n}"
            ],
            [
                "readerContents",
                "plume",
                "UtilMDE",
                "/**\n * Reads the entire contents of the reader and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param r the Reader to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readerContents(Reader r) {\n    try {\n        StringBuilder contents = new StringBuilder();\n        int ch;\n        while ((ch = r.read()) != -1) {\n            contents.append((char) ch);\n        }\n        r.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n}"
            ],
            [
                "readFile",
                "plume",
                "UtilMDE",
                "// an alternate name would be \"fileContents\".\n/**\n * Reads the entire contents of the file and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param file the file to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readFile(File file) {\n    try {\n        BufferedReader reader = UtilMDE.bufferedFileReader(file);\n        StringBuilder contents = new StringBuilder();\n        String line = reader.readLine();\n        while (line != null) {\n            contents.append(line);\n            // Note that this converts line terminators!\n            contents.append(lineSep);\n            line = reader.readLine();\n        }\n        reader.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Hashing\n///\n// In hashing, there are two separate issues.  First, one must convert\n// the input datum into an integer.  Then, one must transform the\n// resulting integer in a pseudorandom way so as to result in a number\n// that is far separated from other values that may have been near it to\n// begin with.  Often these two steps are combined, particularly if\n// one wishes to avoid creating too large an integer (losing information\n// off the top bits).\n// http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n//  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n//    h += (h<<3); h ^= (h>>11); h += (h<<15);\n//    is good.\n//  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n//  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n// In this part of the file, perhaps I will eventually write good hash\n// functions.  For now, write cheesy ones that primarily deal with the\n// first issue, transforming a data structure into a single number.  This\n// is also known as fingerprinting.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Double#hashCode()}.\n * @param x value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a) {\n    double result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a, double[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/// Don't define hash with int args; use the long versions instead.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Long#hashCode()}.\n * But it doesn't map -1 and 0 to the same value.\n * @param l value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n        return (int) l;\n    }\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a, long[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a) {\n    return (a == null) ? 0 : a.hashCode();\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b, /*@Nullable*/\nString c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + hash(a[i]);\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @param random the Random instance to use to make selections\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n    while (itor.hasNext()) {\n        rs.accept(itor.next());\n    }\n    return rs.getValues();\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n}"
            ],
            [
                "incrementMap",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Map\n///\n// In Python, inlining this gave a 10x speed improvement.\n// Will the same be true for Java?\n/**\n * Increment the Integer which is indexed by key in the Map.\n * If the key isn't in the Map, it is added.\n * @param <T> type of keys in the map\n * @param m map to have one of its values incremented\n * @param key the key for the element whose value will be incremented\n * @param count how much to increment the value by\n * @return the old value, before it was incremented\n * @throws Error if the key is in the Map but maps to a non-Integer.\n */\npublic static <T> /*@Nullable*/\nInteger incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n        new_total = count;\n    } else {\n        new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n}"
            ],
            [
                "mapToString",
                "plume",
                "UtilMDE",
                "/**\n * Returns a multi-line string representation of a map.\n * @param <K> type of map keys\n * @param <V> type of map values\n * @param m map to be converted to a string\n * @return a multi-line string representation of m\n */\npublic static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @return a sorted version of m.keySet()\n */\npublic static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @param comparator the Comparator to use for sorting\n * @return a sorted version of m.keySet()\n */\npublic static <K, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m, Comparator<K> comparator) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a method signature, return the method.\n * Example calls are:\n * <pre>\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n * </pre>\n * @param method a method signature\n * @return the method corresponding to the given signature\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n        throw new Error(\"malformed method name should contain a period, open paren, and close paren: \" + method + \" <<\" + dotpos + \",\" + oparenpos + \",\" + cparenpos + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n        if (!Character.isWhitespace(method.charAt(i))) {\n            throw new Error(\"malformed method name should contain only whitespace following close paren\");\n        }\n    }\n    // throws exception if class does not exist\n    @SuppressWarnings(\"signature\")\n    String /*@BinaryNameForNonArray*/\n    classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n        String[] argnames;\n        if (all_argnames.equals(\"\")) {\n            argnames = new String[0];\n        } else {\n            argnames = split(all_argnames, ',');\n        }\n        /*@MonotonicNonNull*/\n        Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n        for (int i = 0; i < argnames.length; i++) {\n            String bnArgname = argnames[i].trim();\n            /*@ClassGetName*/\n            String cgnArgname = binaryNameToClassGetName(bnArgname);\n            argclasses_tmp[i] = classForName(cgnArgname);\n        }\n        @SuppressWarnings(\"cast\")\n        Class<?>[] argclasses_res = (Class<?>[]) argclasses_tmp;\n        argclasses = argclasses_res;\n        args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a class name and a method name in that class, return the method.\n * @param classname class in which to find the method\n * @param methodname the method name\n * @param params the parameters of the method\n * @return the method named classname.methodname with parameters params\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(/*@BinaryNameForNonArray*/\nString classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// ProcessBuilder\n///\n/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line\n * @return all the output of the command\n */\npublic static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line, as a list of\n * strings (the command, then its arguments)\n * @return all the output of the command\n */\npublic static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n        Process p = pb.start();\n        @SuppressWarnings(// input stream is non-null because we didn't redirect the input stream\n        \"nullness\")\n        String output = UtilMDE.streamString(p.getInputStream());\n        return output;\n    } catch (IOException e) {\n        return \"IOException: \" + e.getMessage();\n    }\n}"
            ],
            [
                "propertyIsTrue",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Properties\n///\n/**\n * Determines whether a property has value \"true\", \"yes\", or \"1\".\n * @see Properties#getProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @return true iff the property has value \"true\", \"yes\", or \"1\"\n */\n// does not depend on object identity\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n        return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n}"
            ],
            [
                "appendProperty",
                "plume",
                "UtilMDE",
                "/**\n * Set the property to its previous value concatenated to the given value.\n * Return the previous value.\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to concatenate to the previous value of the property\n * @return the previous value of the property\n * @see Properties#getProperty\n * @see Properties#setProperty\n */\npublic static /*@Nullable*/\nString appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n}"
            ],
            [
                "setDefaultMaybe",
                "plume",
                "UtilMDE",
                "/**\n * Set the property only if it was not previously set.\n * @see Properties#getProperty\n * @see Properties#setProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to set the property to, if it is not already set\n * @return the previous value of the property\n */\npublic static /*@Nullable*/\nString setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n        p.setProperty(key, value);\n    }\n    return currentValue;\n}"
            ],
            [
                "getPrivateField",
                "plume",
                "UtilMDE",
                "// TODO: set the field back to private after is is accessed.\n/**\n * Reads the given field, which may be private.\n * Leaves the field accessible.\n * Use with care!\n * @param o object in which to set the field\n * @param fieldName name of field to set\n * @return new value of field\n * @throws NoSuchFieldException if the field does not exist in the object\n */\npublic static /*@Nullable*/\nObject getPrivateField(Object o, String fieldName) throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) {\n        // Class is interned\n        // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n        try {\n            Field f = c.getDeclaredField(fieldName);\n            f.setAccessible(true);\n            return f.get(o);\n        } catch (IllegalAccessException e) {\n            System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n            throw new Error(\"This can't happen: \" + e);\n        } catch (NoSuchFieldException e) {\n            if (c.getSuperclass() == Object.class) {\n                // Class is interned\n                throw e;\n            }\n            // nothing to do; will now examine superclass\n        }\n        c = c.getSuperclass();\n        assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n}"
            ],
            [
                "getFromSet",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set\n///\n/**\n * Return the object in this set that is equal to key.\n * The Set abstraction doesn't provide this; it only provides \"contains\".\n * Returns null if the argument is null, or if it isn't in the set.\n * @param set a set in which to look up the value\n * @param key the value to look up in the set\n * @return the object in this set that is equal to key, or null\n */\npublic static /*@Nullable*/\nObject getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n        return null;\n    }\n    for (Object elt : set) {\n        if (key.equals(elt)) {\n            return elt;\n        }\n    }\n    return null;\n}"
            ],
            [
                "streamString",
                "plume",
                "UtilMDE",
                "/**\n * Return a String containing all the characters from the input stream.\n * @param is input stream to read\n * @return a String containing all the characters from the input stream\n */\npublic static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n}"
            ],
            [
                "replaceString",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// String\n///\n/**\n * Return a new string which is the text of target with all instances of\n * oldStr replaced by newStr.\n * @param target the string to do replacement in\n * @param oldStr the substring to replace\n * @param newStr the replacement\n * @return target with all instances of oldStr replaced by newStr\n */\npublic static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n        throw new IllegalArgumentException();\n    }\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n        result.append(target.substring(lastend, pos));\n        result.append(newStr);\n        lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter character.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, String delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter String.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, char delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n        throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "splitLines",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings, one for each line in the argument.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n * are supported.  Note that a string that ends with a line separator\n * will return an empty string as the last element of the array.\n * @see #split(String s, char delim)\n * @param s the string to split\n * @return an array of Strings, one for each line in the argument\n */\npublic static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the array elements, placing the\n * delimiter between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n        return \"\";\n    }\n    if (a.length == 1) {\n        return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n        sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(Object... a) {\n    return join(a, lineSep);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * delimiter between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n        return \"\";\n    }\n    if (v.size() == 1) {\n        return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n        sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(List<String> v) {\n    return join(v, lineSep);\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Escape \\, \", newline, and carriage-return characters in the\n * target as \\\\, \\\", \\n, and \\r; return a new string if any\n * modifications were necessary.  The intent is that by surrounding\n * the return value with double quote marks, the result will be a\n * Java string literal denoting the original string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        switch(c) {\n            case '\\\"':\n            case '\\\\':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append('\\\\');\n                post_esc = i;\n                break;\n            case // not lineSep\n            '\\n':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                // not lineSep\n                sb.append(\"\\\\n\");\n                post_esc = i + 1;\n                break;\n            case '\\r':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append(\"\\\\r\");\n                post_esc = i + 1;\n                break;\n            default:\n        }\n    }\n    if (sb.length() == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "// The overhead of this is too high to call in escapeNonJava(String), so\n// it is inlined there.\n/**\n * Like {@link #escapeNonJava(String)}, but for a single character.\n * @param ch character to quote\n * @return quoted version och ch\n */\npublic static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch(c) {\n        case '\\\"':\n            return \"\\\\\\\"\";\n        case '\\\\':\n            return \"\\\\\\\\\";\n        case // not lineSep\n        '\\n':\n            // not lineSep\n            return \"\\\\n\";\n        case '\\r':\n            return \"\\\\r\";\n        default:\n            return new String(new char[] { c });\n    }\n}"
            ],
            [
                "escapeNonASCII",
                "plume",
                "UtilMDE",
                "/**\n * Escape unprintable characters in the target, following the usual\n * Java backslash conventions, so that the result is sure to be\n * printable ASCII.  Returns a new string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n}"
            ],
            [
                "unescapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n * one-character equivalents.  All other backslashes are removed\n * (for instance, octal/hex escape sequences are not turned into\n * their respective characters). This is the inverse operation of\n * escapeNonJava(). Previously known as unquote().\n * @param orig string to quoto\n * @return quoted version of orig\n */\npublic static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n        if (this_esc == orig.length() - 1) {\n            sb.append(orig.substring(post_esc, this_esc + 1));\n            post_esc = this_esc + 1;\n            break;\n        }\n        switch(orig.charAt(this_esc + 1)) {\n            case 'n':\n                sb.append(orig.substring(post_esc, this_esc));\n                // not lineSep\n                sb.append('\\n');\n                post_esc = this_esc + 2;\n                break;\n            case 'r':\n                sb.append(orig.substring(post_esc, this_esc));\n                sb.append('\\r');\n                post_esc = this_esc + 2;\n                break;\n            case '\\\\':\n                // This is not in the default case because the search would find\n                // the quoted backslash.  Here we incluce the first backslash in\n                // the output, but not the first.\n                sb.append(orig.substring(post_esc, this_esc + 1));\n                post_esc = this_esc + 2;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                sb.append(orig.substring(post_esc, this_esc));\n                char octal_char = 0;\n                int ii = this_esc + 1;\n                while (ii < orig.length()) {\n                    char ch = orig.charAt(ii++);\n                    if ((ch < '0') || (ch > '8')) {\n                        break;\n                    }\n                    octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n                }\n                sb.append(octal_char);\n                post_esc = ii - 1;\n                break;\n            default:\n                // In the default case, retain the character following the backslash,\n                // but discard the backslash itself.  \"\\*\" is just a one-character string.\n                sb.append(orig.substring(post_esc, this_esc));\n                post_esc = this_esc + 1;\n                break;\n        }\n        this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "removeWhitespaceAround",
                "plume",
                "UtilMDE",
                "// Use the built-in String.trim()!\n// /** Return the string with all leading and trailing whitespace stripped. */\n// public static String trimWhitespace(String s) {\n//   int len = s.length();\n//   if (len == 0)\n//     return s;\n//   int first_non_ws = 0;\n//   int last_non_ws = len-1;\n//   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n//     first_non_ws++;\n//   if (first_non_ws == len)\n//     return \"\";\n//   while (Character.isWhitespace(s.charAt(last_non_ws)))\n//     last_non_ws--;\n//   if ((first_non_ws == 0) && (last_non_ws == len)) {\n//     return s;\n//   } else {\n//     return s.substring(first_non_ws, last_non_ws+1);\n//   }\n// }\n// // // Testing:\n// // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n// // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n// // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n/**\n * Remove all whitespace before or after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace abutting\n * @return version of arg, with whitespace abutting delimiter removed\n */\npublic static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n}"
            ],
            [
                "removeWhitespaceAfter",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace after\n * @return version of arg, with whitespace after delimiter removed\n */\npublic static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index + delim_len;\n        while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index++;\n        }\n        // if (non_ws_index == arg.length()) {\n        //   System.out.println(\"No nonspace character at end of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index + delim_len) {\n            arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n        }\n        delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n}"
            ],
            [
                "removeWhitespaceBefore",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace before instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace before\n * @return version of arg, with whitespace before delimiter removed\n */\npublic static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index - 1;\n        while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index--;\n        }\n        // if (non_ws_index == -1) {\n        //   System.out.println(\"No nonspace character at front of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index - 1) {\n            arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n        }\n        delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n}"
            ],
            [
                "nplural",
                "plume",
                "UtilMDE",
                "/**\n * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n * @param n count of nouns\n * @param noun word being counted\n * @return noun, if n==1; otherwise, pluralization of noun\n */\npublic static String nplural(int n, String noun) {\n    if (n == 1) {\n        return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\") || noun.endsWith(\"s\") || noun.endsWith(\"sh\") || noun.endsWith(\"x\")) {\n        return n + \" \" + noun + \"es\";\n    } else {\n        return n + \" \" + noun + \"s\";\n    }\n}"
            ],
            [
                "lpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the left if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String lpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString() + s;\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the right if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String rpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n * @param num int whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n * @param num double whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the character appears in the string.\n * @param s string to search in\n * @param ch character to search for\n * @return number of times the character appears in the string\n */\npublic static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the second string appears in the first.\n * @param s string to search in\n * @param sub string to search for\n * @return number of times the substring appears in the string\n */\npublic static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// StringTokenizer\n///\n/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n * <p>\n * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n * (probably due to backward-compatibility).\n * @param str a string to be parsed\n * @param delim the delimiters\n * @param returnDelims flag indicating whether to return the delimiters as tokens\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n * @param str a string to be parsed\n * @param delim the delimiters\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n * @param str a string to be parsed\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n}"
            ],
            [
                "backTrace",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Throwable\n///\n/**\n * Return a String representation of the backtrace of the given Throwable.\n * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n * @param t the Throwable to obtain a backtrace of\n * @return a String representation of the backtrace of the given Throwable\n */\npublic static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n}"
            ],
            [
                "sortList",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Collections\n///\n/**\n * Return the sorted version of the list.  Does not alter the list.\n * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n * @return a sorted version of the list\n * @param <T> type of elements of the list\n * @param l a list to sort\n * @param c a sorted version of the list\n */\npublic static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n}"
            ],
            [
                "removeDuplicates",
                "plume",
                "UtilMDE",
                "// This should perhaps be named withoutDuplicates to emphasize that\n// it does not side-effect its argument.\n/**\n * Return a copy of the list with duplicates removed.\n * Retains the original order.\n * @param <T> type of elements of the list\n * @param l a list to remove duplicates from\n * @return a copy of the list with duplicates removed\n */\npublic static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n}"
            ],
            [
                "deepEquals",
                "plume",
                "UtilMDE",
                "/**\n * Determines deep equality for the elements.\n * <ul>\n * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n * <li>If both are lists, uses deepEquals recursively on each element.\n * <li>For other types, just uses equals() and does not recursively call this method.\n * </ul>\n * @param o1 first value to compare\n * @param o2 second value to comare\n * @return true iff o1 and o2 are deeply equal\n */\n// side effect to static field deepEqualsUnderway\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean deepEquals(/*@Nullable*/\nObject o1, /*@Nullable*/\nObject o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    // creates local state\n    @SuppressWarnings(\"purity\")\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n        return true;\n    }\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n        List<?> l1 = (List<?>) o1;\n        List<?> l2 = (List<?>) o2;\n        if (l1.size() != l2.size()) {\n            return false;\n        }\n        try {\n            deepEqualsUnderway.add(mypair);\n            for (int i = 0; i < l1.size(); i++) {\n                Object e1 = l1.get(i);\n                Object e2 = l2.get(i);\n                if (!deepEquals(e1, e2)) {\n                    return false;\n                }\n            }\n        } finally {\n            deepEqualsUnderway.remove(mypair);\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}"
            ],
            [
                "makeVector",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Vector\n///\n/**\n * Returns a vector containing the elements of the enumeration.\n * @param <T> type of the enumeration and vector elements\n * @param e an enumeration to convert to a Vector\n * @return a vector containing the elements of the enumeration\n */\npublic static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n        result.addElement(e.nextElement());\n    }\n    return result;\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "// Rather than writing something like VectorToStringArray, use\n//   v.toArray(new String[0])\n/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of the specified objects starting at index\n * start over dims dimensions, for dims &gt; 0.\n * <p>\n * For example, create_combinations (1, 0, {a, b, c}) returns:\n * <pre>\n *    {a}, {b}, {c}\n * </pre>\n * And create_combinations (2, 0, {a, b, c}) returns:\n * <pre>\n *    {a, a}, {a, b}, {a, c}\n *    {b, b}, {b, c},\n *    {c, c}\n * </pre>\n * @param <T> type of the input list elements, and type of the innermost output list elements\n * @param dims number of dimensions:  that is, size of each innermost list\n * @param start initial index\n * @param objs list of elements to\n * @return list of lists of length dims, each of which combines elements from objs\n */\npublic static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n    if (dims < 1) {\n        throw new IllegalArgumentException();\n    }\n    List<List<T>> results = new ArrayList<List<T>>();\n    for (int i = start; i < objs.size(); i++) {\n        if (dims == 1) {\n            List<T> simple = new ArrayList<T>();\n            simple.add(objs.get(i));\n            results.add(simple);\n        } else {\n            List<List<T>> combos = create_combinations(dims - 1, i, objs);\n            for (List<T> lt : combos) {\n                List<T> simple = new ArrayList<T>();\n                simple.add(objs.get(i));\n                simple.addAll(lt);\n                results.add(simple);\n            }\n        }\n    }\n    return (results);\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of integers from start to cnt (inclusive) over\n * arity dimensions.\n * <p>\n * For example, create_combinations (1, 0, 2) returns:\n * <pre>\n *    {0}, {1}, {2}\n * </pre>\n * And create_combinations (2, 0, 2) returns:\n * <pre>\n *    {0, 0}, {0, 1}, {0, 2}\n *    {1, 1}  {1, 2},\n *    {2, 2}\n * </pre>\n * @param arity size of each innermost list\n * @param start initial value\n * @param cnt maximum element value\n * @return list of lists of length arity, each of which combines integers from start to cnt\n */\npublic static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n        results.add(new ArrayList<Integer>());\n        return (results);\n    }\n    for (int i = start; i <= cnt; i++) {\n        ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n        for (ArrayList<Integer> li : combos) {\n            ArrayList<Integer> simple = new ArrayList<Integer>();\n            simple.add(new Integer(i));\n            simple.addAll(li);\n            results.add(simple);\n        }\n    }\n    return (results);\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(/*@FullyQualifiedName*/\nString qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n}"
            ],
            [
                "fullyQualifiedNameToSimpleName",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n// TODO: does not follow the specification for inner classes (where the\n// type name should be empty), but I think this is more informative anyway.\n// string conversion\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetSimpleName*/\nString fullyQualifiedNameToSimpleName(/*@FullyQualifiedName*/\nString qualified_name) {\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n        return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified class.  For example if qualified name of the class\n * is java.lang.String, String will be returned.\n *\n * @deprecated use {@link Class#getSimpleName()} instead.\n *\n * @param cls a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n}"
            ],
            [
                "abbreviateNumber",
                "plume",
                "UtilMDE",
                "/**\n * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n * of precision in the result (counting both sides of the decimal point).\n * @param val a numeric value\n * @return an abbreviated string representation of the value\n */\npublic static String abbreviateNumber(long val) {\n    double dval = (double) val;\n    String mag = \"\";\n    if (val < 1000) {\n        // nothing to do\n    } else if (val < 1000000) {\n        dval = val / 1000.0;\n        mag = \"K\";\n    } else if (val < 1000000000) {\n        dval = val / 1000000.0;\n        mag = \"M\";\n    } else {\n        dval = val / 1000000000.0;\n        mag = \"G\";\n    }\n    String precision = \"0\";\n    if (dval < 10) {\n        precision = \"2\";\n    } else if (dval < 100) {\n        precision = \"1\";\n    }\n    // format string computed from precision and mag\n    @SuppressWarnings(\"formatter\")\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeIntSet",
                "/**\n * Merges a list of LimitedSizeIntSet objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param max_values the maximum size for the returned LimitedSizeIntSet\n * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n * @return a LimitedSizeIntSet that merges the elements of slist\n */\npublic static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist) {\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ],
            [
                "of",
                "plume",
                "Triple",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param <C> type of third argument\n * @param a first argument\n * @param b second argument\n * @param c third argument\n * @return a triple of the values (a, b, c)\n */\npublic static <A, B, C> Triple<A, B, C> of(A a, B b, C c) {\n    return new Triple<A, B, C>(a, b, c);\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// min, max\n///\n// Could also add linear-time orderStatistics if I liked.\n/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int min(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long min(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double min(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer min(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long min(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() < result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double min(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int max(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long max(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double max(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer max(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long max(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() > result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double max(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int[] min_max(int[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] { result_min, result_max };\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long[] min_max(long[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] { result_min, result_max };\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int element_range(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long element_range(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of integers.\n * @param a an array\n * @return the sum of an array of integers\n */\npublic static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of integers.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of integers\n */\npublic static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of doubles.\n * @param a an array\n * @return the sum of an array of doubles\n */\npublic static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of doubles.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of doubles\n */\npublic static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf\n///\n/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> type of the elements of the array\n * @param a an array\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt) {\n    if (elt == null) {\n        return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> the type of the elements\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n *    Identical to List.indexOf, but included for completeness.\n * @param a a list\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    return a.indexOf(elt);\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a.get(i))) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyNull*/\nObject[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.size(); i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf, for finding subarrays\n///\n// This is analogous to Common Lisp's \"search\" function.\n// This implementation is very inefficient; I could use tricky Boyer-Moore\n// search techniques if I liked, but it's not worth it to me yet.\n/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n// The signature on this method is unnecessarily strict because it\n// requires that the component types be identical.  The signature should\n// be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n// @PolyAll qualifier does not yet take an argument.\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// mismatch\n///\n// This is analogous to Common Lisp's \"mismatch\" function.\n// Put it off until later; for now, use the simpler subarray function,\n// which is a specialization of mismatch,\n///////////////////////////////////////////////////////////////////////////\n/// subarray extraction\n///\n// Note that the second argument is a length, not an end position.\n// That's to avoid confusion over whether it would be the last included\n// index or the first non-included index.\n/**\n * Return a subarray of the given array.\n * @return a subarray of the given array\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n */\n/*@SideEffectFree*/\npublic static Object[] subarray(/*@PolyAll*/\nObject[] a, int startindex, int length) {\n    /*@PolyAll*/\n    Object[] result = new /*@PolyAll*/\n    Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a sublist of the given list.\n * @param <T> type of the elements\n * @param a the original list\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a sublist of the given list\n */\n/*@SideEffectFree*/\npublic static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static String[] subarray(/*@PolyAll*/\nString[] a, int startindex, int length) {\n    /*@PolyAll*/\n    String[] result = new /*@PolyAll*/\n    String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// subarray testing\n///\n/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, /*@PolyNull*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.size()];\n            System.arraycopy(a, 0, result, 0, a.length);\n            // System.arraycopy(b, 0, result, a.length, b.size());\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.length] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.length];\n            // System.arraycopy(a, 0, result, 0, a.size());\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            System.arraycopy(b, 0, result, a.size(), b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.size()];\n            // System.arraycopy(a, 0, result, 0, a.length);\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            // System.arraycopy(b, 0, result, a.length, b.length);\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.size()] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "// Note: PolyAll is not quite right.  Need to review.\n/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first array to concatenate\n * @param b the second array to concatenate\n * @return an array that concatenates the arguments\n */\npublic static String[] concat(/*@PolyAll*/\nString[] a, /*@PolyAll*/\nString[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new String[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            /*@PolyAll*/\n            String[] result = new String[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static byte[] concat(byte[] a, byte[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new byte[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            byte[] result = new byte[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static boolean[] concat(boolean[] a, boolean[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new boolean[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            boolean[] result = new boolean[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static char[] concat(char[] a, char[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new char[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            char[] result = new char[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static double[] concat(double[] a, double[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new double[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            double[] result = new double[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static float[] concat(float[] a, float[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new float[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            float[] result = new float[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static int[] concat(int[] a, int[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new int[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            int[] result = new int[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static long[] concat(long[] a, long[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new long[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            long[] result = new long[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static short[] concat(short[] a, short[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new short[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            short[] result = new short[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Printing\n///\n// This should be extended to all types, when I get around to it.  The\n// methods are patterned after that of java.util.Vector (and use its\n// output format).\n/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@PolyAll*/\nObject[] a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, each element is quoted like a Java String.\n * @param a an array\n * @return a string representation of the array, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@PolyAll*/\nObject[] a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, if quoted is true, then each element is quoted like a Java String.\n * @param a an array\n * @param quoted whether to quote the array elements\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@PolyAll*/\nObject[] a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            if (quoted && a[i] instanceof String) {\n                String elt = (String) a[i];\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava(elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(a[i]);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @param quoted whether to quote the collection elements that are Java strings\n * @return a string representation of the list\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@Nullable*/\nCollection<?> a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n        Iterator<?> itor = a.iterator();\n        sb.append(itor.next());\n        while (itor.hasNext()) {\n            sb.append(\", \");\n            Object elt = itor.next();\n            if (quoted && elt instanceof String) {\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava((String) elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(elt);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(int[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(long[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(double[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(float[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(boolean[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls the appropriate\n * toString() method.  Only call this method if obj is a boolean, double,\n * int, long, or Object array.\n * @param obj an array\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n        return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n        return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n        return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n        return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n        return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n        return toString((List<?>) obj);\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "length",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls .length.\n * Only call this method if obj is a boolean, double, int, long, or Object array.\n * @param obj a list\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n        return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n        return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n        return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n        return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n        return ((List<?>) obj).size();\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Sortedness\n///\n/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Boolean n = Boolean.valueOf(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Byte n = new Byte(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Float n = new Float(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Short n = new Short(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Integer n = new Integer(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space. Equality checking\n * uses the .equals() method for java.lang.Double.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Double n = new Double(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Long n = new Long(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param <T> the type of the elements\n * @param a a list\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static </*@Pure*/\nT> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n        if (hs.contains(a.get(i))) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a.get(i));\n    }\n    return true;\n}"
            ],
            [
                "fn_is_permutation",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Arrays as partial functions of int->int\n///\n/**\n * Returns true if the array is a permutation of [0..a.length).\n * @param a an array, representing a function\n * @return true iff all elements of a are in [0..a.length) and a\n * contains no duplicates.\n */\n// side effect to local state (array)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int n = a[i];\n        if (n < 0 || n >= a.length || see[n]) {\n            return false;\n        }\n        see[n] = true;\n    }\n    return true;\n}"
            ],
            [
                "fn_is_total",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff the array does not contain -1.\n * @param a an array, representing a function\n * @return true iff no element of a maps to -1\n */\n/*@Pure*/\npublic static boolean fn_is_total(int[] a) {\n    // not found\n    return indexOf(a, -1) == -1;\n}"
            ],
            [
                "fn_identity",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array [0..lenth).\n * @param length the length of the result\n * @return fresh array that is the identity function of the given length\n */\npublic static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n        result[i] = i;\n    }\n    return result;\n}"
            ],
            [
                "fn_inverse_permutation",
                "plume",
                "ArraysMDE",
                "/**\n * Requires that fn_is_permutation(a) holds.\n * @param a the input permutation\n * @return fresh array which is the inverse of the given permutation\n * @see #fn_is_permutation(int[])\n */\npublic static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n}"
            ],
            [
                "fn_inverse",
                "plume",
                "ArraysMDE",
                "/**\n * Return the inverse of the given function, which is represented as an array.\n * @param a an array representing a function from [0..a.length) to [0..arange);\n *  each element of a is between 0 and arange inclusive\n * @param arange length of the argument's range and the result's domain\n * @return function from [0..arange) to [0..a.length) that is the inverse of a\n * @throws IllegalArgumentException if a value of a is outside of arange\n * @exception UnsupportedOperationException when the function is not invertible\n */\npublic static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n        int ai = a[i];\n        if (ai < -1 || ai >= arange) {\n            throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n        }\n        // ai is either -1 or a valid index\n        if (ai >= 0) {\n            if (result[ai] != -1) {\n                throw new UnsupportedOperationException(String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n            }\n            result[ai] = i;\n        }\n    }\n    return result;\n}"
            ],
            [
                "fn_compose",
                "plume",
                "ArraysMDE",
                "/**\n * Return the composition of the given two functions, all of which are\n * represented as arrays.\n * @param a function from [0..a.length) to [0..b.length)\n * @param b function from [0..b.length) to range R\n * @return function from [0..a.length) to range R that is the\n * composition of a and b\n */\npublic static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int inner = a[i];\n        if (inner == -1) {\n            result[i] = -1;\n        } else {\n            result[i] = b[inner];\n        }\n    }\n    return result;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set operations, such as subset, unions, and intersections\n///\n// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Long(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Long elt = new Long(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Double(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Double elt = new Double(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(bigger[i]);\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        if (!setBigger.contains(smaller[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// nullness\n///\n/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(/*@PolyAll*/\nObject[] a) {\n    if (a.length == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(/*@PolyAll*/\nObject[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (!(a[i] == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n        if (!(a.get(i) == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "int_array_iterator",
                "plume",
                "TestPlume",
                "///////////////////////////////////////////////////////////////////////////\n/// Utility functions\n///\npublic static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n        asList.add(nums[i]);\n    }\n    return asList.iterator();\n}"
            ],
            [
                "int_iterator_array",
                "plume",
                "TestPlume",
                "public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    return v;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n        v.add(e.nextElement());\n    }\n    return v;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeSet",
                "/**\n * Merges a list of LimitedSizeSet&lt;T&gt; objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param <T> (super)type of elements of the sets\n * @param max_values the maximum size for the returned LimitedSizeSet\n * @param slist a list of LimitedSizeSet, whose elements will be merged\n * @return a LimitedSizeSet that merges the elements of slist\n */\npublic static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist) {\n    LimitedSizeSet<T> result = new LimitedSizeSet<T>(max_values);\n    for (LimitedSizeSet<? extends T> s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "serialVersionUID",
                "plume",
                "FileIOException",
                "static final long serialVersionUID = 20050923L;"
            ],
            [
                "counter",
                "plume",
                "DeterministicObject",
                "/**\n * The number of objects created so far.\n */\nstatic int counter = 0;"
            ],
            [
                "home",
                "plume",
                "MultiVersionControl",
                "@Option(value = \"User home directory\", noDocDefault = true)\npublic static String home = System.getProperty(\"user.home\");"
            ],
            [
                "debug",
                "plume",
                "MultiVersionControl",
                "// It would be good to be able to set this per-checkout.\n// This variable is static because it is used in static methods.\n@Option(\"Print debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "idf",
                "plume",
                "MultiVersionControl",
                "static IsDirectoryFilter idf = new IsDirectoryFilter();"
            ],
            [
                "help",
                "plume",
                "Lookup",
                "/**\n * Show detailed help information and exit.\n */\n@OptionGroup(\"Getting help\")\n@Option(\"-h Show detailed help information\")\npublic static boolean help = false;"
            ],
            [
                "verbose",
                "plume",
                "Lookup",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "entry_file",
                "plume",
                "Lookup",
                "// This uses only the first file because the default search path might be\n// something like user:system and you might want only your version of the\n// system files.  It might be useful to also support (via another flag,\n// or by taking over this one, or by the syntax of the separator, or in\n// some other way) specifying multiple files on the command line.\n/**\n * Specify the colon-separated search list for the file that contains\n * information to be searched.  Only the first file found is used, though\n * it may itself contain include directives.\n */\n@OptionGroup(\"Where to search\")\n@Option(\"-f Specify the colon-separated search list of files of information; may only be supplied once\")\npublic static String entry_file = \"~/lookup/root\";"
            ],
            [
                "search_body",
                "plume",
                "Lookup",
                "/**\n * Search the body of long entries in addition to the entry's\n * description.  The bodies of short entries are always searched.\n */\n@Option(\"-b Search body of long entries for matches\")\npublic static boolean search_body = false;"
            ],
            [
                "regular_expressions",
                "plume",
                "Lookup",
                "/**\n * Specifies that keywords are regular expressions.  If false, keywords\n * are text matches.\n */\n@OptionGroup(\"What to search for\")\n@Option(\"-e Keywords are regular expressions\")\npublic static boolean regular_expressions = false;"
            ],
            [
                "case_sensitive",
                "plume",
                "Lookup",
                "/**\n * If true, keywords matching is case sensistive.  By default, both\n * regular expressions and text keywords are case-insensitive.\n */\n@Option(\"-c Keywords are case sensistive\")\npublic static boolean case_sensitive = false;"
            ],
            [
                "word_match",
                "plume",
                "Lookup",
                "/**\n * If true, match a text keyword only as a separate word, not as a\n * substring of a word.  This option is ignored if\n * regular_expressions is true.\n */\n@Option(\"-w Only match text keywords against complete words\")\npublic static boolean word_match = false;"
            ],
            [
                "print_all",
                "plume",
                "Lookup",
                "/**\n * By default, if multiple entries are matched, only a synopsis\n * of each entry is printed.  If 'print_all' is selected then\n * the body of each matching entry is printed.\n */\n@OptionGroup(\"How to print matches\")\n@Option(\"-a Print the entire entry for each match\")\npublic static boolean print_all = false;"
            ],
            [
                "item_num",
                "plume",
                "Lookup",
                "/**\n * Specifies which item to print when there are multiple matches.\n * The index is 1-based; that is, it starts counting at 1.\n */\n@Option(\"-i Choose a specific item when there are multiple matches; index is 1-based\")\npublic static Integer /*@Nullable*/\nitem_num;"
            ],
            [
                "show_location",
                "plume",
                "Lookup",
                "/**\n * If true, show the filename/line number of each matching entry\n * in the output.\n */\n@Option(\"-l Show the location of each matching entry\")\npublic static boolean show_location = false;"
            ],
            [
                "entry_start_re",
                "plume",
                "Lookup",
                "@OptionGroup(\"Customizing format of files to be searched\")\n@Option(\"Regex that denotes the start of a long entry\")\npublic static Pattern /*@Regex(1)*/\nentry_start_re = Pattern.compile(\"^>entry *()\");"
            ],
            [
                "entry_stop_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that denotes the end of a long entry\")\npublic static Pattern entry_stop_re = Pattern.compile(\"^<entry\");"
            ],
            [
                "description_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that finds an entry's description (for long entries)\")\npublic static Pattern /*@Nullable*/\ndescription_re = null;"
            ],
            [
                "comment_re",
                "plume",
                "Lookup",
                "// If \"\", gets set to null immediately after option processing.\n@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Nullable*/\n/*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "runtime",
                "plume",
                "FileCompiler",
                "/**\n * The Runtime of the JVM.\n */\npublic static Runtime runtime = java.lang.Runtime.getRuntime();"
            ],
            [
                "java_filename_pattern",
                "plume",
                "FileCompiler",
                "/**\n * Matches the names of Java source files.\n * Match group 1 is the complete filename.\n */\nstatic Pattern /*@Regex(1)*/\njava_filename_pattern;"
            ],
            [
                "responsible",
                "plume",
                "TaskManager",
                "// Command line options\n@Option(\"-r Include only those tasks assigned to the specified person\")\npublic static String /*@Nullable*/\nresponsible = null;"
            ],
            [
                "milestone",
                "plume",
                "TaskManager",
                "@Option(\"-m Include only those tasks required for the specified milestone\")\npublic static String /*@Nullable*/\nmilestone = null;"
            ],
            [
                "completed",
                "plume",
                "TaskManager",
                "@Option(\"-c Include only completed tasks\")\npublic static boolean completed = false;"
            ],
            [
                "open",
                "plume",
                "TaskManager",
                "@Option(\"-o Include only open tasks\")\npublic static boolean open = false;"
            ],
            [
                "verbose",
                "plume",
                "TaskManager",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "format",
                "plume",
                "TaskManager",
                "@Option(\"-f Specify output format\")\npublic static OutputFormat format = OutputFormat.short_ascii;"
            ],
            [
                "comment_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "lineSep",
                "plume",
                "TaskManager",
                "// line.separator property is a legal regex\n@SuppressWarnings(\"regex\")\npublic static final String /*@Regex*/\nlineSep = System.getProperty(\"line.separator\");"
            ],
            [
                "minversion",
                "plume",
                "ClassFileVersion",
                "/**\n * Only report versions that are at least this large.\n */\nstatic double minversion = 0;"
            ],
            [
                "debug",
                "plume",
                "DeclarationAnnotations",
                "static boolean debug = false;"
            ],
            [
                "date",
                "plume",
                "ICalAvailable",
                "/// User options\n@Option(\"first date to summarize\")\npublic static String date = \"today\";"
            ],
            [
                "start_date",
                "plume",
                "ICalAvailable",
                "public static DateTime start_date = new DateTime();"
            ],
            [
                "days",
                "plume",
                "ICalAvailable",
                "@Option(\"number of calendar days to summarize\")\npublic static int days = 8;"
            ],
            [
                "iCal_URL",
                "plume",
                "ICalAvailable",
                "/**\n * For a Google calendar:  go to settings, then click on the green \"ICAL\"\n * icon for the \"private address\".\n */\n@Option(\"<url> schedule in iCal format\")\npublic static List<String> iCal_URL = new ArrayList<String>();"
            ],
            [
                "business_hours",
                "plume",
                "ICalAvailable",
                "/**\n * A list of time ranges, expressed as a String.\n * Example: 9am-5pm,7:30pm-9:30pm\n */\n@Option(\"time ranges during which appointments are permitted\")\npublic static String business_hours = \"9am-5pm\";"
            ],
            [
                "businessHours",
                "plume",
                "ICalAvailable",
                "// initialize to 9am-5pm\nstatic List<Period> businessHours = new ArrayList<Period>();"
            ],
            [
                "businessDays",
                "plume",
                "ICalAvailable",
                "// initialize to Mon-Fri\nstatic List<Integer> businessDays = new ArrayList<Integer>();"
            ],
            [
                "tzRegistry",
                "plume",
                "ICalAvailable",
                "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();"
            ],
            [
                "timezone1",
                "plume",
                "ICalAvailable",
                "/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * Available times are printed in this time zone.  It defaults to the\n * system time zone.\n */\n// don't need \"e.g.: America/New_York\" in message:  the default is an example\n@Option(value = \"<timezone> time zone, e.g.: America/New_York\", noDocDefault = true)\npublic static String timezone1 = TimeZone.getDefault().getID();"
            ],
            [
                "tz1",
                "plume",
                "ICalAvailable",
                "// Either of these initializations causes a NullPointerException\n// at net.fortuna.ical4j.model.TimeZone.<init>(TimeZone.java:67)\n// static TimeZone tz1 = new TimeZone(new VTimeZone());\n// static TimeZone tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));\nstatic TimeZone /*@MonotonicNonNull*/\ntz1;"
            ],
            [
                "timezone2",
                "plume",
                "ICalAvailable",
                "// If I'm outputting in a different timezone, then my notion of a \"day\"\n// may be different than the other timezone's notion of a \"day\".  This\n// doesn't seem important enough to fix right now.\n/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * If set, then free times are printed in two time zones.\n */\n@Option(\"<timezone> optional second time zone, e.g.: America/New_York\")\npublic static String /*@Nullable*/\ntimezone2;"
            ],
            [
                "tz2",
                "plume",
                "ICalAvailable",
                "static TimeZone /*@Nullable*/\ntz2;"
            ],
            [
                "debug",
                "plume",
                "ICalAvailable",
                "/// Other variables\n@Option(\"enable debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "calendars",
                "plume",
                "ICalAvailable",
                "/**\n * The appointments (the times that are unavailable for a meeting).\n */\nstatic List<Calendar> calendars = new ArrayList<Calendar>();"
            ],
            [
                "tf",
                "plume",
                "ICalAvailable",
                "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);"
            ],
            [
                "df",
                "plume",
                "ICalAvailable",
                "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);"
            ],
            [
                "dffull",
                "plume",
                "ICalAvailable",
                "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);"
            ],
            [
                "canonicalTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> canonicalTimezones = new HashMap<String, String>();"
            ],
            [
                "printedTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> printedTimezones = new HashMap<String, String>();"
            ],
            [
                "timeRegexp",
                "plume",
                "ICalAvailable",
                "static Pattern /*@Regex(4)*/\ntimeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");"
            ],
            [
                "dateFormats",
                "plume",
                "ICalAvailable",
                "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};"
            ],
            [
                "skip_checks",
                "plume",
                "BCELUtil",
                "/**\n * Controls whether the checks in checkMgen are actually performed.\n */\npublic static boolean skip_checks = false;"
            ],
            [
                "userHome",
                "plume",
                "UtilMDE",
                "static final String userHome = System.getProperty(\"user.home\");"
            ],
            [
                "args_seen",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Method\n///\n/**\n * Maps from a comma-delimited string of arg types, such as appears in a\n * method signature, to an array of Class objects, one for each arg\n * type. Example keys include: \"java.lang.String, java.lang.String,\n * java.lang.Class[]\" and \"int,int\".\n */\nstatic HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();"
            ],
            [
                "serialVersionUID",
                "plume",
                "UtilMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "NullableStringComparator",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeIntSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "split_lists",
                "plume",
                "Options",
                "/**\n * When true, an argument to a option of list type is split, on\n * whitespace, into multiple arguments each of which is added to the\n * list.  When false, each argument to an option of list type is treated\n * as a single element, no matter what characters it contains.\n */\n@Option(\"Treat arguments to lists as space-separated.\")\npublic static boolean split_lists = false;"
            ],
            [
                "serialVersionUID",
                "plume",
                "Options",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArgException",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "StringArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "short_run",
                "plume",
                "TestPlume",
                "// If true, do 100 instead of 100000 iterations when testing randomElements.\n// This saves only a little time.  However, it is significant when running\n// under instrumentation such as that of Chicory.\nstatic boolean short_run = false;"
            ],
            [
                "mass",
                "plume",
                "TestPlume",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestPlume",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestPlume",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "mass",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestOptionGroups1",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups2",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups3",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "FuzzyFloat",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "x",
                "",
                "int"
            ],
            [
                "y",
                "",
                "int"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 10046,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "plume-lib-1.1.0",
        "packageName": "plume",
        "className": "MathMDE",
        "javadocTag": "@param x first operand",
        "methodJavadoc": "    /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */",
        "methodSourceCode": "public static int logicalOr(int x, int y){\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}",
        "classJavadoc": "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
        "classSourceCode": "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "FileIOException",
                "plume"
            ],
            [
                "MathMDE",
                "plume"
            ],
            [
                "DeterministicObject",
                "plume"
            ],
            [
                "Digest",
                "plume"
            ],
            [
                "StringBuilderDelimited",
                "plume"
            ],
            [
                "OrderedPairIterator",
                "plume"
            ],
            [
                "CountingPrintWriter",
                "plume"
            ],
            [
                "MultiVersionControl",
                "plume"
            ],
            [
                "WeakIdentityHashMap",
                "plume"
            ],
            [
                "IterableIterator",
                "plume"
            ],
            [
                "Lookup",
                "plume"
            ],
            [
                "Pair",
                "plume"
            ],
            [
                "FileCompiler",
                "plume"
            ],
            [
                "MultiRandSelector",
                "plume"
            ],
            [
                "RandoopMappedCalls",
                "plume"
            ],
            [
                "Stopwatch",
                "plume"
            ],
            [
                "TaskManager",
                "plume"
            ],
            [
                "WeakHasherMap",
                "plume"
            ],
            [
                "ClassFileVersion",
                "plume"
            ],
            [
                "WeakIdentityPair",
                "plume"
            ],
            [
                "OptionsDoclet",
                "plume"
            ],
            [
                "DeclarationAnnotations",
                "plume"
            ],
            [
                "Option",
                "plume"
            ],
            [
                "RegexUtil",
                "plume"
            ],
            [
                "JWhich",
                "plume"
            ],
            [
                "TimeLimitProcess",
                "plume"
            ],
            [
                "Intern",
                "plume"
            ],
            [
                "GraphMDE",
                "plume"
            ],
            [
                "HtmlPrettyPrint",
                "plume"
            ],
            [
                "SimpleLog",
                "plume"
            ],
            [
                "OptionGroup",
                "plume"
            ],
            [
                "ICalAvailable",
                "plume"
            ],
            [
                "RandomSelector",
                "plume"
            ],
            [
                "BCELUtil",
                "plume"
            ],
            [
                "UtilMDE",
                "plume"
            ],
            [
                "Hasher",
                "plume"
            ],
            [
                "BibtexClean",
                "plume"
            ],
            [
                "LimitedSizeIntSet",
                "plume"
            ],
            [
                "Partitioner",
                "plume"
            ],
            [
                "Triple",
                "plume"
            ],
            [
                "Options",
                "plume"
            ],
            [
                "ArraysMDE",
                "plume"
            ],
            [
                "StrTok",
                "plume"
            ],
            [
                "Unpublicized",
                "plume"
            ],
            [
                "TestPlume",
                "plume"
            ],
            [
                "LimitedSizeSet",
                "plume"
            ],
            [
                "EntryReader",
                "plume"
            ],
            [
                "Filter",
                "plume"
            ],
            [
                "FuzzyFloat",
                "plume"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "negate",
                "plume",
                "MathMDE",
                "///\n/// Function versions of Java operators\n///\n/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static int negate(int a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static long negate(long a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static double negate(double a) {\n    return -a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static int bitwiseComplement(int a) {\n    return ~a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static long bitwiseComplement(long a) {\n    return ~a;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static int mul(int x, int y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static long mul(long x, long y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static double mul(double x, double y) {\n    return x * y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static int div(int x, int y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static long div(long x, long y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static double div(double x, double y) {\n    return x / y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static int mod(int x, int y) {\n    return x % y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static long mod(long x, long y) {\n    return x % y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static int lshift(int x, int y) {\n    return x << y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static long lshift(long x, long y) {\n    return x << y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static int rshiftSigned(int x, int y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static long rshiftSigned(long x, long y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static int bitwiseAnd(int x, int y) {\n    return x & y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static long bitwiseAnd(long x, long y) {\n    return x & y;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static int logicalAnd(int x, int y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static long logicalAnd(long x, long y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static int bitwiseXor(int x, int y) {\n    return x ^ y;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static long bitwiseXor(long x, long y) {\n    return x ^ y;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static int logicalXor(int x, int y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static long logicalXor(long x, long y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static int bitwiseOr(int x, int y) {\n    return x | y;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static long bitwiseOr(long x, long y) {\n    return x | y;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static int logicalOr(int x, int y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static long logicalOr(long x, long y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "sign",
                "plume",
                "MathMDE",
                "///\n/// sign\n///\n/**\n * Returns the sign of its argument.  The result is always -1, 0, or 1.\n * @param a value to have its sign taken\n * @return the sign of a: -1, 0, or 1\n */\npublic static int sign(int a) {\n    if (a == 0) {\n        return 0;\n    } else if (a > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "///\n/// exponentiation\n///\n/**\n * Returns of value of the first argument raised to the\n * power of the second argument.  The arguments are integers.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "/**\n * Returns of value of the first argument raised to the\n * power of the second argument.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "///\n/// gcd\n///\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static int gcd(int a, int b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        int tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/// gcd -- version for manipulating long (rather than int) values\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static long gcd(long a, long b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static double gcd(double a, double b) {\n    if (a == Double.POSITIVE_INFINITY || a == Double.NEGATIVE_INFINITY || Double.isNaN(a) || b == Double.POSITIVE_INFINITY || b == Double.NEGATIVE_INFINITY || Double.isNaN(b)) {\n        return Double.NaN;\n    }\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        double tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "///\n/// Modulus\n///\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nint mod_positive(int x, /*@PolyUpperBound*/\nint y) {\n    int result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static int[] modulus(int[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new int[] { remainder, modulus };\n}"
            ],
            [
                "modulus_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(int[])\n */\npublic static int[] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static int[] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    int modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(int[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().intValue();\n    }\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().intValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "/// modulus for long (as opposed to int) values\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nlong mod_positive(long x, /*@PolyUpperBound*/\nlong y) {\n    long result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static long[] modulus(long[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new long[] { remainder, modulus };\n}"
            ],
            [
                "modulus_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(long[])\n */\npublic static long[] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        long i = itor.next().longValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static long[] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    long modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(long[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().longValue();\n    }\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().longValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "///\n/// Non-Modulus\n///\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] missing_numbers(int[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length - 1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static int[] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   int range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2);\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = mod_positive(nums[i], m);\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new int[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "/// non-modulus for long (as opposed to int) values\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] missing_numbers(long[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length - 1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static long[] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   long range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2)));\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = ((int) (mod_positive(nums[i], m)));\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new long[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "getFileDigest",
                "plume",
                "Digest",
                "/**\n * This convenience method is used by both create() and verify().  It\n * reads the contents of a named file and computes a message digest\n * for it, using the specified MessageDigest object.\n * @param filename the file to read\n * @param md the MessageDigest\n * @return the message digest\n * @throws IOException if there is a problem reading the file\n */\npublic static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    // Read to the end of the file, discarding everything we read. {\n    // The DigestInputStream automatically passes all the bytes read to\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) {\n        /* do nothing */\n    }\n    // Finally, compute and return the digest value.\n    byte[] result = md.digest();\n    in.close();\n    return result;\n}"
            ],
            [
                "hexEncode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert an array of bytes to a String.  We do\n * this simply by converting each byte to two hexadecimal digits.  Something\n * like Base 64 encoding is more compact, but harder to encode.\n * @param bytes the bytes to convert to a String\n * @return a String representation of the input bytes\n */\npublic static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}"
            ],
            [
                "hexDecode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert from a string\n * of hexadecimal digits to an array of bytes.\n * This method is the reverse of {@link #hexEncode(byte[])}.\n * @param s the String to convert to an array of bytes\n * @return the bytes equivalent to the input String\n */\npublic static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9')) {\n                digit1 -= '0';\n            } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n                digit1 -= 'a' - 10;\n            }\n            if ((digit2 >= '0') && (digit2 <= '9')) {\n                digit2 -= '0';\n            } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n                digit2 -= 'a' - 10;\n            }\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}"
            ],
            [
                "dirToCheckoutHg",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".hg\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutHg(File hgDir, File dir) {\n    String repository = null;\n    File hgrcFile = new File(hgDir, \"hgrc\");\n    Ini ini;\n    // There also exist Hg commands that will do this same thing.\n    if (hgrcFile.exists()) {\n        try {\n            ini = new Ini(new FileReader(hgrcFile));\n        } catch (IOException e) {\n            throw new Error(\"Problem reading file \" + hgrcFile);\n        }\n        Ini.Section pathsSection = ini.get(\"paths\");\n        if (pathsSection != null) {\n            repository = pathsSection.get(\"default\");\n            if (repository != null && repository.endsWith(\"/\")) {\n                repository = repository.substring(0, repository.length() - 1);\n            }\n        }\n    }\n    return new Checkout(RepoType.HG, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutGit",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".git\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutGit(File gitDir, File dir) {\n    String repository = UtilMDE.backticks(\"git\", \"config\", \"remote.origin.url\");\n    return new Checkout(RepoType.GIT, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutSvn",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory that contains a .svn subdirectory, create a\n * corresponding Checkout object.\n * Returns null if this is not possible.\n */\nstatic /*@Nullable*/\nCheckout dirToCheckoutSvn(File dir) {\n    // For SVN, do\n    //   svn info\n    // and grep out these lines:\n    //   URL: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository/trunk/www\n    //   Repository Root: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository\n    // Use SVNKit?\n    // Con: introduces dependency on external library.\n    // Pro: no need to re-implement or to call external process (which\n    //   might be slow for large checkouts).\n    // unannotated library: SVNKit\n    @SuppressWarnings(\"nullness\")\n    SVNWCClient wcClient = new SVNWCClient((/*@Nullable*/\n    ISVNAuthenticationManager) null, null);\n    SVNInfo info;\n    try {\n        info = wcClient.doInfo(new File(dir.toString()), SVNRevision.WORKING);\n    } catch (SVNException e) {\n        // throw new Error(\"Problem in dirToCheckoutSvn(\" + dir + \"): \", e);\n        System.err.println(\"Problem in dirToCheckoutSvn(\" + dir + \"): \" + e.getMessage());\n        if (e.getMessage() != null && e.getMessage().contains(\"This client is too old\")) {\n            System.err.println(\"plume-lib needs a newer version of SVNKit.\");\n        }\n        return null;\n    }\n    // getFile is null when operating on a working copy, as I am\n    // String relativeFile = info.getPath(); // relative to repository root -- can use to determine root of checkout\n    // getFile is just the (absolute) local file name for local items -- same as \"dir\"\n    // File relativeFile = info.getFile();\n    SVNURL url = info.getURL();\n    // This can be null (example: dir /afs/csail.mit.edu/u/m/mernst/.snapshot/class/6170/2006-spring/3dphysics).  I don't know under what circumstances.\n    SVNURL repoRoot = info.getRepositoryRootURL();\n    if (repoRoot == null) {\n        System.err.println(\"Problem:  old svn working copy in \" + dir.toString());\n        System.err.println(\"Check it out again to get a 'Repository Root' entry in the svn info output.\");\n        System.err.println(\"  repoUrl = \" + url);\n        System.exit(2);\n    }\n    if (debug) {\n        System.out.println();\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"     dir = \" + dir.toString());\n    }\n    // Strip common suffix off of local dir and repo url.\n    Pair<File, File> /*@Nullable*/\n    /*@Nullable*/\n    stripped = removeCommonSuffixDirs(dir, new File(url.getPath()), new File(repoRoot.getPath()), \".svn\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n        System.out.printf(\"dir (%s) is parent of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    if (stripped.b == null) {\n        System.out.printf(\"dir (%s) is child of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    String pathInRepoAtCheckout = stripped.b.toString();\n    try {\n        url = url.setPath(pathInRepoAtCheckout, false);\n    } catch (SVNException e) {\n        throw new Error(e);\n    }\n    if (debug) {\n        System.out.println(\"stripped: \" + stripped);\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"    cDir = \" + cDir.toString());\n    }\n    assert url.toString().startsWith(repoRoot.toString()) : \"repoRoot=\" + repoRoot + \", url=\" + url;\n    return new Checkout(RepoType.SVN, cDir, url.toString(), null);\n    /// Old implementation\n    // String module = url.toString().substring(repoRoot.toString().length());\n    // if (module.startsWith(\"/\")) {\n    //   module = module.substring(1);\n    // }\n    // if (module.equals(\"\")) {\n    //   module = null;\n    // }\n    // return new Checkout(RepoType.SVN, cDir, repoRoot.toString(), module);\n}"
            ],
            [
                "removeCommonSuffixDirs",
                "plume",
                "MultiVersionControl",
                "/**\n * Strip identical elements off the end of both paths, and then return\n * what is left of each.  Returned elements can be null!  If p2_limit is\n * non-null, then it should be a parent of p2, and the stripping stops\n * when p2 becomes p2_limit.  If p1_contains is non-null, then p1 must\n * contain a subdirectory of that name.\n */\nstatic Pair</*@Nullable*/\nFile, /*@Nullable*/\nFile> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains) {\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\", p1, p2, p2_limit, p1_contains);\n    }\n    // new names for results, because we will be side-effecting them\n    File r1 = p1;\n    File r2 = p2;\n    while (r1 != null && r2 != null && (p2_limit == null || !r2.equals(p2_limit)) && r1.getName().equals(r2.getName())) {\n        if (p1_contains != null && !new File(r1.getParentFile(), p1_contains).isDirectory()) {\n            break;\n        }\n        r1 = r1.getParentFile();\n        r2 = r2.getParentFile();\n    }\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs => %s %s%n\", r1, r2);\n    }\n    return Pair.of(r1, r2);\n}"
            ],
            [
                "eq",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Check for equality of non-null reference x and possibly-null y.  Uses\n * identity equality.\n */\n/*@Pure*/\nstatic boolean eq(Object x, /*@Nullable*/\nObject y) {\n    return x == y;\n}"
            ],
            [
                "hasher",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return the hash code for x\n */\n/*@Pure*/\nstatic int hasher(Object x) {\n    return System.identityHashCode(x);\n}"
            ],
            [
                "indexFor",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return index for hash code h.\n */\n/*@Pure*/\nstatic int indexFor(int h, int length) {\n    return h & (length - 1);\n}"
            ],
            [
                "old_get_entry",
                "plume",
                "Lookup",
                "/**\n * Returns the next entry.  If no more entries are available, returns null.\n * @param reader where to read the entry from\n * @return the next entry, or null\n * @throws IOException if there is a problem reading a file\n */\npublic static /*@Nullable*/\nEntry old_get_entry(EntryReader reader) throws IOException {\n    try {\n        // Skip any preceeding blank lines\n        String line = reader.readLine();\n        while ((line != null) && (line.trim().length() == 0)) {\n            line = reader.readLine();\n        }\n        if (line == null) {\n            return (null);\n        }\n        Entry entry = null;\n        String filename = reader.getFileName();\n        long line_number = reader.getLineNumber();\n        // If this is a long entry\n        if (line.startsWith(\">entry\")) {\n            // Get the current filename\n            String current_filename = reader.getFileName();\n            // Remove '>entry' from the line\n            line = line.replaceFirst(\"^>entry *\", \"\");\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find the termination of the entry\n            while ((line != null) && !line.startsWith(\">entry\") && !line.equals(\"<entry\") && current_filename.equals(reader.getFileName())) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            // If this entry was terminated by the start of the next one,\n            // put that line back\n            if ((line != null) && (line.startsWith(\">entry\") || !current_filename.equals(reader.getFileName()))) {\n                reader.putback(line);\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, false);\n        } else {\n            // blank separated entry\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find another blank line\n            while ((line != null) && (line.trim().length() != 0)) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, true);\n        }\n        return (entry);\n    } catch (FileNotFoundException e) {\n        System.out.printf(\"Error: Can't read %s at line %d in file %s%n\", e.getMessage(), reader.getLineNumber(), reader.getFileName());\n        System.exit(254);\n        return (null);\n    }\n}"
            ],
            [
                "first_line",
                "plume",
                "Lookup",
                "/**\n * Returns the first line of entry.\n * @param entry the entry whose first line to return\n * @return the first line of entry\n */\npublic static String first_line(String entry) {\n    int ii = entry.indexOf(lineSep);\n    if (ii == -1) {\n        return entry;\n    }\n    return entry.substring(0, ii);\n}"
            ],
            [
                "of",
                "plume",
                "Pair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a pair of the values (a, b)\n */\npublic static <A extends /*@Nullable*/\nObject, B extends /*@Nullable*/\nObject> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "short_str",
                "plume",
                "TaskManager",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "short_str",
                "plume",
                "Task",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "versionNumbers",
                "plume",
                "ClassFileVersion",
                "/**\n * Return an array of the major vernios, minor version, and JDK version\n * of the class read from the input stream.\n * Return null if there is an error or the input isn't a class file.\n * @param is input stream from which to read a class\n * @return array of three version numbers\n */\npublic static double[] versionNumbers(InputStream is) {\n    try {\n        DataInputStream dis = new DataInputStream(is);\n        int magic = dis.readInt();\n        if (magic != 0xcafebabe) {\n            return null;\n        }\n        double minor = dis.readShort();\n        double major = dis.readShort();\n        double jdkVersion;\n        if (major < 48) {\n            // really 1.3.1\n            jdkVersion = 1.3;\n        } else if (major == 48) {\n            // really 1.4.2\n            jdkVersion = 1.4;\n        } else if (major == 49) {\n            jdkVersion = 1.5;\n        } else if (major == 50) {\n            jdkVersion = 6;\n        } else {\n            jdkVersion = 7;\n        }\n        return new double[] { major, minor, jdkVersion };\n    } catch (IOException e) {\n        return null;\n    }\n}"
            ],
            [
                "of",
                "plume",
                "WeakIdentityPair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a WeakIdentityPair of (a, b)\n */\npublic static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b) {\n    return new WeakIdentityPair<A, B>(a, b);\n}"
            ],
            [
                "start",
                "plume",
                "OptionsDoclet",
                "// Doclet-specific methods\n/**\n * Entry point for the doclet.\n * @param root the root document\n * @return true if processing completed without an error\n */\npublic static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n        // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n        // returns a fully qualified name.  I do not know a good way to convert\n        // between these two name formats.  For now, we simply ignore inner\n        // classes.  This limitation can be removed when we figure out a better\n        // way to go from ClassDoc to Class<?>.\n        if (doc.containingClass() != null) {\n            continue;\n        }\n        Class<?> clazz;\n        try {\n            // Javadoc source code is not yet annotated\n            @SuppressWarnings(\"signature\")\n            String /*@BinaryNameForNonArray*/\n            className = doc.qualifiedName();\n            clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        }\n        if (needsInstantiation(clazz)) {\n            try {\n                Constructor<?> c = clazz.getDeclaredConstructor();\n                c.setAccessible(true);\n                objs.add(c.newInstance(new Object[0]));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            objs.add(clazz);\n        }\n    }\n    if (objs.isEmpty()) {\n        System.out.println(\"Error: no classes found\");\n        return false;\n    }\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n        System.out.println(\"Error: no @Option-annotated fields found\");\n        return false;\n    }\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n        o.write();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "optionLength",
                "plume",
                "OptionsDoclet",
                "/**\n * Given a command-line option of this doclet, returns the number of\n * arguments you must specify on the command line for the given option.\n * Returns 0 if the argument is not recognized.  This method is\n * automatically invoked.\n *\n * @param option the command-line option\n * @return the number of command-line arguments needed when using the option\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n        System.out.printf(USAGE);\n        return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n        return 1;\n    }\n    if (option.equals(\"-docfile\") || option.equals(\"-outfile\") || option.equals(\"-format\") || option.equals(\"-d\")) {\n        return 2;\n    }\n    return 0;\n}"
            ],
            [
                "validOptions",
                "plume",
                "OptionsDoclet",
                "/**\n * Tests the validity of command-line arguments passed to this doclet.\n * Returns true if the option usage is valid, and false otherwise.  This\n * method is automatically invoked.\n *\n * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n * @param reporter where to report errors\n * @return true iff the command-line options are valid\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            if (hasDocFile) {\n                reporter.printError(\"-docfile option specified twice\");\n                return false;\n            }\n            File f = new File(os[1]);\n            if (!f.exists()) {\n                reporter.printError(\"-docfile file not found: \" + os[1]);\n                return false;\n            }\n            docFile = os[1];\n            hasDocFile = true;\n        }\n        if (opt.equals(\"-outfile\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-outfile option specified twice\");\n                return false;\n            }\n            if (inPlace) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            outFile = os[1];\n            hasOutFile = true;\n        }\n        if (opt.equals(\"-i\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            inPlace = true;\n        }\n        if (opt.equals(\"-format\")) {\n            if (hasFormat) {\n                reporter.printError(\"-format option specified twice\");\n                return false;\n            }\n            if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n                reporter.printError(\"unrecognized output format: \" + os[1]);\n                return false;\n            }\n            hasFormat = true;\n        }\n        if (opt.equals(\"-d\")) {\n            if (hasDestDir) {\n                reporter.printError(\"-d specified twice\");\n                return false;\n            }\n            hasDestDir = true;\n        }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n        reporter.printError(\"docfile must be different from outfile\");\n        return false;\n    }\n    if (inPlace && docFile == null) {\n        reporter.printError(\"-i supplied but -docfile was not\");\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "javadocToHtml",
                "plume",
                "OptionsDoclet",
                "/**\n * Replace the @link tags and block @see tags in a Javadoc comment with\n * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n * comment while still being presentable. <p>\n *\n * This is only a temporary solution.  Ideally, @link/@see tags would be\n * converted to HTML links that point to actual documentation.\n *\n * @param doc a Javadoc comment to convert to HTML\n * @return HTML version of doc\n */\npublic static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n        if (tag instanceof SeeTag) {\n            b.append(\"<code>\" + tag.text() + \"</code>\");\n        } else {\n            b.append(tag.text());\n        }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n        b.append(\" See: \");\n        {\n            StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n            for (SeeTag tag : seetags) {\n                bb.append(\"<code>\" + tag.text() + \"</code>\");\n            }\n            b.append(bb);\n        }\n        b.append(\".\");\n    }\n    return b.toString();\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param s string to check for being a regular expression\n * @return true iff s is a regular expression\n */\n/*@Pure*/\n/*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\npublic static boolean isRegex(String s) {\n    return isRegex(s, 0);\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression with at least the given number of groups.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return true iff s is a regular expression with groups groups\n */\n// RegexUtil; for purity, catches an exception\n@SuppressWarnings({ \"regex\", \"deterministic\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(String s, int groups) {\n    Pattern p;\n    try {\n        p = Pattern.compile(s);\n    } catch (PatternSyntaxException e) {\n        return false;\n    }\n    return getGroupCount(p) >= groups;\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param c char to check for being a regular expression\n * @return true iff c is a regular expression\n */\n@SuppressWarnings({ \"regex\", \"purity.not.deterministic.call\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(char c) {\n    return isRegex(Character.toString(c));\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a string describing why the argument is\n * not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nString regexError(String s) {\n    return regexError(s, 0);\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns\n * a string describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil;\n@SuppressWarnings({ \"regex\", \"not.sef\" })\npublic static /*@Nullable*/\nString regexError(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return regexErrorMessage(s, groups, actualGroups);\n        }\n    } catch (PatternSyntaxException e) {\n        return e.getMessage();\n    }\n    return null;\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a PatternSyntaxException describing\n * why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s) {\n    return regexException(s, 0);\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns a\n * PatternSyntaxException describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return new PatternSyntaxException(regexErrorMessage(s, groups, actualGroups), s, -1);\n        }\n    } catch (PatternSyntaxException pse) {\n        return pse;\n    }\n    return null;\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex String} if it is a regex,\n * otherwise throws an error. The purpose of this method is to suppress Regex\n * Checker warnings. It should be very rarely needed.\n * @param s string to check for being a regular expression\n * @return its argument\n * @throws Error if argument is not a regex\n */\n/*@SideEffectFree*/\n// The return type annotation is a conservative bound.\npublic static /*@Regex*/\nString asRegex(String s) {\n    return asRegex(s, 0);\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex(groups) String} if it is a regex\n * with at least the given number of groups, otherwise throws an error. The\n * purpose of this method is to suppress Regex Checker warnings. It should\n * be very rarely needed.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return its argument\n * @throws Error if argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Regex*/\nString asRegex(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            throw new Error(regexErrorMessage(s, groups, actualGroups));\n        }\n        return s;\n    } catch (PatternSyntaxException e) {\n        throw new Error(e);\n    }\n}"
            ],
            [
                "findClass",
                "plume",
                "JWhich",
                "/**\n * Returns the URL of the resource denoted by the specified\n * class name, as prescribed by the class path.\n *\n * @param className name of the class\n * @return class URL, or null of the class was not found\n */\npublic static /*@Nullable*/\nURL findClass(final String className) {\n    return JWhich.class.getResource(asResourceName(className));\n}"
            ],
            [
                "asResourceName",
                "plume",
                "JWhich",
                "protected static String asResourceName(String resource) {\n    if (!resource.startsWith(\"/\")) {\n        resource = \"/\" + resource;\n    }\n    resource = resource.replace('.', '/');\n    resource = resource + \".class\";\n    return resource;\n}"
            ],
            [
                "getClasspath",
                "plume",
                "JWhich",
                "/**\n * Return the classpath.\n * @return the classpath\n */\n/*@EnsuresNonNull(\"CLASSPATH\")*/\nprotected static String getClasspath() {\n    if (CLASSPATH == null) {\n        String classpath = System.getProperty(\"java.class.path\");\n        setClasspath(classpath);\n    }\n    return CLASSPATH;\n}"
            ],
            [
                "internStrings",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Strings\n///\n/**\n * Replace each element of the array by its interned version.\n * Side-effects the array, but also returns it.\n * @param a the array whose elements to intern in place\n * @return an interned version of a\n * @see String#intern\n */\n// side-effects the array in place (dangerous, but convenient)\n@SuppressWarnings(\"interning\")\npublic static String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] != null) {\n            a[i] = a[i].intern();\n        }\n    }\n    return a;\n}"
            ],
            [
                "isInterned",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Testing interning\n///\n/**\n * Return true if the argument is interned (is canonical among all\n * objects equal to itself).\n * @param value the value to test for interning\n * @return true iff value is interned\n */\n// interning implementation\n@SuppressWarnings(\"interning\")\npublic static /*@Pure*/\nboolean isInterned(/*@Nullable*/\nObject value) {\n    if (value == null) {\n        // nothing to do\n        return true;\n    } else if (value instanceof String) {\n        return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n        return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n        return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n        return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n        return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n        return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n        return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n        return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n        return (value == intern((Object[]) value));\n    } else {\n        // Nothing to do, because we don't intern other types.\n        // System.out.println(\"What type? \" + value.getClass().getName());\n        return true;\n    }\n}"
            ],
            [
                "numIntegers",
                "plume",
                "Intern",
                "// For testing only\npublic static int numIntegers() {\n    return internedIntegers.size();\n}"
            ],
            [
                "numLongs",
                "plume",
                "Intern",
                "public static int numLongs() {\n    return internedLongs.size();\n}"
            ],
            [
                "numIntArrays",
                "plume",
                "Intern",
                "public static int numIntArrays() {\n    return internedIntArrays.size();\n}"
            ],
            [
                "numLongArrays",
                "plume",
                "Intern",
                "public static int numLongArrays() {\n    return internedLongArrays.size();\n}"
            ],
            [
                "numDoubles",
                "plume",
                "Intern",
                "public static int numDoubles() {\n    return internedDoubles.size();\n}"
            ],
            [
                "numDoubleArrays",
                "plume",
                "Intern",
                "public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n}"
            ],
            [
                "numStringArrays",
                "plume",
                "Intern",
                "public static int numStringArrays() {\n    return internedStringArrays.size();\n}"
            ],
            [
                "numObjectArrays",
                "plume",
                "Intern",
                "public static int numObjectArrays() {\n    return internedObjectArrays.size();\n}"
            ],
            [
                "integers",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nInteger> integers() {\n    return internedIntegers.keySet().iterator();\n}"
            ],
            [
                "longs",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nLong> longs() {\n    return internedLongs.keySet().iterator();\n}"
            ],
            [
                "intArrays",
                "plume",
                "Intern",
                "public static Iterator<int[]> intArrays() {\n    return internedIntArrays.keySet().iterator();\n}"
            ],
            [
                "longArrays",
                "plume",
                "Intern",
                "public static Iterator<long[]> longArrays() {\n    return internedLongArrays.keySet().iterator();\n}"
            ],
            [
                "doubles",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nDouble> doubles() {\n    return internedDoubles.keySet().iterator();\n}"
            ],
            [
                "doubleArrays",
                "plume",
                "Intern",
                "public static Iterator<double[]> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n}"
            ],
            [
                "stringArrays",
                "plume",
                "Intern",
                "public static Iterator<String[]> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n}"
            ],
            [
                "objectArrays",
                "plume",
                "Intern",
                "public static Iterator<Object[]> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a String.\n * Delegates to the builtin String.intern() method.\n * Provided for completeness.\n * @param a the string to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static /*@Interned*/\n/*@PolyNull*/\nString intern(/*@PolyNull*/\nString a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n        return null;\n    }\n    return a.intern();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a long.\n * A no-op.  Provided for completeness.\n * @param l the long to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static long intern(long l) {\n    return l;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a double\n * A no-op.  Provided for completeness.\n * @param d the double to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static double intern(double d) {\n    return d;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Integer.\n * Return a canonical representation for the Integer.\n * @param a an Integer to canonicalize\n * @return a canonical representation for the Integer\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Intern.valueOf is intended to promise\n// the same).  This does not currently take advantage of that.\n// interning implementation\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nInteger intern(Integer a) {\n    WeakReference<Integer> /*@Interned*/\n    lookup = internedIntegers.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Integer /*@Interned*/\n        result = (/*@Interned*/\n        Integer) a;\n        internedIntegers.put(result, new WeakReference</*@Interned*/\n        Integer>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nInteger internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value parsed from the string.\n * @param s the string to parse\n * @return an interned Integer parsed from s\n */\npublic static /*@Interned*/\nInteger internedInteger(String s) {\n    return intern(Integer.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Long.\n * Return a canonical representation for the Long.\n * @param a the value to intern\n * @return a canonical representation for the Long\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Long.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nLong intern(Long a) {\n    WeakReference<Long> /*@Interned*/\n    lookup = internedLongs.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Long /*@Interned*/\n        result = (/*@Interned*/\n        Long) a;\n        internedLongs.put(result, new WeakReference</*@Interned*/\n        Long>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nLong internedLong(long i) {\n    return intern(Long.valueOf(i));\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value parsed from the string.\n * @param s the string to parse\n * @return an interned Long parsed from s\n */\npublic static /*@Interned*/\nLong internedLong(String s) {\n    return intern(Long.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) an int[].\n * Return a canonical representation for the int[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the int[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static int[] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        int[] /*@Interned*/\n        result = (int[]) a;\n        internedIntArrays.put(result, new WeakReference<int[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a long[].\n * Return a canonical representation for the long[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the long[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static long[] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        long[] /*@Interned*/\n        result = (long[]) a;\n        internedLongArrays.put(result, new WeakReference<long[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Double.\n * Return a canonical representation for the Double.\n * @param a the Double to canonicalize\n * @return a canonical representation for the Double\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Double.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nDouble intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n        return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) {\n        // catches both positive and negative zero\n        return internedDoubleZero;\n    }\n    WeakReference<Double> /*@Interned*/\n    lookup = internedDoubles.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Double /*@Interned*/\n        result = (/*@Interned*/\n        Double) a;\n        internedDoubles.put(result, new WeakReference</*@Interned*/\n        Double>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value i.\n * @param d the value to intern\n * @return an interned Double with value d\n */\npublic static /*@Interned*/\nDouble internedDouble(double d) {\n    return intern(Double.valueOf(d));\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value parsed from the string.\n * @param s the string to parse\n * @return an interned Double parsed from s\n */\npublic static /*@Interned*/\nDouble internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) a double[].\n * Return a canonical representation for the double[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the double[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static double[] intern(double[] a) {\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        double[] /*@Interned*/\n        result = (double[]) a;\n        internedDoubleArrays.put(result, new WeakReference<double[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an String[].\n * Return a canonical representation for the String[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the String[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static String[] intern(/*@PolyNull*/\n/*@Interned*/\nString[] a) {\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n        assert a[k] == Intern.intern(a[k]);\n    }\n    WeakReference<String[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    String[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (String[]) a;\n        internedStringArrays.put(result, new WeakReference<String[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    String[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Object[].\n * Return a canonical representation for the Object[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the Object[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static Object[] intern(/*@PolyNull*/\n/*@Interned*/\nObject[] a) {\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    WeakReference<Object[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    Object[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (Object[]) a;\n        internedObjectArrays.put(result, new WeakReference<Object[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    Object[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Convenince method to intern an Object when we don't know its\n * runtime type.  Its runtime type must be one of the types for\n * which we have an intern() method, else an exception is thrown.\n * If the argument is an array, its elements should themselves be\n * interned.\n * @param a an Object to canonicalize\n * @return a canonical version of a\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Interned*/\n/*@PolyNull*/\nObject intern(/*@PolyNull*/\nObject a) {\n    if (a == null) {\n        return null;\n    } else if (a instanceof String) {\n        return intern((String) a);\n    } else if (a instanceof String[]) {\n        @SuppressWarnings(\"interning\")\n        String[] /*@Interned*/\n        asArray = (String[]) a;\n        return intern(asArray);\n    } else if (a instanceof Integer) {\n        return intern((Integer) a);\n    } else if (a instanceof Long) {\n        return intern((Long) a);\n    } else if (a instanceof int[]) {\n        return intern((int[]) a);\n    } else if (a instanceof long[]) {\n        return intern((long[]) a);\n    } else if (a instanceof Double) {\n        return intern((Double) a);\n    } else if (a instanceof double[]) {\n        return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n        @SuppressWarnings(\"interning\")\n        Object[] /*@Interned*/\n        asArray = (Object[]) a;\n        return intern(asArray);\n    } else {\n        throw new IllegalArgumentException(\"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * Return the subsequence of seq from start (inclusive) to end\n * (exclusive) that is interned.  What's different about this method\n * from manually finding the subsequence and interning the\n * subsequence is that if the subsequence is already interned, we\n * can avoid having to compute the sequence.  Since derived\n * variables in Daikon compute the subsequence many times, this\n * shortcut saves quite a bit of computation.  It saves even more\n * when there may be many derived variables that are non-canonical,\n * since they are guaranteed to be ==.\n * <p>\n * Requires that seq is already interned.\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n */\npublic static int[] internSubsequence(int[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int[]> /*@Interned*/\n    sai = new SequenceAndIndices<int[]>(seq, start, end);\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n        int[] /*@Interned*/\n        subseq = Intern.intern(subseqUninterned);\n        internedIntSequenceAndIndices.put(sai, new WeakReference<int[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static long[] internSubsequence(long[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long[]> /*@Interned*/\n    sai = new SequenceAndIndices<long[]>(seq, start, end);\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        long[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedLongSequenceAndIndices.put(sai, new WeakReference<long[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static double[] internSubsequence(double[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double[]> /*@Interned*/\n    sai = new SequenceAndIndices<double[]>(seq, start, end);\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        double[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedDoubleSequenceAndIndices.put(sai, new WeakReference<double[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static Object[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nObject[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<Object[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedObjectSequenceAndIndices.put(sai, new WeakReference<Object[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static String[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nString[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<String[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedStringSequenceAndIndices.put(sai, new WeakReference<String[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "dominators",
                "plume",
                "GraphMDE",
                "// Algorithms for computing dominators:\n//\n// Wikipedia:\n//  // dominator of the start node is the start itself\n//  Dom(n_0) = {n_0}\n//  // for all other nodes, set all nodes as the dominators\n//  for each n in N - {n_0}\n//      Dom(n) = N;\n//  // iteratively eliminate nodes that are not dominators\n//  while changes in any Dom(n)\n//      for each n in N - {n_0}:\n//          Dom(n) = {n} union with intersection over all p in pred(n) of Dom(p)\n//\n// Cooper/Harvey/Kennedy:\n//  for all nodes, n\n//    DOM[n] := {1 . . .N}\n//  Changed := true\n//  while (Changed)\n//    Changed := false\n//    for all nodes, n, in reverse postorder\n//      new_set := (Intersect_{p:=preds(n)} DOM[p]) union {n}\n//      if (new_set != DOM[n])\n//        DOM[n] := new_set\n//        Changed := true\n// The two algorithms are essentially the same; this implementation\n// follows the Wikipedia one.\n/**\n * Computes, for each node in the graph, its set of (pre-)dominators.\n * Supply a successor graph if you want post-dominators.\n * @param <T> type of the graph nodes\n * @param predecessors a graph, represented as a predecessor map\n * @return a map from each node to a list of its pre-dominators\n */\npublic static <T> Map<T, List<T>> dominators(Map<T, List</*@KeyFor(\"#1\")*/\nT>> predecessors) {\n    // Map</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>> dom = new HashMap</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>>();\n    Map<T, List<T>> dom = new HashMap<T, List<T>>();\n    // every element of pred's value will be a key for dom\n    @SuppressWarnings(\"keyfor\")\n    Map<T, List<T>> /*@KeyFor({\"dom\"})*/\n    preds = predecessors;\n    List<T> nodes = new ArrayList<T>(preds.keySet());\n    // Compute roots & non-roots, for convenience\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    roots = new ArrayList<T>();\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    non_roots = new ArrayList<T>();\n    // Initialize result:  for roots just the root, otherwise everything\n    for (T node : preds.keySet()) {\n        if (preds.get(node).isEmpty()) {\n            // This is a root.  Its only dominator is itself.\n            Set<T> set = Collections.singleton(node);\n            dom.put(node, new ArrayList<T>(set));\n            roots.add(node);\n        } else {\n            // Initially, set all nodes as dominators;\n            // will later remove nodes that aren't dominators.\n            dom.put(node, new ArrayList<T>(nodes));\n            non_roots.add(node);\n        }\n    }\n    assert roots.size() + non_roots.size() == nodes.size();\n    // Invariants:\n    // preds and dom have the same keyset.\n    // All of the following are keys for both preds and dom:\n    //  * every key in pred\n    //  * elery element of every pred value\n    //  * every key in dom\n    //  * elery element of every dom value\n    // So, the type of pred is now\n    //\n    // rather than its original type\n    //   Map<T,List</*@KeyFor(\"preds\")*/ T>> preds\n    boolean changed = true;\n    while (changed) {\n        changed = false;\n        for (T node : non_roots) {\n            List<T> new_doms = null;\n            assert preds.containsKey(node);\n            for (T pred : preds.get(node)) {\n                assert dom.containsKey(pred);\n                /*@NonNull*/\n                List<T> dom_of_pred = dom.get(pred);\n                if (new_doms == null) {\n                    // make copy because we may side-effect new_doms\n                    new_doms = new ArrayList<T>(dom_of_pred);\n                } else {\n                    new_doms.retainAll(dom_of_pred);\n                }\n            }\n            assert new_doms != null : \"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\";\n            new_doms.add(node);\n            assert dom.containsKey(node);\n            if (!dom.get(node).equals(new_doms)) {\n                dom.put(node, new_doms);\n                changed = true;\n            }\n        }\n    }\n    for (T node : preds.keySet()) {\n        // TODO: The following two assert statements would be easier to read\n        // than the one combined one, but a bug (TODO:  Jonathan will add a\n        // bug number) prevents it from type-checking.\n        // assert dom.containsKey(node);\n        // assert dom.get(node).contains(node);\n        assert dom.containsKey(node) && dom.get(node).contains(node);\n    }\n    return dom;\n}"
            ],
            [
                "canonicalizeTimezone",
                "plume",
                "ICalAvailable",
                "static String canonicalizeTimezone(String timezone) {\n    String result = canonicalTimezones.get(timezone.toLowerCase());\n    return (result == null) ? timezone : result;\n}"
            ],
            [
                "printedTimezone",
                "plume",
                "ICalAvailable",
                "/*@Pure*/\nstatic String printedTimezone(TimeZone tz) {\n    String tzString = tz.getDisplayName();\n    String result = printedTimezones.get(tzString);\n    return (result == null) ? tzString : result;\n}"
            ],
            [
                "parseTime",
                "plume",
                "ICalAvailable",
                "// Parse a time like \"9:30pm\"\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nDateTime parseTime(String time) {\n    Matcher m = timeRegexp.matcher(time);\n    if (!m.matches()) {\n        System.err.println(\"Bad time: \" + time);\n        System.exit(1);\n    }\n    @SuppressWarnings(// Regex Checker imprecision:  matches() guarantees that group 1 exists in regexp\n    \"nullness\")\n    String /*@NonNull*/\n    hourString = m.group(1);\n    String minuteString = m.group(3);\n    String ampmString = m.group(4);\n    int hour = Integer.parseInt(hourString);\n    if ((ampmString != null) && ampmString.toLowerCase().equals(\"pm\")) {\n        hour += 12;\n    }\n    int minute = 0;\n    if (minuteString != null) {\n        minute = Integer.parseInt(minuteString);\n    }\n    DateTime result = new DateTime();\n    result.setTimeZone(tz1);\n    result.setHours(hour);\n    result.setMinutes(minute);\n    result.setSeconds(0);\n    return result;\n}"
            ],
            [
                "rangeString",
                "plume",
                "ICalAvailable",
                "static String rangeString(Period p, TimeZone tz) {\n    tf.setTimeZone(tz);\n    DateTime pstart = p.getStart();\n    DateTime pend = p.getEnd();\n    String rangeString = tf.format(pstart) + \" to \" + tf.format(pend);\n    rangeString = rangeString.replace(\" AM\", \"am\");\n    rangeString = rangeString.replace(\" PM\", \"pm\");\n    return rangeString;\n}"
            ],
            [
                "periodListString",
                "plume",
                "ICalAvailable",
                "static String periodListString(PeriodList pl, TimeZone tz) {\n    tf.setTimeZone(tz);\n    StringBuilder result = new StringBuilder();\n    // \"Object\" because PeriodList extends TreeSet, but it really ought to\n    // extend TreeSet</*@NonNull*/ Period>\n    for (Object p : pl) {\n        assert p != null : \"@AssumeAssertion(nullness): non-generic container class; elements are non-null\";\n        result.append(rangeString((Period) p, tz) + \"\\n\");\n    }\n    return result.toString();\n}"
            ],
            [
                "mergeDateAndTime",
                "plume",
                "ICalAvailable",
                "/**\n * Creates a new DateTime with date taken from the first argument and\n * time taken from the second argument.\n * @return the merged DateTime\n */\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic DateTime mergeDateAndTime(DateTime date, DateTime time) {\n    if (!date.getTimeZone().equals(time.getTimeZone())) {\n        throw new Error(String.format(\"non-matching timezones: %s %s\", date.getTimeZone(), time.getTimeZone()));\n    }\n    DateTime result = new DateTime(date);\n    result.setHours(time.getHours());\n    result.setMinutes(time.getMinutes());\n    result.setSeconds(time.getSeconds());\n    return result;\n}"
            ],
            [
                "oneDayAvailable",
                "plume",
                "ICalAvailable",
                "// TODO:  don't propose times that are before the current moment.\n// Process day-by-day because otherwise weekends and evenings are included.\n// for iCal4j\n@SuppressWarnings(\"unchecked\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nList<Period> oneDayAvailable(DateTime day, List<Calendar> calendars) {\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...)%n\", day);\n    }\n    List<Period> result = new ArrayList<Period>();\n    // for iCal4j\n    @SuppressWarnings(\"deprecation\")\n    int dayOfWeek = day.getDay();\n    if (!businessDays.contains(dayOfWeek)) {\n        return result;\n    }\n    for (Period bh : businessHours) {\n        DateTime start = mergeDateAndTime(day, bh.getStart());\n        DateTime end = mergeDateAndTime(day, bh.getEnd());\n        VFreeBusy request = new VFreeBusy(start, end, new Dur(0, 0, 0, 1));\n        if (debug) {\n            System.out.println(\"Request = \" + request);\n        }\n        ComponentList busyTimes = new ComponentList();\n        // Problem:  any all-day events will be treated as UTC.\n        // Instead, they should be converted to local time (tz1).\n        // But VFreeBusy does not support this, so I may need to convert\n        // daily events into a different format before inserting them.\n        for (Calendar calendar : calendars) {\n            // getComponents() returns a raw ArrayList.  Expose its element type.\n            ArrayList<Component> /*@NonNull*/\n            clist = calendar.getComponents();\n            for (Component c : clist) {\n                if (c instanceof VEvent) {\n                    VEvent v = (VEvent) c;\n                    DtStart dts = v.getStartDate();\n                    Parameter dtsValue = dts.getParameter(\"VALUE\");\n                    boolean allDay = (dtsValue != null) && dtsValue.getValue().equals(\"DATE\");\n                    // TODO: convert to the proper timezone.\n                    // Tricky: must deal with the possibility of RRULE:FREQ=\n                }\n                busyTimes.add(c);\n            }\n        }\n        VFreeBusy response = new VFreeBusy(request, busyTimes);\n        if (debug) {\n            System.out.println(\"Response = \" + response);\n        }\n        FreeBusy freefb = (FreeBusy) response.getProperty(\"FREEBUSY\");\n        if (freefb == null) {\n            if (debug) {\n                System.out.println(\"FREEBUSY property is null\");\n            }\n            continue;\n        }\n        // interned fields from a library, but not annotated so\n        @SuppressWarnings(\"interning\")\n        boolean isFree = (freefb.getParameter(Parameter.FBTYPE) == FbType.FREE);\n        assert isFree;\n        PeriodList freePeriods = freefb.getPeriods();\n        if (debug) {\n            System.out.printf(\"Free periods: %n%s%n\", periodListString(freePeriods, tz1));\n        }\n        result.addAll(freePeriods);\n    }\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...) => %s elements%n\", day, result.size());\n    }\n    return result;\n}"
            ],
            [
                "parseDate",
                "plume",
                "ICalAvailable",
                "/**\n * Parses a date when formatted in several common formats.\n * @return a Date read from the given string\n * @see dateFormats\n */\nstatic java.util.Date parseDate(String strDate) throws ParseException {\n    if (Pattern.matches(\"^[0-9][0-9]?/[0-9][0-9]?$\", date)) {\n        // for iCal4j\n        @SuppressWarnings(\"deprecation\")\n        int year = new Date().getYear() + 1900;\n        strDate = strDate + \"/\" + year;\n    }\n    for (DateFormat this_df : dateFormats) {\n        this_df.setLenient(false);\n        try {\n            java.util.Date result = this_df.parse(strDate);\n            return result;\n        } catch (ParseException e) {\n            // Try the next format in the list.\n        }\n    }\n    throw new ParseException(\"bad date \" + strDate, 0);\n}"
            ],
            [
                "formatDate",
                "plume",
                "ICalAvailable",
                "static String formatDate(DateTime d, TimeZone tz) {\n    df.setTimeZone(tz);\n    String result = df.format(d);\n    // Don't remove trailing year; it's a good double-check.\n    // Remove trailing year, such as \", 1952\".\n    // result = result.substring(0, result.length() - 6);\n    // Prepend day of week.\n    result = dffull.format(d).substring(0, 3) + \" \" + result;\n    return result;\n}"
            ],
            [
                "get_method_declaration",
                "plume",
                "BCELUtil",
                "/**\n * Returns a string describing a method declaration. It contains the access\n * flags (public, private, static, etc), the return type, the method name, and\n * the types of each of its arguments.\n * @param m the method\n * @return a string describing the method declaration\n */\npublic static String get_method_declaration(Method m) {\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n        f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n}"
            ],
            [
                "get_access_flags",
                "plume",
                "BCELUtil",
                "/**\n * Return a string representation of the access flags of method m.\n * @param m the method whose access flags to retrieve\n * @return a string representation of the access flags of method m\n */\nstatic String get_access_flags(Method m) {\n    int flags = m.getAccessFlags();\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n        if ((flags & pow) != 0) {\n            if (buf.length() > 0) {\n                buf.append(\" \");\n            }\n            if (i < Const.ACCESS_NAMES_LENGTH) {\n                buf.append(Const.getAccessName(i));\n            } else {\n                buf.append(String.format(\"ACC_BIT %x\", pow));\n            }\n        }\n        pow <<= 1;\n    }\n    return (buf.toString());\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a) {\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "get_constant_str",
                "plume",
                "BCELUtil",
                "/**\n * Returns the constant string at the specified offset.\n * @param pool the constant pool\n * @param index the index in the constant pool\n * @return the constant string at the specified offset in the constant pool\n */\npublic static String get_constant_str(ConstantPool pool, int index) {\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n        return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n        ConstantClass cc = (ConstantClass) c;\n        return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n        throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param mg the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param m the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param mg the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param m the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param gen the class to test\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in the format of Class.getName();\n *   the class should not be an array\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(/*@ClassGetName*/\nString classname) {\n    return classname.startsWith(\"java.\") || classname.startsWith(\"com.\") || classname.startsWith(\"javax.\") || classname.startsWith(\"org.\") || classname.startsWith(\"sun.\") || classname.startsWith(\"sunw.\");\n}"
            ],
            [
                "in_jdk_internalform",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in internal form\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk_internalform(/*@InternalForm*/\nString classname) {\n    return classname.startsWith(\"java/\") || classname.startsWith(\"com/\") || classname.startsWith(\"javax/\") || classname.startsWith(\"org/\") || classname.startsWith(\"sun/\") || classname.startsWith(\"sunw/\");\n}"
            ],
            [
                "instruction_descr",
                "plume",
                "BCELUtil",
                "// TODO: write Javadoc\n@SuppressWarnings(\"rawtypes\")\npublic static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n        @SuppressWarnings(// BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n        \"nullness\")\n        InstructionHandle /*@NonNull*/\n        handle = (InstructionHandle) i.next();\n        out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n}"
            ],
            [
                "local_var_descr",
                "plume",
                "BCELUtil",
                "/**\n * Return a description of the local variables (one per line).\n * @param mg the method whose local variables to describe\n * @return a description of the local variables (one per line)\n */\npublic static String local_var_descr(MethodGen mg) {\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n        for (LocalVariableGen lvg : lvgs) {\n            out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n        }\n    }\n    return (out.toString());\n}"
            ],
            [
                "is_local_variable_type_table",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the specified attribute is a local variable type\n * table.\n * @param a the attribute\n * @param pool the constant pool\n * @return true iff the attribute is a local variable type table\n */\npublic static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @param pool the constant pool\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "is_main",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not this is a standard main method (static,\n * name is 'main', and one argument of string array).\n * @param mg the method to check\n * @return true iff the method is a main method\n */\npublic static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic() && mg.getName().equals(\"main\") && (arg_types.length == 1) && arg_types[0].equals(string_array));\n}"
            ],
            [
                "type_to_classgetname",
                "plume",
                "BCELUtil",
                "/**\n * Returns the Java class name, in the format of {@link Class#getName()},\n * that corresponds to type.\n * @param type the type\n * @return the Java classname that corresponds to type\n */\npublic static /*@ClassGetName*/\nString type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n}"
            ],
            [
                "type_to_class",
                "plume",
                "BCELUtil",
                "/**\n * Returns the class that corresponds to type.\n * @param type the type\n * @return the Java class that corresponds to type\n */\npublic static Class<?> type_to_class(Type type) {\n    String classname = type_to_classgetname(type);\n    try {\n        Class<?> c = UtilMDE.classForName(classname);\n        return c;\n    } catch (Exception e) {\n        throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n}"
            ],
            [
                "add_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type added to the end of types.\n * @param types the array to extend\n * @param new_type the element to add to the end of the types array\n * @return the array (or a new one), with new_type at the end\n */\npublic static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "insert_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type inserted at the beginning.\n * @param types the array to extend\n * @param new_type the element to add to the beginning of the types array\n * @return the array (or a new one), with new_type at the beginning\n */\npublic static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "classname_to_type",
                "plume",
                "BCELUtil",
                "/**\n * Return the type corresponding to a given class name.\n * @param classname the class to convert to a type\n * @return the type corresponding to the given class name\n */\npublic static Type classname_to_type(String classname) {\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n        classname = classname.substring(0, classname.length() - 2);\n        array_depth++;\n    }\n    classname = classname.intern();\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") {\n        // interned\n        t = Type.INT;\n    } else if (classname == \"boolean\") {\n        // interned\n        t = Type.BOOLEAN;\n    } else if (classname == \"byte\") {\n        // interned\n        t = Type.BYTE;\n    } else if (classname == \"char\") {\n        // interned\n        t = Type.CHAR;\n    } else if (classname == \"double\") {\n        // interned\n        t = Type.DOUBLE;\n    } else if (classname == \"float\") {\n        // interned\n        t = Type.FLOAT;\n    } else if (classname == \"long\") {\n        // interned\n        t = Type.LONG;\n    } else if (classname == \"short\") {\n        // interned\n        t = Type.SHORT;\n    } else {\n        // must be a non-primitive\n        t = new ObjectType(classname);\n    }\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n        t = new ArrayType(t, array_depth);\n    }\n    return t;\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Array\n///\n// For arrays, see ArraysMDE.java.\n///////////////////////////////////////////////////////////////////////////\n/// BitSet\n///\n/**\n * Returns true if the cardinality of the intersection of the two\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b) >= i);\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "/**\n * Returns true if the cardinality of the intersection of the three\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b intersect c) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        intersection.and(c);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the two BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @return size(a intersect b)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the three BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @return size(a intersect b intersect c)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n}"
            ],
            [
                "fileInputStream",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// BufferedFileReader\n///\n// Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n/**\n * Returns an InputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStream for file\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            in = new GZIPInputStream(new FileInputStream(file));\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        in = new FileInputStream(file);\n    }\n    return in;\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return an InputStream for filename\n * @throws IOException if there is trouble reading the file\n * @throws FileNotFoundException if the file is not found\n */\npublic static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName null, or the name of a Charset to use when reading the file\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibility-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a LineNumberReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return a LineNumberReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedWriter appends to the end\n * of the file instead of the beginning\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\n// Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\npublic static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n        file_writer = new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n        file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n}"
            ],
            [
                "bufferedFileOutputStream",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedOutputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedOutputStream appends to the end\n * of the file instead of the beginning\n * @return a BufferedOutputStream for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}"
            ],
            [
                "isSubtype",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Class\n///\n/**\n * Return true iff sub is a subtype of sup.\n * If sub == sup, then sub is considered a subtype of sub and this method\n * returns true.\n * @param sub class to test for being a subtype\n * @param sup class to test for being a supertype\n * @return true iff sub is a subtype of sup\n */\n/*@Pure*/\npublic static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n        return true;\n    }\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n        return true;\n    }\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n        if (ifc == sup || isSubtype(ifc, sup)) {\n            return true;\n        }\n    }\n    return false;\n}"
            ],
            [
                "classForName",
                "plume",
                "UtilMDE",
                "/**\n * Like {@link Class#forName(String)}, but also works when the string\n * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n * <p>\n * If the given name can't be found, this method changes the last '.'  to\n * a dollar sign ($) and tries again.  This accounts for inner classes\n * that are incorrectly passed in in fully-qualified format instead of\n * binary format.\n * <p>\n * Recall the rather odd specification for {@link Class#forName(String)}:\n * the argument is a binary name for non-arrays, but a field descriptor\n * for arrays.  This method uses the same rules, but additionally handles\n * primitive types and, for non-arrays, fully-qualified names.\n * @param className name of the class\n * @return the Class corresponding to className\n * @throws ClassNotFoundException if the class is not found\n */\n// The annotation encourages proper use, even though this can take a\n// fully-qualified name (only for a non-array).\npublic static Class<?> classForName(/*@ClassGetName*/\nString className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n        return result;\n    } else {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            int pos = className.lastIndexOf('.');\n            if (pos < 0) {\n                throw e;\n            }\n            // checked below & exception is handled\n            @SuppressWarnings(\"signature\")\n            String /*@ClassGetName*/\n            inner_name = className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n            try {\n                return Class.forName(inner_name);\n            } catch (ClassNotFoundException ee) {\n                throw e;\n            }\n        }\n    }\n}"
            ],
            [
                "binaryNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a binary name to a field descriptor.\n * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n * or \"int\" to \"I\".\n * @param classname name of the class, in binary class name format\n * @return name of the class, in field descriptor format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@FieldDescriptor*/\nString binaryNameToFieldDescriptor(/*@BinaryName*/\nString classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n        dims++;\n        sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n        result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n        result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n}"
            ],
            [
                "primitiveTypeNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n * a field descriptor (e.g., \"I\", \"D\", etc.).\n * @param primitive_name name of the type, in Java format\n * @return name of the type, in field descriptor format\n * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n */\npublic static /*@FieldDescriptor*/\nString primitiveTypeNameToFieldDescriptor(String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n        throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n}"
            ],
            [
                "binaryNameToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a BinaryName to the format of {@link Class#getName()}.\n * @param bn the binary name to convert\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString binaryNameToClassGetName(/*BinaryName*/\nString bn) {\n    if (bn.endsWith(\"[]\")) {\n        return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n        return bn;\n    }\n}"
            ],
            [
                "fieldDescriptorToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n * @param fd the class, in field descriptor format\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString fieldDescriptorToClassGetName(/*FieldDescriptor*/\nString fd) {\n    if (fd.startsWith(\"[\")) {\n        return fd.replace('/', '.');\n    } else {\n        return fieldDescriptorToBinaryName(fd);\n    }\n}"
            ],
            [
                "arglistToJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert a fully-qualified argument list from Java format to JVML format.\n * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n * @param arglist an argument list, in Java format\n * @return argument list, in JVML format\n */\npublic static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n        // substring\n        @SuppressWarnings(\"signature\")\n        String /*@BinaryName*/\n        arg = args_tokenizer.nextToken().trim();\n        result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n}"
            ],
            [
                "fieldDescriptorToBinaryName",
                "plume",
                "UtilMDE",
                "// does not convert \"V\" to \"void\".  Should it?\n/**\n * Convert a field descriptor to a binary name.\n * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n * or \"I\" to \"int\".\n * @param classname name of the type, in JVML format\n * @return name of the type, in Java format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@BinaryName*/\nString fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n        throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n        dims++;\n        classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n        result = classname.substring(1, classname.length() - 1);\n    } else {\n        result = primitiveClassesFromJvm.get(classname);\n        if (result == null) {\n            throw new Error(\"Malformed base class: \" + classname);\n        }\n    }\n    for (int i = 0; i < dims; i++) {\n        result += \"[]\";\n    }\n    return result.replace('/', '.');\n}"
            ],
            [
                "arglistFromJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert an argument list from JVML format to Java format.\n * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n * @param arglist an argument list, in JVML format\n * @return argument list, in Java format\n */\npublic static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n        if (pos > 1) {\n            result += \", \";\n        }\n        int nonarray_pos = pos;\n        while (arglist.charAt(nonarray_pos) == '[') {\n            nonarray_pos++;\n        }\n        char c = arglist.charAt(nonarray_pos);\n        if (c == 'L') {\n            int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n            result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n            pos = semi_pos + 1;\n        } else {\n            String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n            if (maybe == null) {\n                // return null;\n                throw new Error(\"Malformed arglist: \" + arglist);\n            }\n            result += maybe;\n            pos = nonarray_pos + 1;\n        }\n    }\n    return result + \")\";\n}"
            ],
            [
                "defineClassFromFile",
                "plume",
                "UtilMDE",
                "/**\n * Converts the bytes in a file into an instance of class Class, and\n * resolves (links) the class.\n * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n * file name rather than an array of bytes as an argument, and also resolves\n * (links) the class.\n * @see ClassLoader#defineClass(String,byte[],int,int)\n * @param className the name of the class to define, or null if not known\n * @param pathname the pathname of a .class file\n * @return a Java Object corresponding to the Class defined in the .class file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\n// Also throws UnsupportedClassVersionError and some other exceptions.\npublic static Class<?> defineClassFromFile(/*@BinaryName*/\nString className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n}"
            ],
            [
                "count_lines",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// File\n///\n/**\n * Count the number of lines in the specified file.\n * @param filename file whose size to count\n * @return number of lines in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n        while (reader.readLine() != null) {\n            count++;\n        }\n    }\n    return count;\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param filename the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param file the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n        int unix = 0;\n        int dos = 0;\n        int mac = 0;\n        while (true) {\n            String s = r.readLine();\n            if (s == null) {\n                break;\n            }\n            if (s.endsWith(\"\\r\\n\")) {\n                dos++;\n            } else if (s.endsWith(\"\\r\")) {\n                mac++;\n            } else if (s.endsWith(\"\\n\")) {\n                unix++;\n            } else {\n                // This can happen only if the last line is not terminated.\n            }\n        }\n        if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n            return \"\\r\\n\";\n        }\n        if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n            return \"\\r\";\n        }\n        if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n            return \"\\n\";\n        }\n        // The two non-preferred line endings are tied and have more votes than\n        // the preferred line ending.  Give up and return the line separator\n        // for the system on which Java is currently running.\n        return lineSep;\n    }\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @return true iff the files have the same contents\n */\n/*@Pure*/\npublic static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff the files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @param trimLines if true, call String.trim on each line before comparing\n * @return true iff the files have the same contents\n */\n// reads files, side effects local state\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2)) {\n        String line1 = reader1.readLine();\n        String line2 = reader2.readLine();\n        while (line1 != null && line2 != null) {\n            if (trimLines) {\n                line1 = line1.trim();\n                line2 = line2.trim();\n            }\n            if (!(line1.equals(line2))) {\n                return false;\n            }\n            line1 = reader1.readLine();\n            line2 = reader2.readLine();\n        }\n        if (line1 == null && line2 == null) {\n            return true;\n        }\n        return false;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}"
            ],
            [
                "canCreateAndWrite",
                "plume",
                "UtilMDE",
                "/**\n * Returns true\n *  if the file exists and is writable, or\n *  if the file can be created.\n * @param file the file to create and write\n * @return true iff the file can be created and written\n */\npublic static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n        return file.canWrite();\n    } else {\n        File directory = file.getParentFile();\n        if (directory == null) {\n            directory = new File(\".\");\n        }\n        // Does this test need \"directory.canRead()\" also?\n        return directory.canWrite();\n    }\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n}"
            ],
            [
                "createTempDir",
                "plume",
                "UtilMDE",
                "///\n/// Directories\n///\n/**\n * Creates an empty directory in the default temporary-file directory,\n * using the given prefix and suffix to generate its name. For example,\n * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n * someString is internally generated to ensure no temporary files of the\n * same name are generated.\n * @param prefix the prefix string to be used in generating the file's\n *  name; must be at least three characters long\n * @param suffix the suffix string to be used in generating the file's\n *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n *  An abstract pathname denoting a newly-created empty file\n * @return a File representing the newly-created temporary directory\n * @throws IllegalArgumentException If the prefix argument contains fewer\n *  than three characters\n * @throws IOException If a file could not be created\n * @throws SecurityException If a security manager exists and its\n *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n *  file to be created\n * @see java.io.File#createTempFile(String, String, File)\n */\npublic static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dirName and all its files.\n * @param dirName the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dir and all its files.\n * @param dir the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n        return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    return dir.delete();\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name file whose name to expand\n * @return file with expanded file\n */\npublic static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n        return new File(newname);\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name filename to expand\n * @return expanded filename\n */\npublic static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n        return (name.replace(\"~\", userHome));\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "java_source",
                "plume",
                "UtilMDE",
                "/**\n * Return a string version of the name that can be used in Java source.\n * On Windows, the file will return a backslash separated string.  Since\n * backslash is an escape character, it must be quoted itself inside\n * the string.\n * <p>\n * The current implementation presumes that backslashes don't appear\n * in filenames except as windows path separators.  That seems like a\n * reasonable assumption.\n *\n * @param name file to quote\n * @return a string version of the name that can be used in Java source\n */\npublic static String java_source(File name) {\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n}"
            ],
            [
                "readObject",
                "plume",
                "UtilMDE",
                "/**\n * Reads an Object from a File.\n * @param file the file from which to read\n * @return the object read from the file\n * @throws IOException if there is trouble reading the file\n * @throws ClassNotFoundException if the object's class cannot be found\n */\npublic static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            istream = new GZIPInputStream(istream);\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n}"
            ],
            [
                "readerContents",
                "plume",
                "UtilMDE",
                "/**\n * Reads the entire contents of the reader and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param r the Reader to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readerContents(Reader r) {\n    try {\n        StringBuilder contents = new StringBuilder();\n        int ch;\n        while ((ch = r.read()) != -1) {\n            contents.append((char) ch);\n        }\n        r.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n}"
            ],
            [
                "readFile",
                "plume",
                "UtilMDE",
                "// an alternate name would be \"fileContents\".\n/**\n * Reads the entire contents of the file and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param file the file to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readFile(File file) {\n    try {\n        BufferedReader reader = UtilMDE.bufferedFileReader(file);\n        StringBuilder contents = new StringBuilder();\n        String line = reader.readLine();\n        while (line != null) {\n            contents.append(line);\n            // Note that this converts line terminators!\n            contents.append(lineSep);\n            line = reader.readLine();\n        }\n        reader.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Hashing\n///\n// In hashing, there are two separate issues.  First, one must convert\n// the input datum into an integer.  Then, one must transform the\n// resulting integer in a pseudorandom way so as to result in a number\n// that is far separated from other values that may have been near it to\n// begin with.  Often these two steps are combined, particularly if\n// one wishes to avoid creating too large an integer (losing information\n// off the top bits).\n// http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n//  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n//    h += (h<<3); h ^= (h>>11); h += (h<<15);\n//    is good.\n//  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n//  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n// In this part of the file, perhaps I will eventually write good hash\n// functions.  For now, write cheesy ones that primarily deal with the\n// first issue, transforming a data structure into a single number.  This\n// is also known as fingerprinting.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Double#hashCode()}.\n * @param x value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a) {\n    double result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a, double[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/// Don't define hash with int args; use the long versions instead.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Long#hashCode()}.\n * But it doesn't map -1 and 0 to the same value.\n * @param l value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n        return (int) l;\n    }\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a, long[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a) {\n    return (a == null) ? 0 : a.hashCode();\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b, /*@Nullable*/\nString c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + hash(a[i]);\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @param random the Random instance to use to make selections\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n    while (itor.hasNext()) {\n        rs.accept(itor.next());\n    }\n    return rs.getValues();\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n}"
            ],
            [
                "incrementMap",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Map\n///\n// In Python, inlining this gave a 10x speed improvement.\n// Will the same be true for Java?\n/**\n * Increment the Integer which is indexed by key in the Map.\n * If the key isn't in the Map, it is added.\n * @param <T> type of keys in the map\n * @param m map to have one of its values incremented\n * @param key the key for the element whose value will be incremented\n * @param count how much to increment the value by\n * @return the old value, before it was incremented\n * @throws Error if the key is in the Map but maps to a non-Integer.\n */\npublic static <T> /*@Nullable*/\nInteger incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n        new_total = count;\n    } else {\n        new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n}"
            ],
            [
                "mapToString",
                "plume",
                "UtilMDE",
                "/**\n * Returns a multi-line string representation of a map.\n * @param <K> type of map keys\n * @param <V> type of map values\n * @param m map to be converted to a string\n * @return a multi-line string representation of m\n */\npublic static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @return a sorted version of m.keySet()\n */\npublic static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @param comparator the Comparator to use for sorting\n * @return a sorted version of m.keySet()\n */\npublic static <K, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m, Comparator<K> comparator) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a method signature, return the method.\n * Example calls are:\n * <pre>\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n * </pre>\n * @param method a method signature\n * @return the method corresponding to the given signature\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n        throw new Error(\"malformed method name should contain a period, open paren, and close paren: \" + method + \" <<\" + dotpos + \",\" + oparenpos + \",\" + cparenpos + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n        if (!Character.isWhitespace(method.charAt(i))) {\n            throw new Error(\"malformed method name should contain only whitespace following close paren\");\n        }\n    }\n    // throws exception if class does not exist\n    @SuppressWarnings(\"signature\")\n    String /*@BinaryNameForNonArray*/\n    classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n        String[] argnames;\n        if (all_argnames.equals(\"\")) {\n            argnames = new String[0];\n        } else {\n            argnames = split(all_argnames, ',');\n        }\n        /*@MonotonicNonNull*/\n        Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n        for (int i = 0; i < argnames.length; i++) {\n            String bnArgname = argnames[i].trim();\n            /*@ClassGetName*/\n            String cgnArgname = binaryNameToClassGetName(bnArgname);\n            argclasses_tmp[i] = classForName(cgnArgname);\n        }\n        @SuppressWarnings(\"cast\")\n        Class<?>[] argclasses_res = (Class<?>[]) argclasses_tmp;\n        argclasses = argclasses_res;\n        args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a class name and a method name in that class, return the method.\n * @param classname class in which to find the method\n * @param methodname the method name\n * @param params the parameters of the method\n * @return the method named classname.methodname with parameters params\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(/*@BinaryNameForNonArray*/\nString classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// ProcessBuilder\n///\n/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line\n * @return all the output of the command\n */\npublic static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line, as a list of\n * strings (the command, then its arguments)\n * @return all the output of the command\n */\npublic static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n        Process p = pb.start();\n        @SuppressWarnings(// input stream is non-null because we didn't redirect the input stream\n        \"nullness\")\n        String output = UtilMDE.streamString(p.getInputStream());\n        return output;\n    } catch (IOException e) {\n        return \"IOException: \" + e.getMessage();\n    }\n}"
            ],
            [
                "propertyIsTrue",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Properties\n///\n/**\n * Determines whether a property has value \"true\", \"yes\", or \"1\".\n * @see Properties#getProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @return true iff the property has value \"true\", \"yes\", or \"1\"\n */\n// does not depend on object identity\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n        return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n}"
            ],
            [
                "appendProperty",
                "plume",
                "UtilMDE",
                "/**\n * Set the property to its previous value concatenated to the given value.\n * Return the previous value.\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to concatenate to the previous value of the property\n * @return the previous value of the property\n * @see Properties#getProperty\n * @see Properties#setProperty\n */\npublic static /*@Nullable*/\nString appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n}"
            ],
            [
                "setDefaultMaybe",
                "plume",
                "UtilMDE",
                "/**\n * Set the property only if it was not previously set.\n * @see Properties#getProperty\n * @see Properties#setProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to set the property to, if it is not already set\n * @return the previous value of the property\n */\npublic static /*@Nullable*/\nString setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n        p.setProperty(key, value);\n    }\n    return currentValue;\n}"
            ],
            [
                "getPrivateField",
                "plume",
                "UtilMDE",
                "// TODO: set the field back to private after is is accessed.\n/**\n * Reads the given field, which may be private.\n * Leaves the field accessible.\n * Use with care!\n * @param o object in which to set the field\n * @param fieldName name of field to set\n * @return new value of field\n * @throws NoSuchFieldException if the field does not exist in the object\n */\npublic static /*@Nullable*/\nObject getPrivateField(Object o, String fieldName) throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) {\n        // Class is interned\n        // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n        try {\n            Field f = c.getDeclaredField(fieldName);\n            f.setAccessible(true);\n            return f.get(o);\n        } catch (IllegalAccessException e) {\n            System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n            throw new Error(\"This can't happen: \" + e);\n        } catch (NoSuchFieldException e) {\n            if (c.getSuperclass() == Object.class) {\n                // Class is interned\n                throw e;\n            }\n            // nothing to do; will now examine superclass\n        }\n        c = c.getSuperclass();\n        assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n}"
            ],
            [
                "getFromSet",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set\n///\n/**\n * Return the object in this set that is equal to key.\n * The Set abstraction doesn't provide this; it only provides \"contains\".\n * Returns null if the argument is null, or if it isn't in the set.\n * @param set a set in which to look up the value\n * @param key the value to look up in the set\n * @return the object in this set that is equal to key, or null\n */\npublic static /*@Nullable*/\nObject getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n        return null;\n    }\n    for (Object elt : set) {\n        if (key.equals(elt)) {\n            return elt;\n        }\n    }\n    return null;\n}"
            ],
            [
                "streamString",
                "plume",
                "UtilMDE",
                "/**\n * Return a String containing all the characters from the input stream.\n * @param is input stream to read\n * @return a String containing all the characters from the input stream\n */\npublic static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n}"
            ],
            [
                "replaceString",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// String\n///\n/**\n * Return a new string which is the text of target with all instances of\n * oldStr replaced by newStr.\n * @param target the string to do replacement in\n * @param oldStr the substring to replace\n * @param newStr the replacement\n * @return target with all instances of oldStr replaced by newStr\n */\npublic static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n        throw new IllegalArgumentException();\n    }\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n        result.append(target.substring(lastend, pos));\n        result.append(newStr);\n        lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter character.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, String delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter String.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, char delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n        throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "splitLines",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings, one for each line in the argument.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n * are supported.  Note that a string that ends with a line separator\n * will return an empty string as the last element of the array.\n * @see #split(String s, char delim)\n * @param s the string to split\n * @return an array of Strings, one for each line in the argument\n */\npublic static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the array elements, placing the\n * delimiter between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n        return \"\";\n    }\n    if (a.length == 1) {\n        return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n        sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(Object... a) {\n    return join(a, lineSep);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * delimiter between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n        return \"\";\n    }\n    if (v.size() == 1) {\n        return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n        sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(List<String> v) {\n    return join(v, lineSep);\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Escape \\, \", newline, and carriage-return characters in the\n * target as \\\\, \\\", \\n, and \\r; return a new string if any\n * modifications were necessary.  The intent is that by surrounding\n * the return value with double quote marks, the result will be a\n * Java string literal denoting the original string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        switch(c) {\n            case '\\\"':\n            case '\\\\':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append('\\\\');\n                post_esc = i;\n                break;\n            case // not lineSep\n            '\\n':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                // not lineSep\n                sb.append(\"\\\\n\");\n                post_esc = i + 1;\n                break;\n            case '\\r':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append(\"\\\\r\");\n                post_esc = i + 1;\n                break;\n            default:\n        }\n    }\n    if (sb.length() == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "// The overhead of this is too high to call in escapeNonJava(String), so\n// it is inlined there.\n/**\n * Like {@link #escapeNonJava(String)}, but for a single character.\n * @param ch character to quote\n * @return quoted version och ch\n */\npublic static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch(c) {\n        case '\\\"':\n            return \"\\\\\\\"\";\n        case '\\\\':\n            return \"\\\\\\\\\";\n        case // not lineSep\n        '\\n':\n            // not lineSep\n            return \"\\\\n\";\n        case '\\r':\n            return \"\\\\r\";\n        default:\n            return new String(new char[] { c });\n    }\n}"
            ],
            [
                "escapeNonASCII",
                "plume",
                "UtilMDE",
                "/**\n * Escape unprintable characters in the target, following the usual\n * Java backslash conventions, so that the result is sure to be\n * printable ASCII.  Returns a new string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n}"
            ],
            [
                "unescapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n * one-character equivalents.  All other backslashes are removed\n * (for instance, octal/hex escape sequences are not turned into\n * their respective characters). This is the inverse operation of\n * escapeNonJava(). Previously known as unquote().\n * @param orig string to quoto\n * @return quoted version of orig\n */\npublic static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n        if (this_esc == orig.length() - 1) {\n            sb.append(orig.substring(post_esc, this_esc + 1));\n            post_esc = this_esc + 1;\n            break;\n        }\n        switch(orig.charAt(this_esc + 1)) {\n            case 'n':\n                sb.append(orig.substring(post_esc, this_esc));\n                // not lineSep\n                sb.append('\\n');\n                post_esc = this_esc + 2;\n                break;\n            case 'r':\n                sb.append(orig.substring(post_esc, this_esc));\n                sb.append('\\r');\n                post_esc = this_esc + 2;\n                break;\n            case '\\\\':\n                // This is not in the default case because the search would find\n                // the quoted backslash.  Here we incluce the first backslash in\n                // the output, but not the first.\n                sb.append(orig.substring(post_esc, this_esc + 1));\n                post_esc = this_esc + 2;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                sb.append(orig.substring(post_esc, this_esc));\n                char octal_char = 0;\n                int ii = this_esc + 1;\n                while (ii < orig.length()) {\n                    char ch = orig.charAt(ii++);\n                    if ((ch < '0') || (ch > '8')) {\n                        break;\n                    }\n                    octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n                }\n                sb.append(octal_char);\n                post_esc = ii - 1;\n                break;\n            default:\n                // In the default case, retain the character following the backslash,\n                // but discard the backslash itself.  \"\\*\" is just a one-character string.\n                sb.append(orig.substring(post_esc, this_esc));\n                post_esc = this_esc + 1;\n                break;\n        }\n        this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "removeWhitespaceAround",
                "plume",
                "UtilMDE",
                "// Use the built-in String.trim()!\n// /** Return the string with all leading and trailing whitespace stripped. */\n// public static String trimWhitespace(String s) {\n//   int len = s.length();\n//   if (len == 0)\n//     return s;\n//   int first_non_ws = 0;\n//   int last_non_ws = len-1;\n//   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n//     first_non_ws++;\n//   if (first_non_ws == len)\n//     return \"\";\n//   while (Character.isWhitespace(s.charAt(last_non_ws)))\n//     last_non_ws--;\n//   if ((first_non_ws == 0) && (last_non_ws == len)) {\n//     return s;\n//   } else {\n//     return s.substring(first_non_ws, last_non_ws+1);\n//   }\n// }\n// // // Testing:\n// // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n// // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n// // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n/**\n * Remove all whitespace before or after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace abutting\n * @return version of arg, with whitespace abutting delimiter removed\n */\npublic static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n}"
            ],
            [
                "removeWhitespaceAfter",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace after\n * @return version of arg, with whitespace after delimiter removed\n */\npublic static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index + delim_len;\n        while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index++;\n        }\n        // if (non_ws_index == arg.length()) {\n        //   System.out.println(\"No nonspace character at end of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index + delim_len) {\n            arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n        }\n        delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n}"
            ],
            [
                "removeWhitespaceBefore",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace before instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace before\n * @return version of arg, with whitespace before delimiter removed\n */\npublic static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index - 1;\n        while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index--;\n        }\n        // if (non_ws_index == -1) {\n        //   System.out.println(\"No nonspace character at front of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index - 1) {\n            arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n        }\n        delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n}"
            ],
            [
                "nplural",
                "plume",
                "UtilMDE",
                "/**\n * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n * @param n count of nouns\n * @param noun word being counted\n * @return noun, if n==1; otherwise, pluralization of noun\n */\npublic static String nplural(int n, String noun) {\n    if (n == 1) {\n        return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\") || noun.endsWith(\"s\") || noun.endsWith(\"sh\") || noun.endsWith(\"x\")) {\n        return n + \" \" + noun + \"es\";\n    } else {\n        return n + \" \" + noun + \"s\";\n    }\n}"
            ],
            [
                "lpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the left if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String lpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString() + s;\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the right if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String rpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n * @param num int whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n * @param num double whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the character appears in the string.\n * @param s string to search in\n * @param ch character to search for\n * @return number of times the character appears in the string\n */\npublic static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the second string appears in the first.\n * @param s string to search in\n * @param sub string to search for\n * @return number of times the substring appears in the string\n */\npublic static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// StringTokenizer\n///\n/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n * <p>\n * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n * (probably due to backward-compatibility).\n * @param str a string to be parsed\n * @param delim the delimiters\n * @param returnDelims flag indicating whether to return the delimiters as tokens\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n * @param str a string to be parsed\n * @param delim the delimiters\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n * @param str a string to be parsed\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n}"
            ],
            [
                "backTrace",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Throwable\n///\n/**\n * Return a String representation of the backtrace of the given Throwable.\n * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n * @param t the Throwable to obtain a backtrace of\n * @return a String representation of the backtrace of the given Throwable\n */\npublic static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n}"
            ],
            [
                "sortList",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Collections\n///\n/**\n * Return the sorted version of the list.  Does not alter the list.\n * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n * @return a sorted version of the list\n * @param <T> type of elements of the list\n * @param l a list to sort\n * @param c a sorted version of the list\n */\npublic static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n}"
            ],
            [
                "removeDuplicates",
                "plume",
                "UtilMDE",
                "// This should perhaps be named withoutDuplicates to emphasize that\n// it does not side-effect its argument.\n/**\n * Return a copy of the list with duplicates removed.\n * Retains the original order.\n * @param <T> type of elements of the list\n * @param l a list to remove duplicates from\n * @return a copy of the list with duplicates removed\n */\npublic static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n}"
            ],
            [
                "deepEquals",
                "plume",
                "UtilMDE",
                "/**\n * Determines deep equality for the elements.\n * <ul>\n * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n * <li>If both are lists, uses deepEquals recursively on each element.\n * <li>For other types, just uses equals() and does not recursively call this method.\n * </ul>\n * @param o1 first value to compare\n * @param o2 second value to comare\n * @return true iff o1 and o2 are deeply equal\n */\n// side effect to static field deepEqualsUnderway\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean deepEquals(/*@Nullable*/\nObject o1, /*@Nullable*/\nObject o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    // creates local state\n    @SuppressWarnings(\"purity\")\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n        return true;\n    }\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n        List<?> l1 = (List<?>) o1;\n        List<?> l2 = (List<?>) o2;\n        if (l1.size() != l2.size()) {\n            return false;\n        }\n        try {\n            deepEqualsUnderway.add(mypair);\n            for (int i = 0; i < l1.size(); i++) {\n                Object e1 = l1.get(i);\n                Object e2 = l2.get(i);\n                if (!deepEquals(e1, e2)) {\n                    return false;\n                }\n            }\n        } finally {\n            deepEqualsUnderway.remove(mypair);\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}"
            ],
            [
                "makeVector",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Vector\n///\n/**\n * Returns a vector containing the elements of the enumeration.\n * @param <T> type of the enumeration and vector elements\n * @param e an enumeration to convert to a Vector\n * @return a vector containing the elements of the enumeration\n */\npublic static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n        result.addElement(e.nextElement());\n    }\n    return result;\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "// Rather than writing something like VectorToStringArray, use\n//   v.toArray(new String[0])\n/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of the specified objects starting at index\n * start over dims dimensions, for dims &gt; 0.\n * <p>\n * For example, create_combinations (1, 0, {a, b, c}) returns:\n * <pre>\n *    {a}, {b}, {c}\n * </pre>\n * And create_combinations (2, 0, {a, b, c}) returns:\n * <pre>\n *    {a, a}, {a, b}, {a, c}\n *    {b, b}, {b, c},\n *    {c, c}\n * </pre>\n * @param <T> type of the input list elements, and type of the innermost output list elements\n * @param dims number of dimensions:  that is, size of each innermost list\n * @param start initial index\n * @param objs list of elements to\n * @return list of lists of length dims, each of which combines elements from objs\n */\npublic static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n    if (dims < 1) {\n        throw new IllegalArgumentException();\n    }\n    List<List<T>> results = new ArrayList<List<T>>();\n    for (int i = start; i < objs.size(); i++) {\n        if (dims == 1) {\n            List<T> simple = new ArrayList<T>();\n            simple.add(objs.get(i));\n            results.add(simple);\n        } else {\n            List<List<T>> combos = create_combinations(dims - 1, i, objs);\n            for (List<T> lt : combos) {\n                List<T> simple = new ArrayList<T>();\n                simple.add(objs.get(i));\n                simple.addAll(lt);\n                results.add(simple);\n            }\n        }\n    }\n    return (results);\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of integers from start to cnt (inclusive) over\n * arity dimensions.\n * <p>\n * For example, create_combinations (1, 0, 2) returns:\n * <pre>\n *    {0}, {1}, {2}\n * </pre>\n * And create_combinations (2, 0, 2) returns:\n * <pre>\n *    {0, 0}, {0, 1}, {0, 2}\n *    {1, 1}  {1, 2},\n *    {2, 2}\n * </pre>\n * @param arity size of each innermost list\n * @param start initial value\n * @param cnt maximum element value\n * @return list of lists of length arity, each of which combines integers from start to cnt\n */\npublic static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n        results.add(new ArrayList<Integer>());\n        return (results);\n    }\n    for (int i = start; i <= cnt; i++) {\n        ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n        for (ArrayList<Integer> li : combos) {\n            ArrayList<Integer> simple = new ArrayList<Integer>();\n            simple.add(new Integer(i));\n            simple.addAll(li);\n            results.add(simple);\n        }\n    }\n    return (results);\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(/*@FullyQualifiedName*/\nString qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n}"
            ],
            [
                "fullyQualifiedNameToSimpleName",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n// TODO: does not follow the specification for inner classes (where the\n// type name should be empty), but I think this is more informative anyway.\n// string conversion\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetSimpleName*/\nString fullyQualifiedNameToSimpleName(/*@FullyQualifiedName*/\nString qualified_name) {\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n        return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified class.  For example if qualified name of the class\n * is java.lang.String, String will be returned.\n *\n * @deprecated use {@link Class#getSimpleName()} instead.\n *\n * @param cls a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n}"
            ],
            [
                "abbreviateNumber",
                "plume",
                "UtilMDE",
                "/**\n * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n * of precision in the result (counting both sides of the decimal point).\n * @param val a numeric value\n * @return an abbreviated string representation of the value\n */\npublic static String abbreviateNumber(long val) {\n    double dval = (double) val;\n    String mag = \"\";\n    if (val < 1000) {\n        // nothing to do\n    } else if (val < 1000000) {\n        dval = val / 1000.0;\n        mag = \"K\";\n    } else if (val < 1000000000) {\n        dval = val / 1000000.0;\n        mag = \"M\";\n    } else {\n        dval = val / 1000000000.0;\n        mag = \"G\";\n    }\n    String precision = \"0\";\n    if (dval < 10) {\n        precision = \"2\";\n    } else if (dval < 100) {\n        precision = \"1\";\n    }\n    // format string computed from precision and mag\n    @SuppressWarnings(\"formatter\")\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeIntSet",
                "/**\n * Merges a list of LimitedSizeIntSet objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param max_values the maximum size for the returned LimitedSizeIntSet\n * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n * @return a LimitedSizeIntSet that merges the elements of slist\n */\npublic static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist) {\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ],
            [
                "of",
                "plume",
                "Triple",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param <C> type of third argument\n * @param a first argument\n * @param b second argument\n * @param c third argument\n * @return a triple of the values (a, b, c)\n */\npublic static <A, B, C> Triple<A, B, C> of(A a, B b, C c) {\n    return new Triple<A, B, C>(a, b, c);\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// min, max\n///\n// Could also add linear-time orderStatistics if I liked.\n/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int min(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long min(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double min(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer min(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long min(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() < result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double min(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int max(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long max(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double max(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer max(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long max(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() > result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double max(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int[] min_max(int[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] { result_min, result_max };\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long[] min_max(long[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] { result_min, result_max };\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int element_range(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long element_range(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of integers.\n * @param a an array\n * @return the sum of an array of integers\n */\npublic static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of integers.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of integers\n */\npublic static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of doubles.\n * @param a an array\n * @return the sum of an array of doubles\n */\npublic static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of doubles.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of doubles\n */\npublic static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf\n///\n/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> type of the elements of the array\n * @param a an array\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt) {\n    if (elt == null) {\n        return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> the type of the elements\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n *    Identical to List.indexOf, but included for completeness.\n * @param a a list\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    return a.indexOf(elt);\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a.get(i))) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyNull*/\nObject[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.size(); i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf, for finding subarrays\n///\n// This is analogous to Common Lisp's \"search\" function.\n// This implementation is very inefficient; I could use tricky Boyer-Moore\n// search techniques if I liked, but it's not worth it to me yet.\n/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n// The signature on this method is unnecessarily strict because it\n// requires that the component types be identical.  The signature should\n// be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n// @PolyAll qualifier does not yet take an argument.\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// mismatch\n///\n// This is analogous to Common Lisp's \"mismatch\" function.\n// Put it off until later; for now, use the simpler subarray function,\n// which is a specialization of mismatch,\n///////////////////////////////////////////////////////////////////////////\n/// subarray extraction\n///\n// Note that the second argument is a length, not an end position.\n// That's to avoid confusion over whether it would be the last included\n// index or the first non-included index.\n/**\n * Return a subarray of the given array.\n * @return a subarray of the given array\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n */\n/*@SideEffectFree*/\npublic static Object[] subarray(/*@PolyAll*/\nObject[] a, int startindex, int length) {\n    /*@PolyAll*/\n    Object[] result = new /*@PolyAll*/\n    Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a sublist of the given list.\n * @param <T> type of the elements\n * @param a the original list\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a sublist of the given list\n */\n/*@SideEffectFree*/\npublic static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static String[] subarray(/*@PolyAll*/\nString[] a, int startindex, int length) {\n    /*@PolyAll*/\n    String[] result = new /*@PolyAll*/\n    String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// subarray testing\n///\n/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, /*@PolyNull*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.size()];\n            System.arraycopy(a, 0, result, 0, a.length);\n            // System.arraycopy(b, 0, result, a.length, b.size());\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.length] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.length];\n            // System.arraycopy(a, 0, result, 0, a.size());\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            System.arraycopy(b, 0, result, a.size(), b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.size()];\n            // System.arraycopy(a, 0, result, 0, a.length);\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            // System.arraycopy(b, 0, result, a.length, b.length);\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.size()] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "// Note: PolyAll is not quite right.  Need to review.\n/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first array to concatenate\n * @param b the second array to concatenate\n * @return an array that concatenates the arguments\n */\npublic static String[] concat(/*@PolyAll*/\nString[] a, /*@PolyAll*/\nString[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new String[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            /*@PolyAll*/\n            String[] result = new String[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static byte[] concat(byte[] a, byte[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new byte[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            byte[] result = new byte[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static boolean[] concat(boolean[] a, boolean[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new boolean[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            boolean[] result = new boolean[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static char[] concat(char[] a, char[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new char[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            char[] result = new char[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static double[] concat(double[] a, double[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new double[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            double[] result = new double[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static float[] concat(float[] a, float[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new float[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            float[] result = new float[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static int[] concat(int[] a, int[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new int[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            int[] result = new int[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static long[] concat(long[] a, long[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new long[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            long[] result = new long[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static short[] concat(short[] a, short[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new short[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            short[] result = new short[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Printing\n///\n// This should be extended to all types, when I get around to it.  The\n// methods are patterned after that of java.util.Vector (and use its\n// output format).\n/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@PolyAll*/\nObject[] a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, each element is quoted like a Java String.\n * @param a an array\n * @return a string representation of the array, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@PolyAll*/\nObject[] a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, if quoted is true, then each element is quoted like a Java String.\n * @param a an array\n * @param quoted whether to quote the array elements\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@PolyAll*/\nObject[] a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            if (quoted && a[i] instanceof String) {\n                String elt = (String) a[i];\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava(elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(a[i]);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @param quoted whether to quote the collection elements that are Java strings\n * @return a string representation of the list\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@Nullable*/\nCollection<?> a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n        Iterator<?> itor = a.iterator();\n        sb.append(itor.next());\n        while (itor.hasNext()) {\n            sb.append(\", \");\n            Object elt = itor.next();\n            if (quoted && elt instanceof String) {\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava((String) elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(elt);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(int[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(long[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(double[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(float[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(boolean[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls the appropriate\n * toString() method.  Only call this method if obj is a boolean, double,\n * int, long, or Object array.\n * @param obj an array\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n        return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n        return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n        return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n        return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n        return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n        return toString((List<?>) obj);\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "length",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls .length.\n * Only call this method if obj is a boolean, double, int, long, or Object array.\n * @param obj a list\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n        return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n        return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n        return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n        return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n        return ((List<?>) obj).size();\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Sortedness\n///\n/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Boolean n = Boolean.valueOf(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Byte n = new Byte(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Float n = new Float(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Short n = new Short(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Integer n = new Integer(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space. Equality checking\n * uses the .equals() method for java.lang.Double.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Double n = new Double(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Long n = new Long(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param <T> the type of the elements\n * @param a a list\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static </*@Pure*/\nT> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n        if (hs.contains(a.get(i))) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a.get(i));\n    }\n    return true;\n}"
            ],
            [
                "fn_is_permutation",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Arrays as partial functions of int->int\n///\n/**\n * Returns true if the array is a permutation of [0..a.length).\n * @param a an array, representing a function\n * @return true iff all elements of a are in [0..a.length) and a\n * contains no duplicates.\n */\n// side effect to local state (array)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int n = a[i];\n        if (n < 0 || n >= a.length || see[n]) {\n            return false;\n        }\n        see[n] = true;\n    }\n    return true;\n}"
            ],
            [
                "fn_is_total",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff the array does not contain -1.\n * @param a an array, representing a function\n * @return true iff no element of a maps to -1\n */\n/*@Pure*/\npublic static boolean fn_is_total(int[] a) {\n    // not found\n    return indexOf(a, -1) == -1;\n}"
            ],
            [
                "fn_identity",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array [0..lenth).\n * @param length the length of the result\n * @return fresh array that is the identity function of the given length\n */\npublic static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n        result[i] = i;\n    }\n    return result;\n}"
            ],
            [
                "fn_inverse_permutation",
                "plume",
                "ArraysMDE",
                "/**\n * Requires that fn_is_permutation(a) holds.\n * @param a the input permutation\n * @return fresh array which is the inverse of the given permutation\n * @see #fn_is_permutation(int[])\n */\npublic static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n}"
            ],
            [
                "fn_inverse",
                "plume",
                "ArraysMDE",
                "/**\n * Return the inverse of the given function, which is represented as an array.\n * @param a an array representing a function from [0..a.length) to [0..arange);\n *  each element of a is between 0 and arange inclusive\n * @param arange length of the argument's range and the result's domain\n * @return function from [0..arange) to [0..a.length) that is the inverse of a\n * @throws IllegalArgumentException if a value of a is outside of arange\n * @exception UnsupportedOperationException when the function is not invertible\n */\npublic static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n        int ai = a[i];\n        if (ai < -1 || ai >= arange) {\n            throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n        }\n        // ai is either -1 or a valid index\n        if (ai >= 0) {\n            if (result[ai] != -1) {\n                throw new UnsupportedOperationException(String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n            }\n            result[ai] = i;\n        }\n    }\n    return result;\n}"
            ],
            [
                "fn_compose",
                "plume",
                "ArraysMDE",
                "/**\n * Return the composition of the given two functions, all of which are\n * represented as arrays.\n * @param a function from [0..a.length) to [0..b.length)\n * @param b function from [0..b.length) to range R\n * @return function from [0..a.length) to range R that is the\n * composition of a and b\n */\npublic static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int inner = a[i];\n        if (inner == -1) {\n            result[i] = -1;\n        } else {\n            result[i] = b[inner];\n        }\n    }\n    return result;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set operations, such as subset, unions, and intersections\n///\n// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Long(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Long elt = new Long(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Double(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Double elt = new Double(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(bigger[i]);\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        if (!setBigger.contains(smaller[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// nullness\n///\n/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(/*@PolyAll*/\nObject[] a) {\n    if (a.length == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(/*@PolyAll*/\nObject[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (!(a[i] == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n        if (!(a.get(i) == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "int_array_iterator",
                "plume",
                "TestPlume",
                "///////////////////////////////////////////////////////////////////////////\n/// Utility functions\n///\npublic static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n        asList.add(nums[i]);\n    }\n    return asList.iterator();\n}"
            ],
            [
                "int_iterator_array",
                "plume",
                "TestPlume",
                "public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    return v;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n        v.add(e.nextElement());\n    }\n    return v;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeSet",
                "/**\n * Merges a list of LimitedSizeSet&lt;T&gt; objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param <T> (super)type of elements of the sets\n * @param max_values the maximum size for the returned LimitedSizeSet\n * @param slist a list of LimitedSizeSet, whose elements will be merged\n * @return a LimitedSizeSet that merges the elements of slist\n */\npublic static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist) {\n    LimitedSizeSet<T> result = new LimitedSizeSet<T>(max_values);\n    for (LimitedSizeSet<? extends T> s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "serialVersionUID",
                "plume",
                "FileIOException",
                "static final long serialVersionUID = 20050923L;"
            ],
            [
                "counter",
                "plume",
                "DeterministicObject",
                "/**\n * The number of objects created so far.\n */\nstatic int counter = 0;"
            ],
            [
                "home",
                "plume",
                "MultiVersionControl",
                "@Option(value = \"User home directory\", noDocDefault = true)\npublic static String home = System.getProperty(\"user.home\");"
            ],
            [
                "debug",
                "plume",
                "MultiVersionControl",
                "// It would be good to be able to set this per-checkout.\n// This variable is static because it is used in static methods.\n@Option(\"Print debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "idf",
                "plume",
                "MultiVersionControl",
                "static IsDirectoryFilter idf = new IsDirectoryFilter();"
            ],
            [
                "help",
                "plume",
                "Lookup",
                "/**\n * Show detailed help information and exit.\n */\n@OptionGroup(\"Getting help\")\n@Option(\"-h Show detailed help information\")\npublic static boolean help = false;"
            ],
            [
                "verbose",
                "plume",
                "Lookup",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "entry_file",
                "plume",
                "Lookup",
                "// This uses only the first file because the default search path might be\n// something like user:system and you might want only your version of the\n// system files.  It might be useful to also support (via another flag,\n// or by taking over this one, or by the syntax of the separator, or in\n// some other way) specifying multiple files on the command line.\n/**\n * Specify the colon-separated search list for the file that contains\n * information to be searched.  Only the first file found is used, though\n * it may itself contain include directives.\n */\n@OptionGroup(\"Where to search\")\n@Option(\"-f Specify the colon-separated search list of files of information; may only be supplied once\")\npublic static String entry_file = \"~/lookup/root\";"
            ],
            [
                "search_body",
                "plume",
                "Lookup",
                "/**\n * Search the body of long entries in addition to the entry's\n * description.  The bodies of short entries are always searched.\n */\n@Option(\"-b Search body of long entries for matches\")\npublic static boolean search_body = false;"
            ],
            [
                "regular_expressions",
                "plume",
                "Lookup",
                "/**\n * Specifies that keywords are regular expressions.  If false, keywords\n * are text matches.\n */\n@OptionGroup(\"What to search for\")\n@Option(\"-e Keywords are regular expressions\")\npublic static boolean regular_expressions = false;"
            ],
            [
                "case_sensitive",
                "plume",
                "Lookup",
                "/**\n * If true, keywords matching is case sensistive.  By default, both\n * regular expressions and text keywords are case-insensitive.\n */\n@Option(\"-c Keywords are case sensistive\")\npublic static boolean case_sensitive = false;"
            ],
            [
                "word_match",
                "plume",
                "Lookup",
                "/**\n * If true, match a text keyword only as a separate word, not as a\n * substring of a word.  This option is ignored if\n * regular_expressions is true.\n */\n@Option(\"-w Only match text keywords against complete words\")\npublic static boolean word_match = false;"
            ],
            [
                "print_all",
                "plume",
                "Lookup",
                "/**\n * By default, if multiple entries are matched, only a synopsis\n * of each entry is printed.  If 'print_all' is selected then\n * the body of each matching entry is printed.\n */\n@OptionGroup(\"How to print matches\")\n@Option(\"-a Print the entire entry for each match\")\npublic static boolean print_all = false;"
            ],
            [
                "item_num",
                "plume",
                "Lookup",
                "/**\n * Specifies which item to print when there are multiple matches.\n * The index is 1-based; that is, it starts counting at 1.\n */\n@Option(\"-i Choose a specific item when there are multiple matches; index is 1-based\")\npublic static Integer /*@Nullable*/\nitem_num;"
            ],
            [
                "show_location",
                "plume",
                "Lookup",
                "/**\n * If true, show the filename/line number of each matching entry\n * in the output.\n */\n@Option(\"-l Show the location of each matching entry\")\npublic static boolean show_location = false;"
            ],
            [
                "entry_start_re",
                "plume",
                "Lookup",
                "@OptionGroup(\"Customizing format of files to be searched\")\n@Option(\"Regex that denotes the start of a long entry\")\npublic static Pattern /*@Regex(1)*/\nentry_start_re = Pattern.compile(\"^>entry *()\");"
            ],
            [
                "entry_stop_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that denotes the end of a long entry\")\npublic static Pattern entry_stop_re = Pattern.compile(\"^<entry\");"
            ],
            [
                "description_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that finds an entry's description (for long entries)\")\npublic static Pattern /*@Nullable*/\ndescription_re = null;"
            ],
            [
                "comment_re",
                "plume",
                "Lookup",
                "// If \"\", gets set to null immediately after option processing.\n@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Nullable*/\n/*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "runtime",
                "plume",
                "FileCompiler",
                "/**\n * The Runtime of the JVM.\n */\npublic static Runtime runtime = java.lang.Runtime.getRuntime();"
            ],
            [
                "java_filename_pattern",
                "plume",
                "FileCompiler",
                "/**\n * Matches the names of Java source files.\n * Match group 1 is the complete filename.\n */\nstatic Pattern /*@Regex(1)*/\njava_filename_pattern;"
            ],
            [
                "responsible",
                "plume",
                "TaskManager",
                "// Command line options\n@Option(\"-r Include only those tasks assigned to the specified person\")\npublic static String /*@Nullable*/\nresponsible = null;"
            ],
            [
                "milestone",
                "plume",
                "TaskManager",
                "@Option(\"-m Include only those tasks required for the specified milestone\")\npublic static String /*@Nullable*/\nmilestone = null;"
            ],
            [
                "completed",
                "plume",
                "TaskManager",
                "@Option(\"-c Include only completed tasks\")\npublic static boolean completed = false;"
            ],
            [
                "open",
                "plume",
                "TaskManager",
                "@Option(\"-o Include only open tasks\")\npublic static boolean open = false;"
            ],
            [
                "verbose",
                "plume",
                "TaskManager",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "format",
                "plume",
                "TaskManager",
                "@Option(\"-f Specify output format\")\npublic static OutputFormat format = OutputFormat.short_ascii;"
            ],
            [
                "comment_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "lineSep",
                "plume",
                "TaskManager",
                "// line.separator property is a legal regex\n@SuppressWarnings(\"regex\")\npublic static final String /*@Regex*/\nlineSep = System.getProperty(\"line.separator\");"
            ],
            [
                "minversion",
                "plume",
                "ClassFileVersion",
                "/**\n * Only report versions that are at least this large.\n */\nstatic double minversion = 0;"
            ],
            [
                "debug",
                "plume",
                "DeclarationAnnotations",
                "static boolean debug = false;"
            ],
            [
                "date",
                "plume",
                "ICalAvailable",
                "/// User options\n@Option(\"first date to summarize\")\npublic static String date = \"today\";"
            ],
            [
                "start_date",
                "plume",
                "ICalAvailable",
                "public static DateTime start_date = new DateTime();"
            ],
            [
                "days",
                "plume",
                "ICalAvailable",
                "@Option(\"number of calendar days to summarize\")\npublic static int days = 8;"
            ],
            [
                "iCal_URL",
                "plume",
                "ICalAvailable",
                "/**\n * For a Google calendar:  go to settings, then click on the green \"ICAL\"\n * icon for the \"private address\".\n */\n@Option(\"<url> schedule in iCal format\")\npublic static List<String> iCal_URL = new ArrayList<String>();"
            ],
            [
                "business_hours",
                "plume",
                "ICalAvailable",
                "/**\n * A list of time ranges, expressed as a String.\n * Example: 9am-5pm,7:30pm-9:30pm\n */\n@Option(\"time ranges during which appointments are permitted\")\npublic static String business_hours = \"9am-5pm\";"
            ],
            [
                "businessHours",
                "plume",
                "ICalAvailable",
                "// initialize to 9am-5pm\nstatic List<Period> businessHours = new ArrayList<Period>();"
            ],
            [
                "businessDays",
                "plume",
                "ICalAvailable",
                "// initialize to Mon-Fri\nstatic List<Integer> businessDays = new ArrayList<Integer>();"
            ],
            [
                "tzRegistry",
                "plume",
                "ICalAvailable",
                "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();"
            ],
            [
                "timezone1",
                "plume",
                "ICalAvailable",
                "/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * Available times are printed in this time zone.  It defaults to the\n * system time zone.\n */\n// don't need \"e.g.: America/New_York\" in message:  the default is an example\n@Option(value = \"<timezone> time zone, e.g.: America/New_York\", noDocDefault = true)\npublic static String timezone1 = TimeZone.getDefault().getID();"
            ],
            [
                "tz1",
                "plume",
                "ICalAvailable",
                "// Either of these initializations causes a NullPointerException\n// at net.fortuna.ical4j.model.TimeZone.<init>(TimeZone.java:67)\n// static TimeZone tz1 = new TimeZone(new VTimeZone());\n// static TimeZone tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));\nstatic TimeZone /*@MonotonicNonNull*/\ntz1;"
            ],
            [
                "timezone2",
                "plume",
                "ICalAvailable",
                "// If I'm outputting in a different timezone, then my notion of a \"day\"\n// may be different than the other timezone's notion of a \"day\".  This\n// doesn't seem important enough to fix right now.\n/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * If set, then free times are printed in two time zones.\n */\n@Option(\"<timezone> optional second time zone, e.g.: America/New_York\")\npublic static String /*@Nullable*/\ntimezone2;"
            ],
            [
                "tz2",
                "plume",
                "ICalAvailable",
                "static TimeZone /*@Nullable*/\ntz2;"
            ],
            [
                "debug",
                "plume",
                "ICalAvailable",
                "/// Other variables\n@Option(\"enable debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "calendars",
                "plume",
                "ICalAvailable",
                "/**\n * The appointments (the times that are unavailable for a meeting).\n */\nstatic List<Calendar> calendars = new ArrayList<Calendar>();"
            ],
            [
                "tf",
                "plume",
                "ICalAvailable",
                "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);"
            ],
            [
                "df",
                "plume",
                "ICalAvailable",
                "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);"
            ],
            [
                "dffull",
                "plume",
                "ICalAvailable",
                "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);"
            ],
            [
                "canonicalTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> canonicalTimezones = new HashMap<String, String>();"
            ],
            [
                "printedTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> printedTimezones = new HashMap<String, String>();"
            ],
            [
                "timeRegexp",
                "plume",
                "ICalAvailable",
                "static Pattern /*@Regex(4)*/\ntimeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");"
            ],
            [
                "dateFormats",
                "plume",
                "ICalAvailable",
                "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};"
            ],
            [
                "skip_checks",
                "plume",
                "BCELUtil",
                "/**\n * Controls whether the checks in checkMgen are actually performed.\n */\npublic static boolean skip_checks = false;"
            ],
            [
                "userHome",
                "plume",
                "UtilMDE",
                "static final String userHome = System.getProperty(\"user.home\");"
            ],
            [
                "args_seen",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Method\n///\n/**\n * Maps from a comma-delimited string of arg types, such as appears in a\n * method signature, to an array of Class objects, one for each arg\n * type. Example keys include: \"java.lang.String, java.lang.String,\n * java.lang.Class[]\" and \"int,int\".\n */\nstatic HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();"
            ],
            [
                "serialVersionUID",
                "plume",
                "UtilMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "NullableStringComparator",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeIntSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "split_lists",
                "plume",
                "Options",
                "/**\n * When true, an argument to a option of list type is split, on\n * whitespace, into multiple arguments each of which is added to the\n * list.  When false, each argument to an option of list type is treated\n * as a single element, no matter what characters it contains.\n */\n@Option(\"Treat arguments to lists as space-separated.\")\npublic static boolean split_lists = false;"
            ],
            [
                "serialVersionUID",
                "plume",
                "Options",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArgException",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "StringArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "short_run",
                "plume",
                "TestPlume",
                "// If true, do 100 instead of 100000 iterations when testing randomElements.\n// This saves only a little time.  However, it is significant when running\n// under instrumentation such as that of Chicory.\nstatic boolean short_run = false;"
            ],
            [
                "mass",
                "plume",
                "TestPlume",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestPlume",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestPlume",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "mass",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestOptionGroups1",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups2",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups3",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "FuzzyFloat",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "x",
                "",
                "int"
            ],
            [
                "y",
                "",
                "int"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 10048,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "plume-lib-1.1.0",
        "packageName": "plume",
        "className": "MathMDE",
        "javadocTag": "@param x first operand",
        "methodJavadoc": "    /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */",
        "methodSourceCode": "public static long logicalOr(long x, long y){\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}",
        "classJavadoc": "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
        "classSourceCode": "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "FileIOException",
                "plume"
            ],
            [
                "MathMDE",
                "plume"
            ],
            [
                "DeterministicObject",
                "plume"
            ],
            [
                "Digest",
                "plume"
            ],
            [
                "StringBuilderDelimited",
                "plume"
            ],
            [
                "OrderedPairIterator",
                "plume"
            ],
            [
                "CountingPrintWriter",
                "plume"
            ],
            [
                "MultiVersionControl",
                "plume"
            ],
            [
                "WeakIdentityHashMap",
                "plume"
            ],
            [
                "IterableIterator",
                "plume"
            ],
            [
                "Lookup",
                "plume"
            ],
            [
                "Pair",
                "plume"
            ],
            [
                "FileCompiler",
                "plume"
            ],
            [
                "MultiRandSelector",
                "plume"
            ],
            [
                "RandoopMappedCalls",
                "plume"
            ],
            [
                "Stopwatch",
                "plume"
            ],
            [
                "TaskManager",
                "plume"
            ],
            [
                "WeakHasherMap",
                "plume"
            ],
            [
                "ClassFileVersion",
                "plume"
            ],
            [
                "WeakIdentityPair",
                "plume"
            ],
            [
                "OptionsDoclet",
                "plume"
            ],
            [
                "DeclarationAnnotations",
                "plume"
            ],
            [
                "Option",
                "plume"
            ],
            [
                "RegexUtil",
                "plume"
            ],
            [
                "JWhich",
                "plume"
            ],
            [
                "TimeLimitProcess",
                "plume"
            ],
            [
                "Intern",
                "plume"
            ],
            [
                "GraphMDE",
                "plume"
            ],
            [
                "HtmlPrettyPrint",
                "plume"
            ],
            [
                "SimpleLog",
                "plume"
            ],
            [
                "OptionGroup",
                "plume"
            ],
            [
                "ICalAvailable",
                "plume"
            ],
            [
                "RandomSelector",
                "plume"
            ],
            [
                "BCELUtil",
                "plume"
            ],
            [
                "UtilMDE",
                "plume"
            ],
            [
                "Hasher",
                "plume"
            ],
            [
                "BibtexClean",
                "plume"
            ],
            [
                "LimitedSizeIntSet",
                "plume"
            ],
            [
                "Partitioner",
                "plume"
            ],
            [
                "Triple",
                "plume"
            ],
            [
                "Options",
                "plume"
            ],
            [
                "ArraysMDE",
                "plume"
            ],
            [
                "StrTok",
                "plume"
            ],
            [
                "Unpublicized",
                "plume"
            ],
            [
                "TestPlume",
                "plume"
            ],
            [
                "LimitedSizeSet",
                "plume"
            ],
            [
                "EntryReader",
                "plume"
            ],
            [
                "Filter",
                "plume"
            ],
            [
                "FuzzyFloat",
                "plume"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "negate",
                "plume",
                "MathMDE",
                "///\n/// Function versions of Java operators\n///\n/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static int negate(int a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static long negate(long a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static double negate(double a) {\n    return -a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static int bitwiseComplement(int a) {\n    return ~a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static long bitwiseComplement(long a) {\n    return ~a;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static int mul(int x, int y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static long mul(long x, long y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static double mul(double x, double y) {\n    return x * y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static int div(int x, int y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static long div(long x, long y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static double div(double x, double y) {\n    return x / y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static int mod(int x, int y) {\n    return x % y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static long mod(long x, long y) {\n    return x % y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static int lshift(int x, int y) {\n    return x << y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static long lshift(long x, long y) {\n    return x << y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static int rshiftSigned(int x, int y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static long rshiftSigned(long x, long y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static int bitwiseAnd(int x, int y) {\n    return x & y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static long bitwiseAnd(long x, long y) {\n    return x & y;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static int logicalAnd(int x, int y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static long logicalAnd(long x, long y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static int bitwiseXor(int x, int y) {\n    return x ^ y;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static long bitwiseXor(long x, long y) {\n    return x ^ y;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static int logicalXor(int x, int y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static long logicalXor(long x, long y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static int bitwiseOr(int x, int y) {\n    return x | y;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static long bitwiseOr(long x, long y) {\n    return x | y;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static int logicalOr(int x, int y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static long logicalOr(long x, long y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "sign",
                "plume",
                "MathMDE",
                "///\n/// sign\n///\n/**\n * Returns the sign of its argument.  The result is always -1, 0, or 1.\n * @param a value to have its sign taken\n * @return the sign of a: -1, 0, or 1\n */\npublic static int sign(int a) {\n    if (a == 0) {\n        return 0;\n    } else if (a > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "///\n/// exponentiation\n///\n/**\n * Returns of value of the first argument raised to the\n * power of the second argument.  The arguments are integers.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "/**\n * Returns of value of the first argument raised to the\n * power of the second argument.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "///\n/// gcd\n///\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static int gcd(int a, int b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        int tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/// gcd -- version for manipulating long (rather than int) values\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static long gcd(long a, long b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static double gcd(double a, double b) {\n    if (a == Double.POSITIVE_INFINITY || a == Double.NEGATIVE_INFINITY || Double.isNaN(a) || b == Double.POSITIVE_INFINITY || b == Double.NEGATIVE_INFINITY || Double.isNaN(b)) {\n        return Double.NaN;\n    }\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        double tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "///\n/// Modulus\n///\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nint mod_positive(int x, /*@PolyUpperBound*/\nint y) {\n    int result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static int[] modulus(int[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new int[] { remainder, modulus };\n}"
            ],
            [
                "modulus_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(int[])\n */\npublic static int[] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static int[] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    int modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(int[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().intValue();\n    }\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().intValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "/// modulus for long (as opposed to int) values\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nlong mod_positive(long x, /*@PolyUpperBound*/\nlong y) {\n    long result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static long[] modulus(long[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new long[] { remainder, modulus };\n}"
            ],
            [
                "modulus_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(long[])\n */\npublic static long[] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        long i = itor.next().longValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static long[] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    long modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(long[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().longValue();\n    }\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().longValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "///\n/// Non-Modulus\n///\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] missing_numbers(int[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length - 1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static int[] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   int range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2);\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = mod_positive(nums[i], m);\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new int[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "/// non-modulus for long (as opposed to int) values\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] missing_numbers(long[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length - 1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static long[] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   long range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2)));\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = ((int) (mod_positive(nums[i], m)));\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new long[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "getFileDigest",
                "plume",
                "Digest",
                "/**\n * This convenience method is used by both create() and verify().  It\n * reads the contents of a named file and computes a message digest\n * for it, using the specified MessageDigest object.\n * @param filename the file to read\n * @param md the MessageDigest\n * @return the message digest\n * @throws IOException if there is a problem reading the file\n */\npublic static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    // Read to the end of the file, discarding everything we read. {\n    // The DigestInputStream automatically passes all the bytes read to\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) {\n        /* do nothing */\n    }\n    // Finally, compute and return the digest value.\n    byte[] result = md.digest();\n    in.close();\n    return result;\n}"
            ],
            [
                "hexEncode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert an array of bytes to a String.  We do\n * this simply by converting each byte to two hexadecimal digits.  Something\n * like Base 64 encoding is more compact, but harder to encode.\n * @param bytes the bytes to convert to a String\n * @return a String representation of the input bytes\n */\npublic static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}"
            ],
            [
                "hexDecode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert from a string\n * of hexadecimal digits to an array of bytes.\n * This method is the reverse of {@link #hexEncode(byte[])}.\n * @param s the String to convert to an array of bytes\n * @return the bytes equivalent to the input String\n */\npublic static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9')) {\n                digit1 -= '0';\n            } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n                digit1 -= 'a' - 10;\n            }\n            if ((digit2 >= '0') && (digit2 <= '9')) {\n                digit2 -= '0';\n            } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n                digit2 -= 'a' - 10;\n            }\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}"
            ],
            [
                "dirToCheckoutHg",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".hg\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutHg(File hgDir, File dir) {\n    String repository = null;\n    File hgrcFile = new File(hgDir, \"hgrc\");\n    Ini ini;\n    // There also exist Hg commands that will do this same thing.\n    if (hgrcFile.exists()) {\n        try {\n            ini = new Ini(new FileReader(hgrcFile));\n        } catch (IOException e) {\n            throw new Error(\"Problem reading file \" + hgrcFile);\n        }\n        Ini.Section pathsSection = ini.get(\"paths\");\n        if (pathsSection != null) {\n            repository = pathsSection.get(\"default\");\n            if (repository != null && repository.endsWith(\"/\")) {\n                repository = repository.substring(0, repository.length() - 1);\n            }\n        }\n    }\n    return new Checkout(RepoType.HG, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutGit",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".git\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutGit(File gitDir, File dir) {\n    String repository = UtilMDE.backticks(\"git\", \"config\", \"remote.origin.url\");\n    return new Checkout(RepoType.GIT, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutSvn",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory that contains a .svn subdirectory, create a\n * corresponding Checkout object.\n * Returns null if this is not possible.\n */\nstatic /*@Nullable*/\nCheckout dirToCheckoutSvn(File dir) {\n    // For SVN, do\n    //   svn info\n    // and grep out these lines:\n    //   URL: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository/trunk/www\n    //   Repository Root: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository\n    // Use SVNKit?\n    // Con: introduces dependency on external library.\n    // Pro: no need to re-implement or to call external process (which\n    //   might be slow for large checkouts).\n    // unannotated library: SVNKit\n    @SuppressWarnings(\"nullness\")\n    SVNWCClient wcClient = new SVNWCClient((/*@Nullable*/\n    ISVNAuthenticationManager) null, null);\n    SVNInfo info;\n    try {\n        info = wcClient.doInfo(new File(dir.toString()), SVNRevision.WORKING);\n    } catch (SVNException e) {\n        // throw new Error(\"Problem in dirToCheckoutSvn(\" + dir + \"): \", e);\n        System.err.println(\"Problem in dirToCheckoutSvn(\" + dir + \"): \" + e.getMessage());\n        if (e.getMessage() != null && e.getMessage().contains(\"This client is too old\")) {\n            System.err.println(\"plume-lib needs a newer version of SVNKit.\");\n        }\n        return null;\n    }\n    // getFile is null when operating on a working copy, as I am\n    // String relativeFile = info.getPath(); // relative to repository root -- can use to determine root of checkout\n    // getFile is just the (absolute) local file name for local items -- same as \"dir\"\n    // File relativeFile = info.getFile();\n    SVNURL url = info.getURL();\n    // This can be null (example: dir /afs/csail.mit.edu/u/m/mernst/.snapshot/class/6170/2006-spring/3dphysics).  I don't know under what circumstances.\n    SVNURL repoRoot = info.getRepositoryRootURL();\n    if (repoRoot == null) {\n        System.err.println(\"Problem:  old svn working copy in \" + dir.toString());\n        System.err.println(\"Check it out again to get a 'Repository Root' entry in the svn info output.\");\n        System.err.println(\"  repoUrl = \" + url);\n        System.exit(2);\n    }\n    if (debug) {\n        System.out.println();\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"     dir = \" + dir.toString());\n    }\n    // Strip common suffix off of local dir and repo url.\n    Pair<File, File> /*@Nullable*/\n    /*@Nullable*/\n    stripped = removeCommonSuffixDirs(dir, new File(url.getPath()), new File(repoRoot.getPath()), \".svn\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n        System.out.printf(\"dir (%s) is parent of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    if (stripped.b == null) {\n        System.out.printf(\"dir (%s) is child of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    String pathInRepoAtCheckout = stripped.b.toString();\n    try {\n        url = url.setPath(pathInRepoAtCheckout, false);\n    } catch (SVNException e) {\n        throw new Error(e);\n    }\n    if (debug) {\n        System.out.println(\"stripped: \" + stripped);\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"    cDir = \" + cDir.toString());\n    }\n    assert url.toString().startsWith(repoRoot.toString()) : \"repoRoot=\" + repoRoot + \", url=\" + url;\n    return new Checkout(RepoType.SVN, cDir, url.toString(), null);\n    /// Old implementation\n    // String module = url.toString().substring(repoRoot.toString().length());\n    // if (module.startsWith(\"/\")) {\n    //   module = module.substring(1);\n    // }\n    // if (module.equals(\"\")) {\n    //   module = null;\n    // }\n    // return new Checkout(RepoType.SVN, cDir, repoRoot.toString(), module);\n}"
            ],
            [
                "removeCommonSuffixDirs",
                "plume",
                "MultiVersionControl",
                "/**\n * Strip identical elements off the end of both paths, and then return\n * what is left of each.  Returned elements can be null!  If p2_limit is\n * non-null, then it should be a parent of p2, and the stripping stops\n * when p2 becomes p2_limit.  If p1_contains is non-null, then p1 must\n * contain a subdirectory of that name.\n */\nstatic Pair</*@Nullable*/\nFile, /*@Nullable*/\nFile> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains) {\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\", p1, p2, p2_limit, p1_contains);\n    }\n    // new names for results, because we will be side-effecting them\n    File r1 = p1;\n    File r2 = p2;\n    while (r1 != null && r2 != null && (p2_limit == null || !r2.equals(p2_limit)) && r1.getName().equals(r2.getName())) {\n        if (p1_contains != null && !new File(r1.getParentFile(), p1_contains).isDirectory()) {\n            break;\n        }\n        r1 = r1.getParentFile();\n        r2 = r2.getParentFile();\n    }\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs => %s %s%n\", r1, r2);\n    }\n    return Pair.of(r1, r2);\n}"
            ],
            [
                "eq",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Check for equality of non-null reference x and possibly-null y.  Uses\n * identity equality.\n */\n/*@Pure*/\nstatic boolean eq(Object x, /*@Nullable*/\nObject y) {\n    return x == y;\n}"
            ],
            [
                "hasher",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return the hash code for x\n */\n/*@Pure*/\nstatic int hasher(Object x) {\n    return System.identityHashCode(x);\n}"
            ],
            [
                "indexFor",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return index for hash code h.\n */\n/*@Pure*/\nstatic int indexFor(int h, int length) {\n    return h & (length - 1);\n}"
            ],
            [
                "old_get_entry",
                "plume",
                "Lookup",
                "/**\n * Returns the next entry.  If no more entries are available, returns null.\n * @param reader where to read the entry from\n * @return the next entry, or null\n * @throws IOException if there is a problem reading a file\n */\npublic static /*@Nullable*/\nEntry old_get_entry(EntryReader reader) throws IOException {\n    try {\n        // Skip any preceeding blank lines\n        String line = reader.readLine();\n        while ((line != null) && (line.trim().length() == 0)) {\n            line = reader.readLine();\n        }\n        if (line == null) {\n            return (null);\n        }\n        Entry entry = null;\n        String filename = reader.getFileName();\n        long line_number = reader.getLineNumber();\n        // If this is a long entry\n        if (line.startsWith(\">entry\")) {\n            // Get the current filename\n            String current_filename = reader.getFileName();\n            // Remove '>entry' from the line\n            line = line.replaceFirst(\"^>entry *\", \"\");\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find the termination of the entry\n            while ((line != null) && !line.startsWith(\">entry\") && !line.equals(\"<entry\") && current_filename.equals(reader.getFileName())) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            // If this entry was terminated by the start of the next one,\n            // put that line back\n            if ((line != null) && (line.startsWith(\">entry\") || !current_filename.equals(reader.getFileName()))) {\n                reader.putback(line);\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, false);\n        } else {\n            // blank separated entry\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find another blank line\n            while ((line != null) && (line.trim().length() != 0)) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, true);\n        }\n        return (entry);\n    } catch (FileNotFoundException e) {\n        System.out.printf(\"Error: Can't read %s at line %d in file %s%n\", e.getMessage(), reader.getLineNumber(), reader.getFileName());\n        System.exit(254);\n        return (null);\n    }\n}"
            ],
            [
                "first_line",
                "plume",
                "Lookup",
                "/**\n * Returns the first line of entry.\n * @param entry the entry whose first line to return\n * @return the first line of entry\n */\npublic static String first_line(String entry) {\n    int ii = entry.indexOf(lineSep);\n    if (ii == -1) {\n        return entry;\n    }\n    return entry.substring(0, ii);\n}"
            ],
            [
                "of",
                "plume",
                "Pair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a pair of the values (a, b)\n */\npublic static <A extends /*@Nullable*/\nObject, B extends /*@Nullable*/\nObject> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "short_str",
                "plume",
                "TaskManager",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "short_str",
                "plume",
                "Task",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "versionNumbers",
                "plume",
                "ClassFileVersion",
                "/**\n * Return an array of the major vernios, minor version, and JDK version\n * of the class read from the input stream.\n * Return null if there is an error or the input isn't a class file.\n * @param is input stream from which to read a class\n * @return array of three version numbers\n */\npublic static double[] versionNumbers(InputStream is) {\n    try {\n        DataInputStream dis = new DataInputStream(is);\n        int magic = dis.readInt();\n        if (magic != 0xcafebabe) {\n            return null;\n        }\n        double minor = dis.readShort();\n        double major = dis.readShort();\n        double jdkVersion;\n        if (major < 48) {\n            // really 1.3.1\n            jdkVersion = 1.3;\n        } else if (major == 48) {\n            // really 1.4.2\n            jdkVersion = 1.4;\n        } else if (major == 49) {\n            jdkVersion = 1.5;\n        } else if (major == 50) {\n            jdkVersion = 6;\n        } else {\n            jdkVersion = 7;\n        }\n        return new double[] { major, minor, jdkVersion };\n    } catch (IOException e) {\n        return null;\n    }\n}"
            ],
            [
                "of",
                "plume",
                "WeakIdentityPair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a WeakIdentityPair of (a, b)\n */\npublic static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b) {\n    return new WeakIdentityPair<A, B>(a, b);\n}"
            ],
            [
                "start",
                "plume",
                "OptionsDoclet",
                "// Doclet-specific methods\n/**\n * Entry point for the doclet.\n * @param root the root document\n * @return true if processing completed without an error\n */\npublic static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n        // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n        // returns a fully qualified name.  I do not know a good way to convert\n        // between these two name formats.  For now, we simply ignore inner\n        // classes.  This limitation can be removed when we figure out a better\n        // way to go from ClassDoc to Class<?>.\n        if (doc.containingClass() != null) {\n            continue;\n        }\n        Class<?> clazz;\n        try {\n            // Javadoc source code is not yet annotated\n            @SuppressWarnings(\"signature\")\n            String /*@BinaryNameForNonArray*/\n            className = doc.qualifiedName();\n            clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        }\n        if (needsInstantiation(clazz)) {\n            try {\n                Constructor<?> c = clazz.getDeclaredConstructor();\n                c.setAccessible(true);\n                objs.add(c.newInstance(new Object[0]));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            objs.add(clazz);\n        }\n    }\n    if (objs.isEmpty()) {\n        System.out.println(\"Error: no classes found\");\n        return false;\n    }\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n        System.out.println(\"Error: no @Option-annotated fields found\");\n        return false;\n    }\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n        o.write();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "optionLength",
                "plume",
                "OptionsDoclet",
                "/**\n * Given a command-line option of this doclet, returns the number of\n * arguments you must specify on the command line for the given option.\n * Returns 0 if the argument is not recognized.  This method is\n * automatically invoked.\n *\n * @param option the command-line option\n * @return the number of command-line arguments needed when using the option\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n        System.out.printf(USAGE);\n        return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n        return 1;\n    }\n    if (option.equals(\"-docfile\") || option.equals(\"-outfile\") || option.equals(\"-format\") || option.equals(\"-d\")) {\n        return 2;\n    }\n    return 0;\n}"
            ],
            [
                "validOptions",
                "plume",
                "OptionsDoclet",
                "/**\n * Tests the validity of command-line arguments passed to this doclet.\n * Returns true if the option usage is valid, and false otherwise.  This\n * method is automatically invoked.\n *\n * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n * @param reporter where to report errors\n * @return true iff the command-line options are valid\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            if (hasDocFile) {\n                reporter.printError(\"-docfile option specified twice\");\n                return false;\n            }\n            File f = new File(os[1]);\n            if (!f.exists()) {\n                reporter.printError(\"-docfile file not found: \" + os[1]);\n                return false;\n            }\n            docFile = os[1];\n            hasDocFile = true;\n        }\n        if (opt.equals(\"-outfile\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-outfile option specified twice\");\n                return false;\n            }\n            if (inPlace) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            outFile = os[1];\n            hasOutFile = true;\n        }\n        if (opt.equals(\"-i\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            inPlace = true;\n        }\n        if (opt.equals(\"-format\")) {\n            if (hasFormat) {\n                reporter.printError(\"-format option specified twice\");\n                return false;\n            }\n            if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n                reporter.printError(\"unrecognized output format: \" + os[1]);\n                return false;\n            }\n            hasFormat = true;\n        }\n        if (opt.equals(\"-d\")) {\n            if (hasDestDir) {\n                reporter.printError(\"-d specified twice\");\n                return false;\n            }\n            hasDestDir = true;\n        }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n        reporter.printError(\"docfile must be different from outfile\");\n        return false;\n    }\n    if (inPlace && docFile == null) {\n        reporter.printError(\"-i supplied but -docfile was not\");\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "javadocToHtml",
                "plume",
                "OptionsDoclet",
                "/**\n * Replace the @link tags and block @see tags in a Javadoc comment with\n * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n * comment while still being presentable. <p>\n *\n * This is only a temporary solution.  Ideally, @link/@see tags would be\n * converted to HTML links that point to actual documentation.\n *\n * @param doc a Javadoc comment to convert to HTML\n * @return HTML version of doc\n */\npublic static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n        if (tag instanceof SeeTag) {\n            b.append(\"<code>\" + tag.text() + \"</code>\");\n        } else {\n            b.append(tag.text());\n        }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n        b.append(\" See: \");\n        {\n            StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n            for (SeeTag tag : seetags) {\n                bb.append(\"<code>\" + tag.text() + \"</code>\");\n            }\n            b.append(bb);\n        }\n        b.append(\".\");\n    }\n    return b.toString();\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param s string to check for being a regular expression\n * @return true iff s is a regular expression\n */\n/*@Pure*/\n/*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\npublic static boolean isRegex(String s) {\n    return isRegex(s, 0);\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression with at least the given number of groups.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return true iff s is a regular expression with groups groups\n */\n// RegexUtil; for purity, catches an exception\n@SuppressWarnings({ \"regex\", \"deterministic\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(String s, int groups) {\n    Pattern p;\n    try {\n        p = Pattern.compile(s);\n    } catch (PatternSyntaxException e) {\n        return false;\n    }\n    return getGroupCount(p) >= groups;\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param c char to check for being a regular expression\n * @return true iff c is a regular expression\n */\n@SuppressWarnings({ \"regex\", \"purity.not.deterministic.call\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(char c) {\n    return isRegex(Character.toString(c));\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a string describing why the argument is\n * not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nString regexError(String s) {\n    return regexError(s, 0);\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns\n * a string describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil;\n@SuppressWarnings({ \"regex\", \"not.sef\" })\npublic static /*@Nullable*/\nString regexError(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return regexErrorMessage(s, groups, actualGroups);\n        }\n    } catch (PatternSyntaxException e) {\n        return e.getMessage();\n    }\n    return null;\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a PatternSyntaxException describing\n * why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s) {\n    return regexException(s, 0);\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns a\n * PatternSyntaxException describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return new PatternSyntaxException(regexErrorMessage(s, groups, actualGroups), s, -1);\n        }\n    } catch (PatternSyntaxException pse) {\n        return pse;\n    }\n    return null;\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex String} if it is a regex,\n * otherwise throws an error. The purpose of this method is to suppress Regex\n * Checker warnings. It should be very rarely needed.\n * @param s string to check for being a regular expression\n * @return its argument\n * @throws Error if argument is not a regex\n */\n/*@SideEffectFree*/\n// The return type annotation is a conservative bound.\npublic static /*@Regex*/\nString asRegex(String s) {\n    return asRegex(s, 0);\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex(groups) String} if it is a regex\n * with at least the given number of groups, otherwise throws an error. The\n * purpose of this method is to suppress Regex Checker warnings. It should\n * be very rarely needed.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return its argument\n * @throws Error if argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Regex*/\nString asRegex(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            throw new Error(regexErrorMessage(s, groups, actualGroups));\n        }\n        return s;\n    } catch (PatternSyntaxException e) {\n        throw new Error(e);\n    }\n}"
            ],
            [
                "findClass",
                "plume",
                "JWhich",
                "/**\n * Returns the URL of the resource denoted by the specified\n * class name, as prescribed by the class path.\n *\n * @param className name of the class\n * @return class URL, or null of the class was not found\n */\npublic static /*@Nullable*/\nURL findClass(final String className) {\n    return JWhich.class.getResource(asResourceName(className));\n}"
            ],
            [
                "asResourceName",
                "plume",
                "JWhich",
                "protected static String asResourceName(String resource) {\n    if (!resource.startsWith(\"/\")) {\n        resource = \"/\" + resource;\n    }\n    resource = resource.replace('.', '/');\n    resource = resource + \".class\";\n    return resource;\n}"
            ],
            [
                "getClasspath",
                "plume",
                "JWhich",
                "/**\n * Return the classpath.\n * @return the classpath\n */\n/*@EnsuresNonNull(\"CLASSPATH\")*/\nprotected static String getClasspath() {\n    if (CLASSPATH == null) {\n        String classpath = System.getProperty(\"java.class.path\");\n        setClasspath(classpath);\n    }\n    return CLASSPATH;\n}"
            ],
            [
                "internStrings",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Strings\n///\n/**\n * Replace each element of the array by its interned version.\n * Side-effects the array, but also returns it.\n * @param a the array whose elements to intern in place\n * @return an interned version of a\n * @see String#intern\n */\n// side-effects the array in place (dangerous, but convenient)\n@SuppressWarnings(\"interning\")\npublic static String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] != null) {\n            a[i] = a[i].intern();\n        }\n    }\n    return a;\n}"
            ],
            [
                "isInterned",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Testing interning\n///\n/**\n * Return true if the argument is interned (is canonical among all\n * objects equal to itself).\n * @param value the value to test for interning\n * @return true iff value is interned\n */\n// interning implementation\n@SuppressWarnings(\"interning\")\npublic static /*@Pure*/\nboolean isInterned(/*@Nullable*/\nObject value) {\n    if (value == null) {\n        // nothing to do\n        return true;\n    } else if (value instanceof String) {\n        return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n        return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n        return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n        return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n        return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n        return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n        return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n        return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n        return (value == intern((Object[]) value));\n    } else {\n        // Nothing to do, because we don't intern other types.\n        // System.out.println(\"What type? \" + value.getClass().getName());\n        return true;\n    }\n}"
            ],
            [
                "numIntegers",
                "plume",
                "Intern",
                "// For testing only\npublic static int numIntegers() {\n    return internedIntegers.size();\n}"
            ],
            [
                "numLongs",
                "plume",
                "Intern",
                "public static int numLongs() {\n    return internedLongs.size();\n}"
            ],
            [
                "numIntArrays",
                "plume",
                "Intern",
                "public static int numIntArrays() {\n    return internedIntArrays.size();\n}"
            ],
            [
                "numLongArrays",
                "plume",
                "Intern",
                "public static int numLongArrays() {\n    return internedLongArrays.size();\n}"
            ],
            [
                "numDoubles",
                "plume",
                "Intern",
                "public static int numDoubles() {\n    return internedDoubles.size();\n}"
            ],
            [
                "numDoubleArrays",
                "plume",
                "Intern",
                "public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n}"
            ],
            [
                "numStringArrays",
                "plume",
                "Intern",
                "public static int numStringArrays() {\n    return internedStringArrays.size();\n}"
            ],
            [
                "numObjectArrays",
                "plume",
                "Intern",
                "public static int numObjectArrays() {\n    return internedObjectArrays.size();\n}"
            ],
            [
                "integers",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nInteger> integers() {\n    return internedIntegers.keySet().iterator();\n}"
            ],
            [
                "longs",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nLong> longs() {\n    return internedLongs.keySet().iterator();\n}"
            ],
            [
                "intArrays",
                "plume",
                "Intern",
                "public static Iterator<int[]> intArrays() {\n    return internedIntArrays.keySet().iterator();\n}"
            ],
            [
                "longArrays",
                "plume",
                "Intern",
                "public static Iterator<long[]> longArrays() {\n    return internedLongArrays.keySet().iterator();\n}"
            ],
            [
                "doubles",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nDouble> doubles() {\n    return internedDoubles.keySet().iterator();\n}"
            ],
            [
                "doubleArrays",
                "plume",
                "Intern",
                "public static Iterator<double[]> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n}"
            ],
            [
                "stringArrays",
                "plume",
                "Intern",
                "public static Iterator<String[]> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n}"
            ],
            [
                "objectArrays",
                "plume",
                "Intern",
                "public static Iterator<Object[]> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a String.\n * Delegates to the builtin String.intern() method.\n * Provided for completeness.\n * @param a the string to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static /*@Interned*/\n/*@PolyNull*/\nString intern(/*@PolyNull*/\nString a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n        return null;\n    }\n    return a.intern();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a long.\n * A no-op.  Provided for completeness.\n * @param l the long to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static long intern(long l) {\n    return l;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a double\n * A no-op.  Provided for completeness.\n * @param d the double to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static double intern(double d) {\n    return d;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Integer.\n * Return a canonical representation for the Integer.\n * @param a an Integer to canonicalize\n * @return a canonical representation for the Integer\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Intern.valueOf is intended to promise\n// the same).  This does not currently take advantage of that.\n// interning implementation\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nInteger intern(Integer a) {\n    WeakReference<Integer> /*@Interned*/\n    lookup = internedIntegers.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Integer /*@Interned*/\n        result = (/*@Interned*/\n        Integer) a;\n        internedIntegers.put(result, new WeakReference</*@Interned*/\n        Integer>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nInteger internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value parsed from the string.\n * @param s the string to parse\n * @return an interned Integer parsed from s\n */\npublic static /*@Interned*/\nInteger internedInteger(String s) {\n    return intern(Integer.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Long.\n * Return a canonical representation for the Long.\n * @param a the value to intern\n * @return a canonical representation for the Long\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Long.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nLong intern(Long a) {\n    WeakReference<Long> /*@Interned*/\n    lookup = internedLongs.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Long /*@Interned*/\n        result = (/*@Interned*/\n        Long) a;\n        internedLongs.put(result, new WeakReference</*@Interned*/\n        Long>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nLong internedLong(long i) {\n    return intern(Long.valueOf(i));\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value parsed from the string.\n * @param s the string to parse\n * @return an interned Long parsed from s\n */\npublic static /*@Interned*/\nLong internedLong(String s) {\n    return intern(Long.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) an int[].\n * Return a canonical representation for the int[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the int[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static int[] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        int[] /*@Interned*/\n        result = (int[]) a;\n        internedIntArrays.put(result, new WeakReference<int[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a long[].\n * Return a canonical representation for the long[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the long[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static long[] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        long[] /*@Interned*/\n        result = (long[]) a;\n        internedLongArrays.put(result, new WeakReference<long[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Double.\n * Return a canonical representation for the Double.\n * @param a the Double to canonicalize\n * @return a canonical representation for the Double\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Double.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nDouble intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n        return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) {\n        // catches both positive and negative zero\n        return internedDoubleZero;\n    }\n    WeakReference<Double> /*@Interned*/\n    lookup = internedDoubles.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Double /*@Interned*/\n        result = (/*@Interned*/\n        Double) a;\n        internedDoubles.put(result, new WeakReference</*@Interned*/\n        Double>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value i.\n * @param d the value to intern\n * @return an interned Double with value d\n */\npublic static /*@Interned*/\nDouble internedDouble(double d) {\n    return intern(Double.valueOf(d));\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value parsed from the string.\n * @param s the string to parse\n * @return an interned Double parsed from s\n */\npublic static /*@Interned*/\nDouble internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) a double[].\n * Return a canonical representation for the double[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the double[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static double[] intern(double[] a) {\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        double[] /*@Interned*/\n        result = (double[]) a;\n        internedDoubleArrays.put(result, new WeakReference<double[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an String[].\n * Return a canonical representation for the String[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the String[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static String[] intern(/*@PolyNull*/\n/*@Interned*/\nString[] a) {\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n        assert a[k] == Intern.intern(a[k]);\n    }\n    WeakReference<String[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    String[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (String[]) a;\n        internedStringArrays.put(result, new WeakReference<String[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    String[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Object[].\n * Return a canonical representation for the Object[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the Object[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static Object[] intern(/*@PolyNull*/\n/*@Interned*/\nObject[] a) {\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    WeakReference<Object[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    Object[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (Object[]) a;\n        internedObjectArrays.put(result, new WeakReference<Object[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    Object[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Convenince method to intern an Object when we don't know its\n * runtime type.  Its runtime type must be one of the types for\n * which we have an intern() method, else an exception is thrown.\n * If the argument is an array, its elements should themselves be\n * interned.\n * @param a an Object to canonicalize\n * @return a canonical version of a\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Interned*/\n/*@PolyNull*/\nObject intern(/*@PolyNull*/\nObject a) {\n    if (a == null) {\n        return null;\n    } else if (a instanceof String) {\n        return intern((String) a);\n    } else if (a instanceof String[]) {\n        @SuppressWarnings(\"interning\")\n        String[] /*@Interned*/\n        asArray = (String[]) a;\n        return intern(asArray);\n    } else if (a instanceof Integer) {\n        return intern((Integer) a);\n    } else if (a instanceof Long) {\n        return intern((Long) a);\n    } else if (a instanceof int[]) {\n        return intern((int[]) a);\n    } else if (a instanceof long[]) {\n        return intern((long[]) a);\n    } else if (a instanceof Double) {\n        return intern((Double) a);\n    } else if (a instanceof double[]) {\n        return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n        @SuppressWarnings(\"interning\")\n        Object[] /*@Interned*/\n        asArray = (Object[]) a;\n        return intern(asArray);\n    } else {\n        throw new IllegalArgumentException(\"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * Return the subsequence of seq from start (inclusive) to end\n * (exclusive) that is interned.  What's different about this method\n * from manually finding the subsequence and interning the\n * subsequence is that if the subsequence is already interned, we\n * can avoid having to compute the sequence.  Since derived\n * variables in Daikon compute the subsequence many times, this\n * shortcut saves quite a bit of computation.  It saves even more\n * when there may be many derived variables that are non-canonical,\n * since they are guaranteed to be ==.\n * <p>\n * Requires that seq is already interned.\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n */\npublic static int[] internSubsequence(int[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int[]> /*@Interned*/\n    sai = new SequenceAndIndices<int[]>(seq, start, end);\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n        int[] /*@Interned*/\n        subseq = Intern.intern(subseqUninterned);\n        internedIntSequenceAndIndices.put(sai, new WeakReference<int[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static long[] internSubsequence(long[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long[]> /*@Interned*/\n    sai = new SequenceAndIndices<long[]>(seq, start, end);\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        long[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedLongSequenceAndIndices.put(sai, new WeakReference<long[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static double[] internSubsequence(double[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double[]> /*@Interned*/\n    sai = new SequenceAndIndices<double[]>(seq, start, end);\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        double[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedDoubleSequenceAndIndices.put(sai, new WeakReference<double[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static Object[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nObject[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<Object[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedObjectSequenceAndIndices.put(sai, new WeakReference<Object[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static String[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nString[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<String[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedStringSequenceAndIndices.put(sai, new WeakReference<String[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "dominators",
                "plume",
                "GraphMDE",
                "// Algorithms for computing dominators:\n//\n// Wikipedia:\n//  // dominator of the start node is the start itself\n//  Dom(n_0) = {n_0}\n//  // for all other nodes, set all nodes as the dominators\n//  for each n in N - {n_0}\n//      Dom(n) = N;\n//  // iteratively eliminate nodes that are not dominators\n//  while changes in any Dom(n)\n//      for each n in N - {n_0}:\n//          Dom(n) = {n} union with intersection over all p in pred(n) of Dom(p)\n//\n// Cooper/Harvey/Kennedy:\n//  for all nodes, n\n//    DOM[n] := {1 . . .N}\n//  Changed := true\n//  while (Changed)\n//    Changed := false\n//    for all nodes, n, in reverse postorder\n//      new_set := (Intersect_{p:=preds(n)} DOM[p]) union {n}\n//      if (new_set != DOM[n])\n//        DOM[n] := new_set\n//        Changed := true\n// The two algorithms are essentially the same; this implementation\n// follows the Wikipedia one.\n/**\n * Computes, for each node in the graph, its set of (pre-)dominators.\n * Supply a successor graph if you want post-dominators.\n * @param <T> type of the graph nodes\n * @param predecessors a graph, represented as a predecessor map\n * @return a map from each node to a list of its pre-dominators\n */\npublic static <T> Map<T, List<T>> dominators(Map<T, List</*@KeyFor(\"#1\")*/\nT>> predecessors) {\n    // Map</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>> dom = new HashMap</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>>();\n    Map<T, List<T>> dom = new HashMap<T, List<T>>();\n    // every element of pred's value will be a key for dom\n    @SuppressWarnings(\"keyfor\")\n    Map<T, List<T>> /*@KeyFor({\"dom\"})*/\n    preds = predecessors;\n    List<T> nodes = new ArrayList<T>(preds.keySet());\n    // Compute roots & non-roots, for convenience\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    roots = new ArrayList<T>();\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    non_roots = new ArrayList<T>();\n    // Initialize result:  for roots just the root, otherwise everything\n    for (T node : preds.keySet()) {\n        if (preds.get(node).isEmpty()) {\n            // This is a root.  Its only dominator is itself.\n            Set<T> set = Collections.singleton(node);\n            dom.put(node, new ArrayList<T>(set));\n            roots.add(node);\n        } else {\n            // Initially, set all nodes as dominators;\n            // will later remove nodes that aren't dominators.\n            dom.put(node, new ArrayList<T>(nodes));\n            non_roots.add(node);\n        }\n    }\n    assert roots.size() + non_roots.size() == nodes.size();\n    // Invariants:\n    // preds and dom have the same keyset.\n    // All of the following are keys for both preds and dom:\n    //  * every key in pred\n    //  * elery element of every pred value\n    //  * every key in dom\n    //  * elery element of every dom value\n    // So, the type of pred is now\n    //\n    // rather than its original type\n    //   Map<T,List</*@KeyFor(\"preds\")*/ T>> preds\n    boolean changed = true;\n    while (changed) {\n        changed = false;\n        for (T node : non_roots) {\n            List<T> new_doms = null;\n            assert preds.containsKey(node);\n            for (T pred : preds.get(node)) {\n                assert dom.containsKey(pred);\n                /*@NonNull*/\n                List<T> dom_of_pred = dom.get(pred);\n                if (new_doms == null) {\n                    // make copy because we may side-effect new_doms\n                    new_doms = new ArrayList<T>(dom_of_pred);\n                } else {\n                    new_doms.retainAll(dom_of_pred);\n                }\n            }\n            assert new_doms != null : \"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\";\n            new_doms.add(node);\n            assert dom.containsKey(node);\n            if (!dom.get(node).equals(new_doms)) {\n                dom.put(node, new_doms);\n                changed = true;\n            }\n        }\n    }\n    for (T node : preds.keySet()) {\n        // TODO: The following two assert statements would be easier to read\n        // than the one combined one, but a bug (TODO:  Jonathan will add a\n        // bug number) prevents it from type-checking.\n        // assert dom.containsKey(node);\n        // assert dom.get(node).contains(node);\n        assert dom.containsKey(node) && dom.get(node).contains(node);\n    }\n    return dom;\n}"
            ],
            [
                "canonicalizeTimezone",
                "plume",
                "ICalAvailable",
                "static String canonicalizeTimezone(String timezone) {\n    String result = canonicalTimezones.get(timezone.toLowerCase());\n    return (result == null) ? timezone : result;\n}"
            ],
            [
                "printedTimezone",
                "plume",
                "ICalAvailable",
                "/*@Pure*/\nstatic String printedTimezone(TimeZone tz) {\n    String tzString = tz.getDisplayName();\n    String result = printedTimezones.get(tzString);\n    return (result == null) ? tzString : result;\n}"
            ],
            [
                "parseTime",
                "plume",
                "ICalAvailable",
                "// Parse a time like \"9:30pm\"\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nDateTime parseTime(String time) {\n    Matcher m = timeRegexp.matcher(time);\n    if (!m.matches()) {\n        System.err.println(\"Bad time: \" + time);\n        System.exit(1);\n    }\n    @SuppressWarnings(// Regex Checker imprecision:  matches() guarantees that group 1 exists in regexp\n    \"nullness\")\n    String /*@NonNull*/\n    hourString = m.group(1);\n    String minuteString = m.group(3);\n    String ampmString = m.group(4);\n    int hour = Integer.parseInt(hourString);\n    if ((ampmString != null) && ampmString.toLowerCase().equals(\"pm\")) {\n        hour += 12;\n    }\n    int minute = 0;\n    if (minuteString != null) {\n        minute = Integer.parseInt(minuteString);\n    }\n    DateTime result = new DateTime();\n    result.setTimeZone(tz1);\n    result.setHours(hour);\n    result.setMinutes(minute);\n    result.setSeconds(0);\n    return result;\n}"
            ],
            [
                "rangeString",
                "plume",
                "ICalAvailable",
                "static String rangeString(Period p, TimeZone tz) {\n    tf.setTimeZone(tz);\n    DateTime pstart = p.getStart();\n    DateTime pend = p.getEnd();\n    String rangeString = tf.format(pstart) + \" to \" + tf.format(pend);\n    rangeString = rangeString.replace(\" AM\", \"am\");\n    rangeString = rangeString.replace(\" PM\", \"pm\");\n    return rangeString;\n}"
            ],
            [
                "periodListString",
                "plume",
                "ICalAvailable",
                "static String periodListString(PeriodList pl, TimeZone tz) {\n    tf.setTimeZone(tz);\n    StringBuilder result = new StringBuilder();\n    // \"Object\" because PeriodList extends TreeSet, but it really ought to\n    // extend TreeSet</*@NonNull*/ Period>\n    for (Object p : pl) {\n        assert p != null : \"@AssumeAssertion(nullness): non-generic container class; elements are non-null\";\n        result.append(rangeString((Period) p, tz) + \"\\n\");\n    }\n    return result.toString();\n}"
            ],
            [
                "mergeDateAndTime",
                "plume",
                "ICalAvailable",
                "/**\n * Creates a new DateTime with date taken from the first argument and\n * time taken from the second argument.\n * @return the merged DateTime\n */\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic DateTime mergeDateAndTime(DateTime date, DateTime time) {\n    if (!date.getTimeZone().equals(time.getTimeZone())) {\n        throw new Error(String.format(\"non-matching timezones: %s %s\", date.getTimeZone(), time.getTimeZone()));\n    }\n    DateTime result = new DateTime(date);\n    result.setHours(time.getHours());\n    result.setMinutes(time.getMinutes());\n    result.setSeconds(time.getSeconds());\n    return result;\n}"
            ],
            [
                "oneDayAvailable",
                "plume",
                "ICalAvailable",
                "// TODO:  don't propose times that are before the current moment.\n// Process day-by-day because otherwise weekends and evenings are included.\n// for iCal4j\n@SuppressWarnings(\"unchecked\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nList<Period> oneDayAvailable(DateTime day, List<Calendar> calendars) {\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...)%n\", day);\n    }\n    List<Period> result = new ArrayList<Period>();\n    // for iCal4j\n    @SuppressWarnings(\"deprecation\")\n    int dayOfWeek = day.getDay();\n    if (!businessDays.contains(dayOfWeek)) {\n        return result;\n    }\n    for (Period bh : businessHours) {\n        DateTime start = mergeDateAndTime(day, bh.getStart());\n        DateTime end = mergeDateAndTime(day, bh.getEnd());\n        VFreeBusy request = new VFreeBusy(start, end, new Dur(0, 0, 0, 1));\n        if (debug) {\n            System.out.println(\"Request = \" + request);\n        }\n        ComponentList busyTimes = new ComponentList();\n        // Problem:  any all-day events will be treated as UTC.\n        // Instead, they should be converted to local time (tz1).\n        // But VFreeBusy does not support this, so I may need to convert\n        // daily events into a different format before inserting them.\n        for (Calendar calendar : calendars) {\n            // getComponents() returns a raw ArrayList.  Expose its element type.\n            ArrayList<Component> /*@NonNull*/\n            clist = calendar.getComponents();\n            for (Component c : clist) {\n                if (c instanceof VEvent) {\n                    VEvent v = (VEvent) c;\n                    DtStart dts = v.getStartDate();\n                    Parameter dtsValue = dts.getParameter(\"VALUE\");\n                    boolean allDay = (dtsValue != null) && dtsValue.getValue().equals(\"DATE\");\n                    // TODO: convert to the proper timezone.\n                    // Tricky: must deal with the possibility of RRULE:FREQ=\n                }\n                busyTimes.add(c);\n            }\n        }\n        VFreeBusy response = new VFreeBusy(request, busyTimes);\n        if (debug) {\n            System.out.println(\"Response = \" + response);\n        }\n        FreeBusy freefb = (FreeBusy) response.getProperty(\"FREEBUSY\");\n        if (freefb == null) {\n            if (debug) {\n                System.out.println(\"FREEBUSY property is null\");\n            }\n            continue;\n        }\n        // interned fields from a library, but not annotated so\n        @SuppressWarnings(\"interning\")\n        boolean isFree = (freefb.getParameter(Parameter.FBTYPE) == FbType.FREE);\n        assert isFree;\n        PeriodList freePeriods = freefb.getPeriods();\n        if (debug) {\n            System.out.printf(\"Free periods: %n%s%n\", periodListString(freePeriods, tz1));\n        }\n        result.addAll(freePeriods);\n    }\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...) => %s elements%n\", day, result.size());\n    }\n    return result;\n}"
            ],
            [
                "parseDate",
                "plume",
                "ICalAvailable",
                "/**\n * Parses a date when formatted in several common formats.\n * @return a Date read from the given string\n * @see dateFormats\n */\nstatic java.util.Date parseDate(String strDate) throws ParseException {\n    if (Pattern.matches(\"^[0-9][0-9]?/[0-9][0-9]?$\", date)) {\n        // for iCal4j\n        @SuppressWarnings(\"deprecation\")\n        int year = new Date().getYear() + 1900;\n        strDate = strDate + \"/\" + year;\n    }\n    for (DateFormat this_df : dateFormats) {\n        this_df.setLenient(false);\n        try {\n            java.util.Date result = this_df.parse(strDate);\n            return result;\n        } catch (ParseException e) {\n            // Try the next format in the list.\n        }\n    }\n    throw new ParseException(\"bad date \" + strDate, 0);\n}"
            ],
            [
                "formatDate",
                "plume",
                "ICalAvailable",
                "static String formatDate(DateTime d, TimeZone tz) {\n    df.setTimeZone(tz);\n    String result = df.format(d);\n    // Don't remove trailing year; it's a good double-check.\n    // Remove trailing year, such as \", 1952\".\n    // result = result.substring(0, result.length() - 6);\n    // Prepend day of week.\n    result = dffull.format(d).substring(0, 3) + \" \" + result;\n    return result;\n}"
            ],
            [
                "get_method_declaration",
                "plume",
                "BCELUtil",
                "/**\n * Returns a string describing a method declaration. It contains the access\n * flags (public, private, static, etc), the return type, the method name, and\n * the types of each of its arguments.\n * @param m the method\n * @return a string describing the method declaration\n */\npublic static String get_method_declaration(Method m) {\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n        f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n}"
            ],
            [
                "get_access_flags",
                "plume",
                "BCELUtil",
                "/**\n * Return a string representation of the access flags of method m.\n * @param m the method whose access flags to retrieve\n * @return a string representation of the access flags of method m\n */\nstatic String get_access_flags(Method m) {\n    int flags = m.getAccessFlags();\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n        if ((flags & pow) != 0) {\n            if (buf.length() > 0) {\n                buf.append(\" \");\n            }\n            if (i < Const.ACCESS_NAMES_LENGTH) {\n                buf.append(Const.getAccessName(i));\n            } else {\n                buf.append(String.format(\"ACC_BIT %x\", pow));\n            }\n        }\n        pow <<= 1;\n    }\n    return (buf.toString());\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a) {\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "get_constant_str",
                "plume",
                "BCELUtil",
                "/**\n * Returns the constant string at the specified offset.\n * @param pool the constant pool\n * @param index the index in the constant pool\n * @return the constant string at the specified offset in the constant pool\n */\npublic static String get_constant_str(ConstantPool pool, int index) {\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n        return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n        ConstantClass cc = (ConstantClass) c;\n        return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n        throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param mg the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param m the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param mg the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param m the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param gen the class to test\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in the format of Class.getName();\n *   the class should not be an array\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(/*@ClassGetName*/\nString classname) {\n    return classname.startsWith(\"java.\") || classname.startsWith(\"com.\") || classname.startsWith(\"javax.\") || classname.startsWith(\"org.\") || classname.startsWith(\"sun.\") || classname.startsWith(\"sunw.\");\n}"
            ],
            [
                "in_jdk_internalform",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in internal form\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk_internalform(/*@InternalForm*/\nString classname) {\n    return classname.startsWith(\"java/\") || classname.startsWith(\"com/\") || classname.startsWith(\"javax/\") || classname.startsWith(\"org/\") || classname.startsWith(\"sun/\") || classname.startsWith(\"sunw/\");\n}"
            ],
            [
                "instruction_descr",
                "plume",
                "BCELUtil",
                "// TODO: write Javadoc\n@SuppressWarnings(\"rawtypes\")\npublic static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n        @SuppressWarnings(// BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n        \"nullness\")\n        InstructionHandle /*@NonNull*/\n        handle = (InstructionHandle) i.next();\n        out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n}"
            ],
            [
                "local_var_descr",
                "plume",
                "BCELUtil",
                "/**\n * Return a description of the local variables (one per line).\n * @param mg the method whose local variables to describe\n * @return a description of the local variables (one per line)\n */\npublic static String local_var_descr(MethodGen mg) {\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n        for (LocalVariableGen lvg : lvgs) {\n            out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n        }\n    }\n    return (out.toString());\n}"
            ],
            [
                "is_local_variable_type_table",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the specified attribute is a local variable type\n * table.\n * @param a the attribute\n * @param pool the constant pool\n * @return true iff the attribute is a local variable type table\n */\npublic static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @param pool the constant pool\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "is_main",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not this is a standard main method (static,\n * name is 'main', and one argument of string array).\n * @param mg the method to check\n * @return true iff the method is a main method\n */\npublic static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic() && mg.getName().equals(\"main\") && (arg_types.length == 1) && arg_types[0].equals(string_array));\n}"
            ],
            [
                "type_to_classgetname",
                "plume",
                "BCELUtil",
                "/**\n * Returns the Java class name, in the format of {@link Class#getName()},\n * that corresponds to type.\n * @param type the type\n * @return the Java classname that corresponds to type\n */\npublic static /*@ClassGetName*/\nString type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n}"
            ],
            [
                "type_to_class",
                "plume",
                "BCELUtil",
                "/**\n * Returns the class that corresponds to type.\n * @param type the type\n * @return the Java class that corresponds to type\n */\npublic static Class<?> type_to_class(Type type) {\n    String classname = type_to_classgetname(type);\n    try {\n        Class<?> c = UtilMDE.classForName(classname);\n        return c;\n    } catch (Exception e) {\n        throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n}"
            ],
            [
                "add_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type added to the end of types.\n * @param types the array to extend\n * @param new_type the element to add to the end of the types array\n * @return the array (or a new one), with new_type at the end\n */\npublic static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "insert_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type inserted at the beginning.\n * @param types the array to extend\n * @param new_type the element to add to the beginning of the types array\n * @return the array (or a new one), with new_type at the beginning\n */\npublic static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "classname_to_type",
                "plume",
                "BCELUtil",
                "/**\n * Return the type corresponding to a given class name.\n * @param classname the class to convert to a type\n * @return the type corresponding to the given class name\n */\npublic static Type classname_to_type(String classname) {\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n        classname = classname.substring(0, classname.length() - 2);\n        array_depth++;\n    }\n    classname = classname.intern();\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") {\n        // interned\n        t = Type.INT;\n    } else if (classname == \"boolean\") {\n        // interned\n        t = Type.BOOLEAN;\n    } else if (classname == \"byte\") {\n        // interned\n        t = Type.BYTE;\n    } else if (classname == \"char\") {\n        // interned\n        t = Type.CHAR;\n    } else if (classname == \"double\") {\n        // interned\n        t = Type.DOUBLE;\n    } else if (classname == \"float\") {\n        // interned\n        t = Type.FLOAT;\n    } else if (classname == \"long\") {\n        // interned\n        t = Type.LONG;\n    } else if (classname == \"short\") {\n        // interned\n        t = Type.SHORT;\n    } else {\n        // must be a non-primitive\n        t = new ObjectType(classname);\n    }\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n        t = new ArrayType(t, array_depth);\n    }\n    return t;\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Array\n///\n// For arrays, see ArraysMDE.java.\n///////////////////////////////////////////////////////////////////////////\n/// BitSet\n///\n/**\n * Returns true if the cardinality of the intersection of the two\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b) >= i);\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "/**\n * Returns true if the cardinality of the intersection of the three\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b intersect c) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        intersection.and(c);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the two BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @return size(a intersect b)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the three BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @return size(a intersect b intersect c)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n}"
            ],
            [
                "fileInputStream",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// BufferedFileReader\n///\n// Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n/**\n * Returns an InputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStream for file\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            in = new GZIPInputStream(new FileInputStream(file));\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        in = new FileInputStream(file);\n    }\n    return in;\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return an InputStream for filename\n * @throws IOException if there is trouble reading the file\n * @throws FileNotFoundException if the file is not found\n */\npublic static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName null, or the name of a Charset to use when reading the file\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibility-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a LineNumberReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return a LineNumberReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedWriter appends to the end\n * of the file instead of the beginning\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\n// Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\npublic static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n        file_writer = new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n        file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n}"
            ],
            [
                "bufferedFileOutputStream",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedOutputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedOutputStream appends to the end\n * of the file instead of the beginning\n * @return a BufferedOutputStream for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}"
            ],
            [
                "isSubtype",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Class\n///\n/**\n * Return true iff sub is a subtype of sup.\n * If sub == sup, then sub is considered a subtype of sub and this method\n * returns true.\n * @param sub class to test for being a subtype\n * @param sup class to test for being a supertype\n * @return true iff sub is a subtype of sup\n */\n/*@Pure*/\npublic static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n        return true;\n    }\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n        return true;\n    }\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n        if (ifc == sup || isSubtype(ifc, sup)) {\n            return true;\n        }\n    }\n    return false;\n}"
            ],
            [
                "classForName",
                "plume",
                "UtilMDE",
                "/**\n * Like {@link Class#forName(String)}, but also works when the string\n * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n * <p>\n * If the given name can't be found, this method changes the last '.'  to\n * a dollar sign ($) and tries again.  This accounts for inner classes\n * that are incorrectly passed in in fully-qualified format instead of\n * binary format.\n * <p>\n * Recall the rather odd specification for {@link Class#forName(String)}:\n * the argument is a binary name for non-arrays, but a field descriptor\n * for arrays.  This method uses the same rules, but additionally handles\n * primitive types and, for non-arrays, fully-qualified names.\n * @param className name of the class\n * @return the Class corresponding to className\n * @throws ClassNotFoundException if the class is not found\n */\n// The annotation encourages proper use, even though this can take a\n// fully-qualified name (only for a non-array).\npublic static Class<?> classForName(/*@ClassGetName*/\nString className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n        return result;\n    } else {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            int pos = className.lastIndexOf('.');\n            if (pos < 0) {\n                throw e;\n            }\n            // checked below & exception is handled\n            @SuppressWarnings(\"signature\")\n            String /*@ClassGetName*/\n            inner_name = className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n            try {\n                return Class.forName(inner_name);\n            } catch (ClassNotFoundException ee) {\n                throw e;\n            }\n        }\n    }\n}"
            ],
            [
                "binaryNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a binary name to a field descriptor.\n * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n * or \"int\" to \"I\".\n * @param classname name of the class, in binary class name format\n * @return name of the class, in field descriptor format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@FieldDescriptor*/\nString binaryNameToFieldDescriptor(/*@BinaryName*/\nString classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n        dims++;\n        sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n        result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n        result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n}"
            ],
            [
                "primitiveTypeNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n * a field descriptor (e.g., \"I\", \"D\", etc.).\n * @param primitive_name name of the type, in Java format\n * @return name of the type, in field descriptor format\n * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n */\npublic static /*@FieldDescriptor*/\nString primitiveTypeNameToFieldDescriptor(String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n        throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n}"
            ],
            [
                "binaryNameToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a BinaryName to the format of {@link Class#getName()}.\n * @param bn the binary name to convert\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString binaryNameToClassGetName(/*BinaryName*/\nString bn) {\n    if (bn.endsWith(\"[]\")) {\n        return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n        return bn;\n    }\n}"
            ],
            [
                "fieldDescriptorToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n * @param fd the class, in field descriptor format\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString fieldDescriptorToClassGetName(/*FieldDescriptor*/\nString fd) {\n    if (fd.startsWith(\"[\")) {\n        return fd.replace('/', '.');\n    } else {\n        return fieldDescriptorToBinaryName(fd);\n    }\n}"
            ],
            [
                "arglistToJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert a fully-qualified argument list from Java format to JVML format.\n * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n * @param arglist an argument list, in Java format\n * @return argument list, in JVML format\n */\npublic static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n        // substring\n        @SuppressWarnings(\"signature\")\n        String /*@BinaryName*/\n        arg = args_tokenizer.nextToken().trim();\n        result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n}"
            ],
            [
                "fieldDescriptorToBinaryName",
                "plume",
                "UtilMDE",
                "// does not convert \"V\" to \"void\".  Should it?\n/**\n * Convert a field descriptor to a binary name.\n * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n * or \"I\" to \"int\".\n * @param classname name of the type, in JVML format\n * @return name of the type, in Java format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@BinaryName*/\nString fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n        throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n        dims++;\n        classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n        result = classname.substring(1, classname.length() - 1);\n    } else {\n        result = primitiveClassesFromJvm.get(classname);\n        if (result == null) {\n            throw new Error(\"Malformed base class: \" + classname);\n        }\n    }\n    for (int i = 0; i < dims; i++) {\n        result += \"[]\";\n    }\n    return result.replace('/', '.');\n}"
            ],
            [
                "arglistFromJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert an argument list from JVML format to Java format.\n * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n * @param arglist an argument list, in JVML format\n * @return argument list, in Java format\n */\npublic static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n        if (pos > 1) {\n            result += \", \";\n        }\n        int nonarray_pos = pos;\n        while (arglist.charAt(nonarray_pos) == '[') {\n            nonarray_pos++;\n        }\n        char c = arglist.charAt(nonarray_pos);\n        if (c == 'L') {\n            int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n            result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n            pos = semi_pos + 1;\n        } else {\n            String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n            if (maybe == null) {\n                // return null;\n                throw new Error(\"Malformed arglist: \" + arglist);\n            }\n            result += maybe;\n            pos = nonarray_pos + 1;\n        }\n    }\n    return result + \")\";\n}"
            ],
            [
                "defineClassFromFile",
                "plume",
                "UtilMDE",
                "/**\n * Converts the bytes in a file into an instance of class Class, and\n * resolves (links) the class.\n * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n * file name rather than an array of bytes as an argument, and also resolves\n * (links) the class.\n * @see ClassLoader#defineClass(String,byte[],int,int)\n * @param className the name of the class to define, or null if not known\n * @param pathname the pathname of a .class file\n * @return a Java Object corresponding to the Class defined in the .class file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\n// Also throws UnsupportedClassVersionError and some other exceptions.\npublic static Class<?> defineClassFromFile(/*@BinaryName*/\nString className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n}"
            ],
            [
                "count_lines",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// File\n///\n/**\n * Count the number of lines in the specified file.\n * @param filename file whose size to count\n * @return number of lines in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n        while (reader.readLine() != null) {\n            count++;\n        }\n    }\n    return count;\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param filename the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param file the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n        int unix = 0;\n        int dos = 0;\n        int mac = 0;\n        while (true) {\n            String s = r.readLine();\n            if (s == null) {\n                break;\n            }\n            if (s.endsWith(\"\\r\\n\")) {\n                dos++;\n            } else if (s.endsWith(\"\\r\")) {\n                mac++;\n            } else if (s.endsWith(\"\\n\")) {\n                unix++;\n            } else {\n                // This can happen only if the last line is not terminated.\n            }\n        }\n        if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n            return \"\\r\\n\";\n        }\n        if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n            return \"\\r\";\n        }\n        if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n            return \"\\n\";\n        }\n        // The two non-preferred line endings are tied and have more votes than\n        // the preferred line ending.  Give up and return the line separator\n        // for the system on which Java is currently running.\n        return lineSep;\n    }\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @return true iff the files have the same contents\n */\n/*@Pure*/\npublic static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff the files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @param trimLines if true, call String.trim on each line before comparing\n * @return true iff the files have the same contents\n */\n// reads files, side effects local state\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2)) {\n        String line1 = reader1.readLine();\n        String line2 = reader2.readLine();\n        while (line1 != null && line2 != null) {\n            if (trimLines) {\n                line1 = line1.trim();\n                line2 = line2.trim();\n            }\n            if (!(line1.equals(line2))) {\n                return false;\n            }\n            line1 = reader1.readLine();\n            line2 = reader2.readLine();\n        }\n        if (line1 == null && line2 == null) {\n            return true;\n        }\n        return false;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}"
            ],
            [
                "canCreateAndWrite",
                "plume",
                "UtilMDE",
                "/**\n * Returns true\n *  if the file exists and is writable, or\n *  if the file can be created.\n * @param file the file to create and write\n * @return true iff the file can be created and written\n */\npublic static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n        return file.canWrite();\n    } else {\n        File directory = file.getParentFile();\n        if (directory == null) {\n            directory = new File(\".\");\n        }\n        // Does this test need \"directory.canRead()\" also?\n        return directory.canWrite();\n    }\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n}"
            ],
            [
                "createTempDir",
                "plume",
                "UtilMDE",
                "///\n/// Directories\n///\n/**\n * Creates an empty directory in the default temporary-file directory,\n * using the given prefix and suffix to generate its name. For example,\n * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n * someString is internally generated to ensure no temporary files of the\n * same name are generated.\n * @param prefix the prefix string to be used in generating the file's\n *  name; must be at least three characters long\n * @param suffix the suffix string to be used in generating the file's\n *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n *  An abstract pathname denoting a newly-created empty file\n * @return a File representing the newly-created temporary directory\n * @throws IllegalArgumentException If the prefix argument contains fewer\n *  than three characters\n * @throws IOException If a file could not be created\n * @throws SecurityException If a security manager exists and its\n *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n *  file to be created\n * @see java.io.File#createTempFile(String, String, File)\n */\npublic static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dirName and all its files.\n * @param dirName the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dir and all its files.\n * @param dir the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n        return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    return dir.delete();\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name file whose name to expand\n * @return file with expanded file\n */\npublic static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n        return new File(newname);\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name filename to expand\n * @return expanded filename\n */\npublic static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n        return (name.replace(\"~\", userHome));\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "java_source",
                "plume",
                "UtilMDE",
                "/**\n * Return a string version of the name that can be used in Java source.\n * On Windows, the file will return a backslash separated string.  Since\n * backslash is an escape character, it must be quoted itself inside\n * the string.\n * <p>\n * The current implementation presumes that backslashes don't appear\n * in filenames except as windows path separators.  That seems like a\n * reasonable assumption.\n *\n * @param name file to quote\n * @return a string version of the name that can be used in Java source\n */\npublic static String java_source(File name) {\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n}"
            ],
            [
                "readObject",
                "plume",
                "UtilMDE",
                "/**\n * Reads an Object from a File.\n * @param file the file from which to read\n * @return the object read from the file\n * @throws IOException if there is trouble reading the file\n * @throws ClassNotFoundException if the object's class cannot be found\n */\npublic static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            istream = new GZIPInputStream(istream);\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n}"
            ],
            [
                "readerContents",
                "plume",
                "UtilMDE",
                "/**\n * Reads the entire contents of the reader and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param r the Reader to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readerContents(Reader r) {\n    try {\n        StringBuilder contents = new StringBuilder();\n        int ch;\n        while ((ch = r.read()) != -1) {\n            contents.append((char) ch);\n        }\n        r.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n}"
            ],
            [
                "readFile",
                "plume",
                "UtilMDE",
                "// an alternate name would be \"fileContents\".\n/**\n * Reads the entire contents of the file and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param file the file to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readFile(File file) {\n    try {\n        BufferedReader reader = UtilMDE.bufferedFileReader(file);\n        StringBuilder contents = new StringBuilder();\n        String line = reader.readLine();\n        while (line != null) {\n            contents.append(line);\n            // Note that this converts line terminators!\n            contents.append(lineSep);\n            line = reader.readLine();\n        }\n        reader.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Hashing\n///\n// In hashing, there are two separate issues.  First, one must convert\n// the input datum into an integer.  Then, one must transform the\n// resulting integer in a pseudorandom way so as to result in a number\n// that is far separated from other values that may have been near it to\n// begin with.  Often these two steps are combined, particularly if\n// one wishes to avoid creating too large an integer (losing information\n// off the top bits).\n// http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n//  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n//    h += (h<<3); h ^= (h>>11); h += (h<<15);\n//    is good.\n//  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n//  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n// In this part of the file, perhaps I will eventually write good hash\n// functions.  For now, write cheesy ones that primarily deal with the\n// first issue, transforming a data structure into a single number.  This\n// is also known as fingerprinting.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Double#hashCode()}.\n * @param x value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a) {\n    double result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a, double[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/// Don't define hash with int args; use the long versions instead.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Long#hashCode()}.\n * But it doesn't map -1 and 0 to the same value.\n * @param l value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n        return (int) l;\n    }\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a, long[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a) {\n    return (a == null) ? 0 : a.hashCode();\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b, /*@Nullable*/\nString c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + hash(a[i]);\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @param random the Random instance to use to make selections\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n    while (itor.hasNext()) {\n        rs.accept(itor.next());\n    }\n    return rs.getValues();\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n}"
            ],
            [
                "incrementMap",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Map\n///\n// In Python, inlining this gave a 10x speed improvement.\n// Will the same be true for Java?\n/**\n * Increment the Integer which is indexed by key in the Map.\n * If the key isn't in the Map, it is added.\n * @param <T> type of keys in the map\n * @param m map to have one of its values incremented\n * @param key the key for the element whose value will be incremented\n * @param count how much to increment the value by\n * @return the old value, before it was incremented\n * @throws Error if the key is in the Map but maps to a non-Integer.\n */\npublic static <T> /*@Nullable*/\nInteger incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n        new_total = count;\n    } else {\n        new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n}"
            ],
            [
                "mapToString",
                "plume",
                "UtilMDE",
                "/**\n * Returns a multi-line string representation of a map.\n * @param <K> type of map keys\n * @param <V> type of map values\n * @param m map to be converted to a string\n * @return a multi-line string representation of m\n */\npublic static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @return a sorted version of m.keySet()\n */\npublic static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @param comparator the Comparator to use for sorting\n * @return a sorted version of m.keySet()\n */\npublic static <K, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m, Comparator<K> comparator) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a method signature, return the method.\n * Example calls are:\n * <pre>\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n * </pre>\n * @param method a method signature\n * @return the method corresponding to the given signature\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n        throw new Error(\"malformed method name should contain a period, open paren, and close paren: \" + method + \" <<\" + dotpos + \",\" + oparenpos + \",\" + cparenpos + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n        if (!Character.isWhitespace(method.charAt(i))) {\n            throw new Error(\"malformed method name should contain only whitespace following close paren\");\n        }\n    }\n    // throws exception if class does not exist\n    @SuppressWarnings(\"signature\")\n    String /*@BinaryNameForNonArray*/\n    classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n        String[] argnames;\n        if (all_argnames.equals(\"\")) {\n            argnames = new String[0];\n        } else {\n            argnames = split(all_argnames, ',');\n        }\n        /*@MonotonicNonNull*/\n        Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n        for (int i = 0; i < argnames.length; i++) {\n            String bnArgname = argnames[i].trim();\n            /*@ClassGetName*/\n            String cgnArgname = binaryNameToClassGetName(bnArgname);\n            argclasses_tmp[i] = classForName(cgnArgname);\n        }\n        @SuppressWarnings(\"cast\")\n        Class<?>[] argclasses_res = (Class<?>[]) argclasses_tmp;\n        argclasses = argclasses_res;\n        args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a class name and a method name in that class, return the method.\n * @param classname class in which to find the method\n * @param methodname the method name\n * @param params the parameters of the method\n * @return the method named classname.methodname with parameters params\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(/*@BinaryNameForNonArray*/\nString classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// ProcessBuilder\n///\n/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line\n * @return all the output of the command\n */\npublic static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line, as a list of\n * strings (the command, then its arguments)\n * @return all the output of the command\n */\npublic static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n        Process p = pb.start();\n        @SuppressWarnings(// input stream is non-null because we didn't redirect the input stream\n        \"nullness\")\n        String output = UtilMDE.streamString(p.getInputStream());\n        return output;\n    } catch (IOException e) {\n        return \"IOException: \" + e.getMessage();\n    }\n}"
            ],
            [
                "propertyIsTrue",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Properties\n///\n/**\n * Determines whether a property has value \"true\", \"yes\", or \"1\".\n * @see Properties#getProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @return true iff the property has value \"true\", \"yes\", or \"1\"\n */\n// does not depend on object identity\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n        return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n}"
            ],
            [
                "appendProperty",
                "plume",
                "UtilMDE",
                "/**\n * Set the property to its previous value concatenated to the given value.\n * Return the previous value.\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to concatenate to the previous value of the property\n * @return the previous value of the property\n * @see Properties#getProperty\n * @see Properties#setProperty\n */\npublic static /*@Nullable*/\nString appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n}"
            ],
            [
                "setDefaultMaybe",
                "plume",
                "UtilMDE",
                "/**\n * Set the property only if it was not previously set.\n * @see Properties#getProperty\n * @see Properties#setProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to set the property to, if it is not already set\n * @return the previous value of the property\n */\npublic static /*@Nullable*/\nString setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n        p.setProperty(key, value);\n    }\n    return currentValue;\n}"
            ],
            [
                "getPrivateField",
                "plume",
                "UtilMDE",
                "// TODO: set the field back to private after is is accessed.\n/**\n * Reads the given field, which may be private.\n * Leaves the field accessible.\n * Use with care!\n * @param o object in which to set the field\n * @param fieldName name of field to set\n * @return new value of field\n * @throws NoSuchFieldException if the field does not exist in the object\n */\npublic static /*@Nullable*/\nObject getPrivateField(Object o, String fieldName) throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) {\n        // Class is interned\n        // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n        try {\n            Field f = c.getDeclaredField(fieldName);\n            f.setAccessible(true);\n            return f.get(o);\n        } catch (IllegalAccessException e) {\n            System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n            throw new Error(\"This can't happen: \" + e);\n        } catch (NoSuchFieldException e) {\n            if (c.getSuperclass() == Object.class) {\n                // Class is interned\n                throw e;\n            }\n            // nothing to do; will now examine superclass\n        }\n        c = c.getSuperclass();\n        assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n}"
            ],
            [
                "getFromSet",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set\n///\n/**\n * Return the object in this set that is equal to key.\n * The Set abstraction doesn't provide this; it only provides \"contains\".\n * Returns null if the argument is null, or if it isn't in the set.\n * @param set a set in which to look up the value\n * @param key the value to look up in the set\n * @return the object in this set that is equal to key, or null\n */\npublic static /*@Nullable*/\nObject getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n        return null;\n    }\n    for (Object elt : set) {\n        if (key.equals(elt)) {\n            return elt;\n        }\n    }\n    return null;\n}"
            ],
            [
                "streamString",
                "plume",
                "UtilMDE",
                "/**\n * Return a String containing all the characters from the input stream.\n * @param is input stream to read\n * @return a String containing all the characters from the input stream\n */\npublic static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n}"
            ],
            [
                "replaceString",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// String\n///\n/**\n * Return a new string which is the text of target with all instances of\n * oldStr replaced by newStr.\n * @param target the string to do replacement in\n * @param oldStr the substring to replace\n * @param newStr the replacement\n * @return target with all instances of oldStr replaced by newStr\n */\npublic static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n        throw new IllegalArgumentException();\n    }\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n        result.append(target.substring(lastend, pos));\n        result.append(newStr);\n        lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter character.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, String delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter String.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, char delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n        throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "splitLines",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings, one for each line in the argument.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n * are supported.  Note that a string that ends with a line separator\n * will return an empty string as the last element of the array.\n * @see #split(String s, char delim)\n * @param s the string to split\n * @return an array of Strings, one for each line in the argument\n */\npublic static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the array elements, placing the\n * delimiter between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n        return \"\";\n    }\n    if (a.length == 1) {\n        return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n        sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(Object... a) {\n    return join(a, lineSep);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * delimiter between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n        return \"\";\n    }\n    if (v.size() == 1) {\n        return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n        sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(List<String> v) {\n    return join(v, lineSep);\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Escape \\, \", newline, and carriage-return characters in the\n * target as \\\\, \\\", \\n, and \\r; return a new string if any\n * modifications were necessary.  The intent is that by surrounding\n * the return value with double quote marks, the result will be a\n * Java string literal denoting the original string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        switch(c) {\n            case '\\\"':\n            case '\\\\':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append('\\\\');\n                post_esc = i;\n                break;\n            case // not lineSep\n            '\\n':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                // not lineSep\n                sb.append(\"\\\\n\");\n                post_esc = i + 1;\n                break;\n            case '\\r':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append(\"\\\\r\");\n                post_esc = i + 1;\n                break;\n            default:\n        }\n    }\n    if (sb.length() == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "// The overhead of this is too high to call in escapeNonJava(String), so\n// it is inlined there.\n/**\n * Like {@link #escapeNonJava(String)}, but for a single character.\n * @param ch character to quote\n * @return quoted version och ch\n */\npublic static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch(c) {\n        case '\\\"':\n            return \"\\\\\\\"\";\n        case '\\\\':\n            return \"\\\\\\\\\";\n        case // not lineSep\n        '\\n':\n            // not lineSep\n            return \"\\\\n\";\n        case '\\r':\n            return \"\\\\r\";\n        default:\n            return new String(new char[] { c });\n    }\n}"
            ],
            [
                "escapeNonASCII",
                "plume",
                "UtilMDE",
                "/**\n * Escape unprintable characters in the target, following the usual\n * Java backslash conventions, so that the result is sure to be\n * printable ASCII.  Returns a new string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n}"
            ],
            [
                "unescapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n * one-character equivalents.  All other backslashes are removed\n * (for instance, octal/hex escape sequences are not turned into\n * their respective characters). This is the inverse operation of\n * escapeNonJava(). Previously known as unquote().\n * @param orig string to quoto\n * @return quoted version of orig\n */\npublic static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n        if (this_esc == orig.length() - 1) {\n            sb.append(orig.substring(post_esc, this_esc + 1));\n            post_esc = this_esc + 1;\n            break;\n        }\n        switch(orig.charAt(this_esc + 1)) {\n            case 'n':\n                sb.append(orig.substring(post_esc, this_esc));\n                // not lineSep\n                sb.append('\\n');\n                post_esc = this_esc + 2;\n                break;\n            case 'r':\n                sb.append(orig.substring(post_esc, this_esc));\n                sb.append('\\r');\n                post_esc = this_esc + 2;\n                break;\n            case '\\\\':\n                // This is not in the default case because the search would find\n                // the quoted backslash.  Here we incluce the first backslash in\n                // the output, but not the first.\n                sb.append(orig.substring(post_esc, this_esc + 1));\n                post_esc = this_esc + 2;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                sb.append(orig.substring(post_esc, this_esc));\n                char octal_char = 0;\n                int ii = this_esc + 1;\n                while (ii < orig.length()) {\n                    char ch = orig.charAt(ii++);\n                    if ((ch < '0') || (ch > '8')) {\n                        break;\n                    }\n                    octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n                }\n                sb.append(octal_char);\n                post_esc = ii - 1;\n                break;\n            default:\n                // In the default case, retain the character following the backslash,\n                // but discard the backslash itself.  \"\\*\" is just a one-character string.\n                sb.append(orig.substring(post_esc, this_esc));\n                post_esc = this_esc + 1;\n                break;\n        }\n        this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "removeWhitespaceAround",
                "plume",
                "UtilMDE",
                "// Use the built-in String.trim()!\n// /** Return the string with all leading and trailing whitespace stripped. */\n// public static String trimWhitespace(String s) {\n//   int len = s.length();\n//   if (len == 0)\n//     return s;\n//   int first_non_ws = 0;\n//   int last_non_ws = len-1;\n//   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n//     first_non_ws++;\n//   if (first_non_ws == len)\n//     return \"\";\n//   while (Character.isWhitespace(s.charAt(last_non_ws)))\n//     last_non_ws--;\n//   if ((first_non_ws == 0) && (last_non_ws == len)) {\n//     return s;\n//   } else {\n//     return s.substring(first_non_ws, last_non_ws+1);\n//   }\n// }\n// // // Testing:\n// // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n// // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n// // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n/**\n * Remove all whitespace before or after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace abutting\n * @return version of arg, with whitespace abutting delimiter removed\n */\npublic static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n}"
            ],
            [
                "removeWhitespaceAfter",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace after\n * @return version of arg, with whitespace after delimiter removed\n */\npublic static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index + delim_len;\n        while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index++;\n        }\n        // if (non_ws_index == arg.length()) {\n        //   System.out.println(\"No nonspace character at end of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index + delim_len) {\n            arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n        }\n        delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n}"
            ],
            [
                "removeWhitespaceBefore",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace before instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace before\n * @return version of arg, with whitespace before delimiter removed\n */\npublic static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index - 1;\n        while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index--;\n        }\n        // if (non_ws_index == -1) {\n        //   System.out.println(\"No nonspace character at front of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index - 1) {\n            arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n        }\n        delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n}"
            ],
            [
                "nplural",
                "plume",
                "UtilMDE",
                "/**\n * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n * @param n count of nouns\n * @param noun word being counted\n * @return noun, if n==1; otherwise, pluralization of noun\n */\npublic static String nplural(int n, String noun) {\n    if (n == 1) {\n        return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\") || noun.endsWith(\"s\") || noun.endsWith(\"sh\") || noun.endsWith(\"x\")) {\n        return n + \" \" + noun + \"es\";\n    } else {\n        return n + \" \" + noun + \"s\";\n    }\n}"
            ],
            [
                "lpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the left if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String lpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString() + s;\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the right if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String rpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n * @param num int whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n * @param num double whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the character appears in the string.\n * @param s string to search in\n * @param ch character to search for\n * @return number of times the character appears in the string\n */\npublic static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the second string appears in the first.\n * @param s string to search in\n * @param sub string to search for\n * @return number of times the substring appears in the string\n */\npublic static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// StringTokenizer\n///\n/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n * <p>\n * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n * (probably due to backward-compatibility).\n * @param str a string to be parsed\n * @param delim the delimiters\n * @param returnDelims flag indicating whether to return the delimiters as tokens\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n * @param str a string to be parsed\n * @param delim the delimiters\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n * @param str a string to be parsed\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n}"
            ],
            [
                "backTrace",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Throwable\n///\n/**\n * Return a String representation of the backtrace of the given Throwable.\n * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n * @param t the Throwable to obtain a backtrace of\n * @return a String representation of the backtrace of the given Throwable\n */\npublic static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n}"
            ],
            [
                "sortList",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Collections\n///\n/**\n * Return the sorted version of the list.  Does not alter the list.\n * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n * @return a sorted version of the list\n * @param <T> type of elements of the list\n * @param l a list to sort\n * @param c a sorted version of the list\n */\npublic static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n}"
            ],
            [
                "removeDuplicates",
                "plume",
                "UtilMDE",
                "// This should perhaps be named withoutDuplicates to emphasize that\n// it does not side-effect its argument.\n/**\n * Return a copy of the list with duplicates removed.\n * Retains the original order.\n * @param <T> type of elements of the list\n * @param l a list to remove duplicates from\n * @return a copy of the list with duplicates removed\n */\npublic static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n}"
            ],
            [
                "deepEquals",
                "plume",
                "UtilMDE",
                "/**\n * Determines deep equality for the elements.\n * <ul>\n * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n * <li>If both are lists, uses deepEquals recursively on each element.\n * <li>For other types, just uses equals() and does not recursively call this method.\n * </ul>\n * @param o1 first value to compare\n * @param o2 second value to comare\n * @return true iff o1 and o2 are deeply equal\n */\n// side effect to static field deepEqualsUnderway\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean deepEquals(/*@Nullable*/\nObject o1, /*@Nullable*/\nObject o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    // creates local state\n    @SuppressWarnings(\"purity\")\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n        return true;\n    }\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n        List<?> l1 = (List<?>) o1;\n        List<?> l2 = (List<?>) o2;\n        if (l1.size() != l2.size()) {\n            return false;\n        }\n        try {\n            deepEqualsUnderway.add(mypair);\n            for (int i = 0; i < l1.size(); i++) {\n                Object e1 = l1.get(i);\n                Object e2 = l2.get(i);\n                if (!deepEquals(e1, e2)) {\n                    return false;\n                }\n            }\n        } finally {\n            deepEqualsUnderway.remove(mypair);\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}"
            ],
            [
                "makeVector",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Vector\n///\n/**\n * Returns a vector containing the elements of the enumeration.\n * @param <T> type of the enumeration and vector elements\n * @param e an enumeration to convert to a Vector\n * @return a vector containing the elements of the enumeration\n */\npublic static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n        result.addElement(e.nextElement());\n    }\n    return result;\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "// Rather than writing something like VectorToStringArray, use\n//   v.toArray(new String[0])\n/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of the specified objects starting at index\n * start over dims dimensions, for dims &gt; 0.\n * <p>\n * For example, create_combinations (1, 0, {a, b, c}) returns:\n * <pre>\n *    {a}, {b}, {c}\n * </pre>\n * And create_combinations (2, 0, {a, b, c}) returns:\n * <pre>\n *    {a, a}, {a, b}, {a, c}\n *    {b, b}, {b, c},\n *    {c, c}\n * </pre>\n * @param <T> type of the input list elements, and type of the innermost output list elements\n * @param dims number of dimensions:  that is, size of each innermost list\n * @param start initial index\n * @param objs list of elements to\n * @return list of lists of length dims, each of which combines elements from objs\n */\npublic static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n    if (dims < 1) {\n        throw new IllegalArgumentException();\n    }\n    List<List<T>> results = new ArrayList<List<T>>();\n    for (int i = start; i < objs.size(); i++) {\n        if (dims == 1) {\n            List<T> simple = new ArrayList<T>();\n            simple.add(objs.get(i));\n            results.add(simple);\n        } else {\n            List<List<T>> combos = create_combinations(dims - 1, i, objs);\n            for (List<T> lt : combos) {\n                List<T> simple = new ArrayList<T>();\n                simple.add(objs.get(i));\n                simple.addAll(lt);\n                results.add(simple);\n            }\n        }\n    }\n    return (results);\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of integers from start to cnt (inclusive) over\n * arity dimensions.\n * <p>\n * For example, create_combinations (1, 0, 2) returns:\n * <pre>\n *    {0}, {1}, {2}\n * </pre>\n * And create_combinations (2, 0, 2) returns:\n * <pre>\n *    {0, 0}, {0, 1}, {0, 2}\n *    {1, 1}  {1, 2},\n *    {2, 2}\n * </pre>\n * @param arity size of each innermost list\n * @param start initial value\n * @param cnt maximum element value\n * @return list of lists of length arity, each of which combines integers from start to cnt\n */\npublic static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n        results.add(new ArrayList<Integer>());\n        return (results);\n    }\n    for (int i = start; i <= cnt; i++) {\n        ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n        for (ArrayList<Integer> li : combos) {\n            ArrayList<Integer> simple = new ArrayList<Integer>();\n            simple.add(new Integer(i));\n            simple.addAll(li);\n            results.add(simple);\n        }\n    }\n    return (results);\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(/*@FullyQualifiedName*/\nString qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n}"
            ],
            [
                "fullyQualifiedNameToSimpleName",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n// TODO: does not follow the specification for inner classes (where the\n// type name should be empty), but I think this is more informative anyway.\n// string conversion\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetSimpleName*/\nString fullyQualifiedNameToSimpleName(/*@FullyQualifiedName*/\nString qualified_name) {\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n        return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified class.  For example if qualified name of the class\n * is java.lang.String, String will be returned.\n *\n * @deprecated use {@link Class#getSimpleName()} instead.\n *\n * @param cls a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n}"
            ],
            [
                "abbreviateNumber",
                "plume",
                "UtilMDE",
                "/**\n * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n * of precision in the result (counting both sides of the decimal point).\n * @param val a numeric value\n * @return an abbreviated string representation of the value\n */\npublic static String abbreviateNumber(long val) {\n    double dval = (double) val;\n    String mag = \"\";\n    if (val < 1000) {\n        // nothing to do\n    } else if (val < 1000000) {\n        dval = val / 1000.0;\n        mag = \"K\";\n    } else if (val < 1000000000) {\n        dval = val / 1000000.0;\n        mag = \"M\";\n    } else {\n        dval = val / 1000000000.0;\n        mag = \"G\";\n    }\n    String precision = \"0\";\n    if (dval < 10) {\n        precision = \"2\";\n    } else if (dval < 100) {\n        precision = \"1\";\n    }\n    // format string computed from precision and mag\n    @SuppressWarnings(\"formatter\")\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeIntSet",
                "/**\n * Merges a list of LimitedSizeIntSet objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param max_values the maximum size for the returned LimitedSizeIntSet\n * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n * @return a LimitedSizeIntSet that merges the elements of slist\n */\npublic static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist) {\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ],
            [
                "of",
                "plume",
                "Triple",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param <C> type of third argument\n * @param a first argument\n * @param b second argument\n * @param c third argument\n * @return a triple of the values (a, b, c)\n */\npublic static <A, B, C> Triple<A, B, C> of(A a, B b, C c) {\n    return new Triple<A, B, C>(a, b, c);\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// min, max\n///\n// Could also add linear-time orderStatistics if I liked.\n/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int min(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long min(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double min(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer min(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long min(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() < result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double min(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int max(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long max(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double max(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer max(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long max(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() > result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double max(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int[] min_max(int[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] { result_min, result_max };\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long[] min_max(long[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] { result_min, result_max };\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int element_range(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long element_range(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of integers.\n * @param a an array\n * @return the sum of an array of integers\n */\npublic static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of integers.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of integers\n */\npublic static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of doubles.\n * @param a an array\n * @return the sum of an array of doubles\n */\npublic static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of doubles.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of doubles\n */\npublic static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf\n///\n/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> type of the elements of the array\n * @param a an array\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt) {\n    if (elt == null) {\n        return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> the type of the elements\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n *    Identical to List.indexOf, but included for completeness.\n * @param a a list\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    return a.indexOf(elt);\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a.get(i))) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyNull*/\nObject[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.size(); i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf, for finding subarrays\n///\n// This is analogous to Common Lisp's \"search\" function.\n// This implementation is very inefficient; I could use tricky Boyer-Moore\n// search techniques if I liked, but it's not worth it to me yet.\n/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n// The signature on this method is unnecessarily strict because it\n// requires that the component types be identical.  The signature should\n// be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n// @PolyAll qualifier does not yet take an argument.\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// mismatch\n///\n// This is analogous to Common Lisp's \"mismatch\" function.\n// Put it off until later; for now, use the simpler subarray function,\n// which is a specialization of mismatch,\n///////////////////////////////////////////////////////////////////////////\n/// subarray extraction\n///\n// Note that the second argument is a length, not an end position.\n// That's to avoid confusion over whether it would be the last included\n// index or the first non-included index.\n/**\n * Return a subarray of the given array.\n * @return a subarray of the given array\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n */\n/*@SideEffectFree*/\npublic static Object[] subarray(/*@PolyAll*/\nObject[] a, int startindex, int length) {\n    /*@PolyAll*/\n    Object[] result = new /*@PolyAll*/\n    Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a sublist of the given list.\n * @param <T> type of the elements\n * @param a the original list\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a sublist of the given list\n */\n/*@SideEffectFree*/\npublic static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static String[] subarray(/*@PolyAll*/\nString[] a, int startindex, int length) {\n    /*@PolyAll*/\n    String[] result = new /*@PolyAll*/\n    String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// subarray testing\n///\n/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, /*@PolyNull*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.size()];\n            System.arraycopy(a, 0, result, 0, a.length);\n            // System.arraycopy(b, 0, result, a.length, b.size());\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.length] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.length];\n            // System.arraycopy(a, 0, result, 0, a.size());\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            System.arraycopy(b, 0, result, a.size(), b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.size()];\n            // System.arraycopy(a, 0, result, 0, a.length);\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            // System.arraycopy(b, 0, result, a.length, b.length);\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.size()] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "// Note: PolyAll is not quite right.  Need to review.\n/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first array to concatenate\n * @param b the second array to concatenate\n * @return an array that concatenates the arguments\n */\npublic static String[] concat(/*@PolyAll*/\nString[] a, /*@PolyAll*/\nString[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new String[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            /*@PolyAll*/\n            String[] result = new String[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static byte[] concat(byte[] a, byte[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new byte[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            byte[] result = new byte[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static boolean[] concat(boolean[] a, boolean[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new boolean[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            boolean[] result = new boolean[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static char[] concat(char[] a, char[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new char[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            char[] result = new char[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static double[] concat(double[] a, double[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new double[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            double[] result = new double[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static float[] concat(float[] a, float[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new float[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            float[] result = new float[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static int[] concat(int[] a, int[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new int[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            int[] result = new int[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static long[] concat(long[] a, long[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new long[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            long[] result = new long[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static short[] concat(short[] a, short[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new short[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            short[] result = new short[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Printing\n///\n// This should be extended to all types, when I get around to it.  The\n// methods are patterned after that of java.util.Vector (and use its\n// output format).\n/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@PolyAll*/\nObject[] a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, each element is quoted like a Java String.\n * @param a an array\n * @return a string representation of the array, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@PolyAll*/\nObject[] a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, if quoted is true, then each element is quoted like a Java String.\n * @param a an array\n * @param quoted whether to quote the array elements\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@PolyAll*/\nObject[] a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            if (quoted && a[i] instanceof String) {\n                String elt = (String) a[i];\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava(elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(a[i]);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @param quoted whether to quote the collection elements that are Java strings\n * @return a string representation of the list\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@Nullable*/\nCollection<?> a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n        Iterator<?> itor = a.iterator();\n        sb.append(itor.next());\n        while (itor.hasNext()) {\n            sb.append(\", \");\n            Object elt = itor.next();\n            if (quoted && elt instanceof String) {\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava((String) elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(elt);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(int[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(long[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(double[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(float[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(boolean[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls the appropriate\n * toString() method.  Only call this method if obj is a boolean, double,\n * int, long, or Object array.\n * @param obj an array\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n        return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n        return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n        return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n        return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n        return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n        return toString((List<?>) obj);\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "length",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls .length.\n * Only call this method if obj is a boolean, double, int, long, or Object array.\n * @param obj a list\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n        return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n        return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n        return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n        return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n        return ((List<?>) obj).size();\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Sortedness\n///\n/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Boolean n = Boolean.valueOf(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Byte n = new Byte(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Float n = new Float(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Short n = new Short(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Integer n = new Integer(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space. Equality checking\n * uses the .equals() method for java.lang.Double.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Double n = new Double(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Long n = new Long(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param <T> the type of the elements\n * @param a a list\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static </*@Pure*/\nT> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n        if (hs.contains(a.get(i))) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a.get(i));\n    }\n    return true;\n}"
            ],
            [
                "fn_is_permutation",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Arrays as partial functions of int->int\n///\n/**\n * Returns true if the array is a permutation of [0..a.length).\n * @param a an array, representing a function\n * @return true iff all elements of a are in [0..a.length) and a\n * contains no duplicates.\n */\n// side effect to local state (array)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int n = a[i];\n        if (n < 0 || n >= a.length || see[n]) {\n            return false;\n        }\n        see[n] = true;\n    }\n    return true;\n}"
            ],
            [
                "fn_is_total",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff the array does not contain -1.\n * @param a an array, representing a function\n * @return true iff no element of a maps to -1\n */\n/*@Pure*/\npublic static boolean fn_is_total(int[] a) {\n    // not found\n    return indexOf(a, -1) == -1;\n}"
            ],
            [
                "fn_identity",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array [0..lenth).\n * @param length the length of the result\n * @return fresh array that is the identity function of the given length\n */\npublic static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n        result[i] = i;\n    }\n    return result;\n}"
            ],
            [
                "fn_inverse_permutation",
                "plume",
                "ArraysMDE",
                "/**\n * Requires that fn_is_permutation(a) holds.\n * @param a the input permutation\n * @return fresh array which is the inverse of the given permutation\n * @see #fn_is_permutation(int[])\n */\npublic static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n}"
            ],
            [
                "fn_inverse",
                "plume",
                "ArraysMDE",
                "/**\n * Return the inverse of the given function, which is represented as an array.\n * @param a an array representing a function from [0..a.length) to [0..arange);\n *  each element of a is between 0 and arange inclusive\n * @param arange length of the argument's range and the result's domain\n * @return function from [0..arange) to [0..a.length) that is the inverse of a\n * @throws IllegalArgumentException if a value of a is outside of arange\n * @exception UnsupportedOperationException when the function is not invertible\n */\npublic static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n        int ai = a[i];\n        if (ai < -1 || ai >= arange) {\n            throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n        }\n        // ai is either -1 or a valid index\n        if (ai >= 0) {\n            if (result[ai] != -1) {\n                throw new UnsupportedOperationException(String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n            }\n            result[ai] = i;\n        }\n    }\n    return result;\n}"
            ],
            [
                "fn_compose",
                "plume",
                "ArraysMDE",
                "/**\n * Return the composition of the given two functions, all of which are\n * represented as arrays.\n * @param a function from [0..a.length) to [0..b.length)\n * @param b function from [0..b.length) to range R\n * @return function from [0..a.length) to range R that is the\n * composition of a and b\n */\npublic static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int inner = a[i];\n        if (inner == -1) {\n            result[i] = -1;\n        } else {\n            result[i] = b[inner];\n        }\n    }\n    return result;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set operations, such as subset, unions, and intersections\n///\n// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Long(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Long elt = new Long(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Double(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Double elt = new Double(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(bigger[i]);\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        if (!setBigger.contains(smaller[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// nullness\n///\n/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(/*@PolyAll*/\nObject[] a) {\n    if (a.length == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(/*@PolyAll*/\nObject[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (!(a[i] == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n        if (!(a.get(i) == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "int_array_iterator",
                "plume",
                "TestPlume",
                "///////////////////////////////////////////////////////////////////////////\n/// Utility functions\n///\npublic static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n        asList.add(nums[i]);\n    }\n    return asList.iterator();\n}"
            ],
            [
                "int_iterator_array",
                "plume",
                "TestPlume",
                "public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    return v;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n        v.add(e.nextElement());\n    }\n    return v;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeSet",
                "/**\n * Merges a list of LimitedSizeSet&lt;T&gt; objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param <T> (super)type of elements of the sets\n * @param max_values the maximum size for the returned LimitedSizeSet\n * @param slist a list of LimitedSizeSet, whose elements will be merged\n * @return a LimitedSizeSet that merges the elements of slist\n */\npublic static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist) {\n    LimitedSizeSet<T> result = new LimitedSizeSet<T>(max_values);\n    for (LimitedSizeSet<? extends T> s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "serialVersionUID",
                "plume",
                "FileIOException",
                "static final long serialVersionUID = 20050923L;"
            ],
            [
                "counter",
                "plume",
                "DeterministicObject",
                "/**\n * The number of objects created so far.\n */\nstatic int counter = 0;"
            ],
            [
                "home",
                "plume",
                "MultiVersionControl",
                "@Option(value = \"User home directory\", noDocDefault = true)\npublic static String home = System.getProperty(\"user.home\");"
            ],
            [
                "debug",
                "plume",
                "MultiVersionControl",
                "// It would be good to be able to set this per-checkout.\n// This variable is static because it is used in static methods.\n@Option(\"Print debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "idf",
                "plume",
                "MultiVersionControl",
                "static IsDirectoryFilter idf = new IsDirectoryFilter();"
            ],
            [
                "help",
                "plume",
                "Lookup",
                "/**\n * Show detailed help information and exit.\n */\n@OptionGroup(\"Getting help\")\n@Option(\"-h Show detailed help information\")\npublic static boolean help = false;"
            ],
            [
                "verbose",
                "plume",
                "Lookup",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "entry_file",
                "plume",
                "Lookup",
                "// This uses only the first file because the default search path might be\n// something like user:system and you might want only your version of the\n// system files.  It might be useful to also support (via another flag,\n// or by taking over this one, or by the syntax of the separator, or in\n// some other way) specifying multiple files on the command line.\n/**\n * Specify the colon-separated search list for the file that contains\n * information to be searched.  Only the first file found is used, though\n * it may itself contain include directives.\n */\n@OptionGroup(\"Where to search\")\n@Option(\"-f Specify the colon-separated search list of files of information; may only be supplied once\")\npublic static String entry_file = \"~/lookup/root\";"
            ],
            [
                "search_body",
                "plume",
                "Lookup",
                "/**\n * Search the body of long entries in addition to the entry's\n * description.  The bodies of short entries are always searched.\n */\n@Option(\"-b Search body of long entries for matches\")\npublic static boolean search_body = false;"
            ],
            [
                "regular_expressions",
                "plume",
                "Lookup",
                "/**\n * Specifies that keywords are regular expressions.  If false, keywords\n * are text matches.\n */\n@OptionGroup(\"What to search for\")\n@Option(\"-e Keywords are regular expressions\")\npublic static boolean regular_expressions = false;"
            ],
            [
                "case_sensitive",
                "plume",
                "Lookup",
                "/**\n * If true, keywords matching is case sensistive.  By default, both\n * regular expressions and text keywords are case-insensitive.\n */\n@Option(\"-c Keywords are case sensistive\")\npublic static boolean case_sensitive = false;"
            ],
            [
                "word_match",
                "plume",
                "Lookup",
                "/**\n * If true, match a text keyword only as a separate word, not as a\n * substring of a word.  This option is ignored if\n * regular_expressions is true.\n */\n@Option(\"-w Only match text keywords against complete words\")\npublic static boolean word_match = false;"
            ],
            [
                "print_all",
                "plume",
                "Lookup",
                "/**\n * By default, if multiple entries are matched, only a synopsis\n * of each entry is printed.  If 'print_all' is selected then\n * the body of each matching entry is printed.\n */\n@OptionGroup(\"How to print matches\")\n@Option(\"-a Print the entire entry for each match\")\npublic static boolean print_all = false;"
            ],
            [
                "item_num",
                "plume",
                "Lookup",
                "/**\n * Specifies which item to print when there are multiple matches.\n * The index is 1-based; that is, it starts counting at 1.\n */\n@Option(\"-i Choose a specific item when there are multiple matches; index is 1-based\")\npublic static Integer /*@Nullable*/\nitem_num;"
            ],
            [
                "show_location",
                "plume",
                "Lookup",
                "/**\n * If true, show the filename/line number of each matching entry\n * in the output.\n */\n@Option(\"-l Show the location of each matching entry\")\npublic static boolean show_location = false;"
            ],
            [
                "entry_start_re",
                "plume",
                "Lookup",
                "@OptionGroup(\"Customizing format of files to be searched\")\n@Option(\"Regex that denotes the start of a long entry\")\npublic static Pattern /*@Regex(1)*/\nentry_start_re = Pattern.compile(\"^>entry *()\");"
            ],
            [
                "entry_stop_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that denotes the end of a long entry\")\npublic static Pattern entry_stop_re = Pattern.compile(\"^<entry\");"
            ],
            [
                "description_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that finds an entry's description (for long entries)\")\npublic static Pattern /*@Nullable*/\ndescription_re = null;"
            ],
            [
                "comment_re",
                "plume",
                "Lookup",
                "// If \"\", gets set to null immediately after option processing.\n@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Nullable*/\n/*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "runtime",
                "plume",
                "FileCompiler",
                "/**\n * The Runtime of the JVM.\n */\npublic static Runtime runtime = java.lang.Runtime.getRuntime();"
            ],
            [
                "java_filename_pattern",
                "plume",
                "FileCompiler",
                "/**\n * Matches the names of Java source files.\n * Match group 1 is the complete filename.\n */\nstatic Pattern /*@Regex(1)*/\njava_filename_pattern;"
            ],
            [
                "responsible",
                "plume",
                "TaskManager",
                "// Command line options\n@Option(\"-r Include only those tasks assigned to the specified person\")\npublic static String /*@Nullable*/\nresponsible = null;"
            ],
            [
                "milestone",
                "plume",
                "TaskManager",
                "@Option(\"-m Include only those tasks required for the specified milestone\")\npublic static String /*@Nullable*/\nmilestone = null;"
            ],
            [
                "completed",
                "plume",
                "TaskManager",
                "@Option(\"-c Include only completed tasks\")\npublic static boolean completed = false;"
            ],
            [
                "open",
                "plume",
                "TaskManager",
                "@Option(\"-o Include only open tasks\")\npublic static boolean open = false;"
            ],
            [
                "verbose",
                "plume",
                "TaskManager",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "format",
                "plume",
                "TaskManager",
                "@Option(\"-f Specify output format\")\npublic static OutputFormat format = OutputFormat.short_ascii;"
            ],
            [
                "comment_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "lineSep",
                "plume",
                "TaskManager",
                "// line.separator property is a legal regex\n@SuppressWarnings(\"regex\")\npublic static final String /*@Regex*/\nlineSep = System.getProperty(\"line.separator\");"
            ],
            [
                "minversion",
                "plume",
                "ClassFileVersion",
                "/**\n * Only report versions that are at least this large.\n */\nstatic double minversion = 0;"
            ],
            [
                "debug",
                "plume",
                "DeclarationAnnotations",
                "static boolean debug = false;"
            ],
            [
                "date",
                "plume",
                "ICalAvailable",
                "/// User options\n@Option(\"first date to summarize\")\npublic static String date = \"today\";"
            ],
            [
                "start_date",
                "plume",
                "ICalAvailable",
                "public static DateTime start_date = new DateTime();"
            ],
            [
                "days",
                "plume",
                "ICalAvailable",
                "@Option(\"number of calendar days to summarize\")\npublic static int days = 8;"
            ],
            [
                "iCal_URL",
                "plume",
                "ICalAvailable",
                "/**\n * For a Google calendar:  go to settings, then click on the green \"ICAL\"\n * icon for the \"private address\".\n */\n@Option(\"<url> schedule in iCal format\")\npublic static List<String> iCal_URL = new ArrayList<String>();"
            ],
            [
                "business_hours",
                "plume",
                "ICalAvailable",
                "/**\n * A list of time ranges, expressed as a String.\n * Example: 9am-5pm,7:30pm-9:30pm\n */\n@Option(\"time ranges during which appointments are permitted\")\npublic static String business_hours = \"9am-5pm\";"
            ],
            [
                "businessHours",
                "plume",
                "ICalAvailable",
                "// initialize to 9am-5pm\nstatic List<Period> businessHours = new ArrayList<Period>();"
            ],
            [
                "businessDays",
                "plume",
                "ICalAvailable",
                "// initialize to Mon-Fri\nstatic List<Integer> businessDays = new ArrayList<Integer>();"
            ],
            [
                "tzRegistry",
                "plume",
                "ICalAvailable",
                "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();"
            ],
            [
                "timezone1",
                "plume",
                "ICalAvailable",
                "/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * Available times are printed in this time zone.  It defaults to the\n * system time zone.\n */\n// don't need \"e.g.: America/New_York\" in message:  the default is an example\n@Option(value = \"<timezone> time zone, e.g.: America/New_York\", noDocDefault = true)\npublic static String timezone1 = TimeZone.getDefault().getID();"
            ],
            [
                "tz1",
                "plume",
                "ICalAvailable",
                "// Either of these initializations causes a NullPointerException\n// at net.fortuna.ical4j.model.TimeZone.<init>(TimeZone.java:67)\n// static TimeZone tz1 = new TimeZone(new VTimeZone());\n// static TimeZone tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));\nstatic TimeZone /*@MonotonicNonNull*/\ntz1;"
            ],
            [
                "timezone2",
                "plume",
                "ICalAvailable",
                "// If I'm outputting in a different timezone, then my notion of a \"day\"\n// may be different than the other timezone's notion of a \"day\".  This\n// doesn't seem important enough to fix right now.\n/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * If set, then free times are printed in two time zones.\n */\n@Option(\"<timezone> optional second time zone, e.g.: America/New_York\")\npublic static String /*@Nullable*/\ntimezone2;"
            ],
            [
                "tz2",
                "plume",
                "ICalAvailable",
                "static TimeZone /*@Nullable*/\ntz2;"
            ],
            [
                "debug",
                "plume",
                "ICalAvailable",
                "/// Other variables\n@Option(\"enable debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "calendars",
                "plume",
                "ICalAvailable",
                "/**\n * The appointments (the times that are unavailable for a meeting).\n */\nstatic List<Calendar> calendars = new ArrayList<Calendar>();"
            ],
            [
                "tf",
                "plume",
                "ICalAvailable",
                "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);"
            ],
            [
                "df",
                "plume",
                "ICalAvailable",
                "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);"
            ],
            [
                "dffull",
                "plume",
                "ICalAvailable",
                "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);"
            ],
            [
                "canonicalTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> canonicalTimezones = new HashMap<String, String>();"
            ],
            [
                "printedTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> printedTimezones = new HashMap<String, String>();"
            ],
            [
                "timeRegexp",
                "plume",
                "ICalAvailable",
                "static Pattern /*@Regex(4)*/\ntimeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");"
            ],
            [
                "dateFormats",
                "plume",
                "ICalAvailable",
                "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};"
            ],
            [
                "skip_checks",
                "plume",
                "BCELUtil",
                "/**\n * Controls whether the checks in checkMgen are actually performed.\n */\npublic static boolean skip_checks = false;"
            ],
            [
                "userHome",
                "plume",
                "UtilMDE",
                "static final String userHome = System.getProperty(\"user.home\");"
            ],
            [
                "args_seen",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Method\n///\n/**\n * Maps from a comma-delimited string of arg types, such as appears in a\n * method signature, to an array of Class objects, one for each arg\n * type. Example keys include: \"java.lang.String, java.lang.String,\n * java.lang.Class[]\" and \"int,int\".\n */\nstatic HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();"
            ],
            [
                "serialVersionUID",
                "plume",
                "UtilMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "NullableStringComparator",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeIntSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "split_lists",
                "plume",
                "Options",
                "/**\n * When true, an argument to a option of list type is split, on\n * whitespace, into multiple arguments each of which is added to the\n * list.  When false, each argument to an option of list type is treated\n * as a single element, no matter what characters it contains.\n */\n@Option(\"Treat arguments to lists as space-separated.\")\npublic static boolean split_lists = false;"
            ],
            [
                "serialVersionUID",
                "plume",
                "Options",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArgException",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "StringArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "short_run",
                "plume",
                "TestPlume",
                "// If true, do 100 instead of 100000 iterations when testing randomElements.\n// This saves only a little time.  However, it is significant when running\n// under instrumentation such as that of Chicory.\nstatic boolean short_run = false;"
            ],
            [
                "mass",
                "plume",
                "TestPlume",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestPlume",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestPlume",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "mass",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestOptionGroups1",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups2",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups3",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "FuzzyFloat",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "x",
                "",
                "long"
            ],
            [
                "y",
                "",
                "long"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 10054,
        "oracle": ";",
        "oracleType": "NORMAL_POST",
        "projectName": "plume-lib-1.1.0",
        "packageName": "plume",
        "className": "MathMDE",
        "javadocTag": "@return base to the expt power",
        "methodJavadoc": "    /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */",
        "methodSourceCode": "public static int pow(int base, int expt) throws ArithmeticException{\n    return pow_fast(base, expt);\n}",
        "classJavadoc": "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
        "classSourceCode": "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "FileIOException",
                "plume"
            ],
            [
                "MathMDE",
                "plume"
            ],
            [
                "DeterministicObject",
                "plume"
            ],
            [
                "Digest",
                "plume"
            ],
            [
                "StringBuilderDelimited",
                "plume"
            ],
            [
                "OrderedPairIterator",
                "plume"
            ],
            [
                "CountingPrintWriter",
                "plume"
            ],
            [
                "MultiVersionControl",
                "plume"
            ],
            [
                "WeakIdentityHashMap",
                "plume"
            ],
            [
                "IterableIterator",
                "plume"
            ],
            [
                "Lookup",
                "plume"
            ],
            [
                "Pair",
                "plume"
            ],
            [
                "FileCompiler",
                "plume"
            ],
            [
                "MultiRandSelector",
                "plume"
            ],
            [
                "RandoopMappedCalls",
                "plume"
            ],
            [
                "Stopwatch",
                "plume"
            ],
            [
                "TaskManager",
                "plume"
            ],
            [
                "WeakHasherMap",
                "plume"
            ],
            [
                "ClassFileVersion",
                "plume"
            ],
            [
                "WeakIdentityPair",
                "plume"
            ],
            [
                "OptionsDoclet",
                "plume"
            ],
            [
                "DeclarationAnnotations",
                "plume"
            ],
            [
                "Option",
                "plume"
            ],
            [
                "RegexUtil",
                "plume"
            ],
            [
                "JWhich",
                "plume"
            ],
            [
                "TimeLimitProcess",
                "plume"
            ],
            [
                "Intern",
                "plume"
            ],
            [
                "GraphMDE",
                "plume"
            ],
            [
                "HtmlPrettyPrint",
                "plume"
            ],
            [
                "SimpleLog",
                "plume"
            ],
            [
                "OptionGroup",
                "plume"
            ],
            [
                "ICalAvailable",
                "plume"
            ],
            [
                "RandomSelector",
                "plume"
            ],
            [
                "BCELUtil",
                "plume"
            ],
            [
                "UtilMDE",
                "plume"
            ],
            [
                "Hasher",
                "plume"
            ],
            [
                "BibtexClean",
                "plume"
            ],
            [
                "LimitedSizeIntSet",
                "plume"
            ],
            [
                "Partitioner",
                "plume"
            ],
            [
                "Triple",
                "plume"
            ],
            [
                "Options",
                "plume"
            ],
            [
                "ArraysMDE",
                "plume"
            ],
            [
                "StrTok",
                "plume"
            ],
            [
                "Unpublicized",
                "plume"
            ],
            [
                "TestPlume",
                "plume"
            ],
            [
                "LimitedSizeSet",
                "plume"
            ],
            [
                "EntryReader",
                "plume"
            ],
            [
                "Filter",
                "plume"
            ],
            [
                "FuzzyFloat",
                "plume"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "negate",
                "plume",
                "MathMDE",
                "///\n/// Function versions of Java operators\n///\n/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static int negate(int a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static long negate(long a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static double negate(double a) {\n    return -a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static int bitwiseComplement(int a) {\n    return ~a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static long bitwiseComplement(long a) {\n    return ~a;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static int mul(int x, int y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static long mul(long x, long y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static double mul(double x, double y) {\n    return x * y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static int div(int x, int y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static long div(long x, long y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static double div(double x, double y) {\n    return x / y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static int mod(int x, int y) {\n    return x % y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static long mod(long x, long y) {\n    return x % y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static int lshift(int x, int y) {\n    return x << y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static long lshift(long x, long y) {\n    return x << y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static int rshiftSigned(int x, int y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static long rshiftSigned(long x, long y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static int bitwiseAnd(int x, int y) {\n    return x & y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static long bitwiseAnd(long x, long y) {\n    return x & y;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static int logicalAnd(int x, int y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static long logicalAnd(long x, long y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static int bitwiseXor(int x, int y) {\n    return x ^ y;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static long bitwiseXor(long x, long y) {\n    return x ^ y;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static int logicalXor(int x, int y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static long logicalXor(long x, long y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static int bitwiseOr(int x, int y) {\n    return x | y;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static long bitwiseOr(long x, long y) {\n    return x | y;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static int logicalOr(int x, int y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static long logicalOr(long x, long y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "sign",
                "plume",
                "MathMDE",
                "///\n/// sign\n///\n/**\n * Returns the sign of its argument.  The result is always -1, 0, or 1.\n * @param a value to have its sign taken\n * @return the sign of a: -1, 0, or 1\n */\npublic static int sign(int a) {\n    if (a == 0) {\n        return 0;\n    } else if (a > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "///\n/// exponentiation\n///\n/**\n * Returns of value of the first argument raised to the\n * power of the second argument.  The arguments are integers.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "/**\n * Returns of value of the first argument raised to the\n * power of the second argument.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "///\n/// gcd\n///\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static int gcd(int a, int b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        int tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/// gcd -- version for manipulating long (rather than int) values\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static long gcd(long a, long b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static double gcd(double a, double b) {\n    if (a == Double.POSITIVE_INFINITY || a == Double.NEGATIVE_INFINITY || Double.isNaN(a) || b == Double.POSITIVE_INFINITY || b == Double.NEGATIVE_INFINITY || Double.isNaN(b)) {\n        return Double.NaN;\n    }\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        double tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "///\n/// Modulus\n///\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nint mod_positive(int x, /*@PolyUpperBound*/\nint y) {\n    int result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static int[] modulus(int[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new int[] { remainder, modulus };\n}"
            ],
            [
                "modulus_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(int[])\n */\npublic static int[] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static int[] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    int modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(int[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().intValue();\n    }\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().intValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "/// modulus for long (as opposed to int) values\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nlong mod_positive(long x, /*@PolyUpperBound*/\nlong y) {\n    long result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static long[] modulus(long[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new long[] { remainder, modulus };\n}"
            ],
            [
                "modulus_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(long[])\n */\npublic static long[] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        long i = itor.next().longValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static long[] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    long modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(long[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().longValue();\n    }\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().longValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "///\n/// Non-Modulus\n///\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] missing_numbers(int[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length - 1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static int[] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   int range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2);\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = mod_positive(nums[i], m);\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new int[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "/// non-modulus for long (as opposed to int) values\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] missing_numbers(long[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length - 1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static long[] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   long range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2)));\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = ((int) (mod_positive(nums[i], m)));\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new long[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "getFileDigest",
                "plume",
                "Digest",
                "/**\n * This convenience method is used by both create() and verify().  It\n * reads the contents of a named file and computes a message digest\n * for it, using the specified MessageDigest object.\n * @param filename the file to read\n * @param md the MessageDigest\n * @return the message digest\n * @throws IOException if there is a problem reading the file\n */\npublic static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    // Read to the end of the file, discarding everything we read. {\n    // The DigestInputStream automatically passes all the bytes read to\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) {\n        /* do nothing */\n    }\n    // Finally, compute and return the digest value.\n    byte[] result = md.digest();\n    in.close();\n    return result;\n}"
            ],
            [
                "hexEncode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert an array of bytes to a String.  We do\n * this simply by converting each byte to two hexadecimal digits.  Something\n * like Base 64 encoding is more compact, but harder to encode.\n * @param bytes the bytes to convert to a String\n * @return a String representation of the input bytes\n */\npublic static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}"
            ],
            [
                "hexDecode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert from a string\n * of hexadecimal digits to an array of bytes.\n * This method is the reverse of {@link #hexEncode(byte[])}.\n * @param s the String to convert to an array of bytes\n * @return the bytes equivalent to the input String\n */\npublic static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9')) {\n                digit1 -= '0';\n            } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n                digit1 -= 'a' - 10;\n            }\n            if ((digit2 >= '0') && (digit2 <= '9')) {\n                digit2 -= '0';\n            } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n                digit2 -= 'a' - 10;\n            }\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}"
            ],
            [
                "dirToCheckoutHg",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".hg\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutHg(File hgDir, File dir) {\n    String repository = null;\n    File hgrcFile = new File(hgDir, \"hgrc\");\n    Ini ini;\n    // There also exist Hg commands that will do this same thing.\n    if (hgrcFile.exists()) {\n        try {\n            ini = new Ini(new FileReader(hgrcFile));\n        } catch (IOException e) {\n            throw new Error(\"Problem reading file \" + hgrcFile);\n        }\n        Ini.Section pathsSection = ini.get(\"paths\");\n        if (pathsSection != null) {\n            repository = pathsSection.get(\"default\");\n            if (repository != null && repository.endsWith(\"/\")) {\n                repository = repository.substring(0, repository.length() - 1);\n            }\n        }\n    }\n    return new Checkout(RepoType.HG, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutGit",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".git\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutGit(File gitDir, File dir) {\n    String repository = UtilMDE.backticks(\"git\", \"config\", \"remote.origin.url\");\n    return new Checkout(RepoType.GIT, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutSvn",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory that contains a .svn subdirectory, create a\n * corresponding Checkout object.\n * Returns null if this is not possible.\n */\nstatic /*@Nullable*/\nCheckout dirToCheckoutSvn(File dir) {\n    // For SVN, do\n    //   svn info\n    // and grep out these lines:\n    //   URL: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository/trunk/www\n    //   Repository Root: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository\n    // Use SVNKit?\n    // Con: introduces dependency on external library.\n    // Pro: no need to re-implement or to call external process (which\n    //   might be slow for large checkouts).\n    // unannotated library: SVNKit\n    @SuppressWarnings(\"nullness\")\n    SVNWCClient wcClient = new SVNWCClient((/*@Nullable*/\n    ISVNAuthenticationManager) null, null);\n    SVNInfo info;\n    try {\n        info = wcClient.doInfo(new File(dir.toString()), SVNRevision.WORKING);\n    } catch (SVNException e) {\n        // throw new Error(\"Problem in dirToCheckoutSvn(\" + dir + \"): \", e);\n        System.err.println(\"Problem in dirToCheckoutSvn(\" + dir + \"): \" + e.getMessage());\n        if (e.getMessage() != null && e.getMessage().contains(\"This client is too old\")) {\n            System.err.println(\"plume-lib needs a newer version of SVNKit.\");\n        }\n        return null;\n    }\n    // getFile is null when operating on a working copy, as I am\n    // String relativeFile = info.getPath(); // relative to repository root -- can use to determine root of checkout\n    // getFile is just the (absolute) local file name for local items -- same as \"dir\"\n    // File relativeFile = info.getFile();\n    SVNURL url = info.getURL();\n    // This can be null (example: dir /afs/csail.mit.edu/u/m/mernst/.snapshot/class/6170/2006-spring/3dphysics).  I don't know under what circumstances.\n    SVNURL repoRoot = info.getRepositoryRootURL();\n    if (repoRoot == null) {\n        System.err.println(\"Problem:  old svn working copy in \" + dir.toString());\n        System.err.println(\"Check it out again to get a 'Repository Root' entry in the svn info output.\");\n        System.err.println(\"  repoUrl = \" + url);\n        System.exit(2);\n    }\n    if (debug) {\n        System.out.println();\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"     dir = \" + dir.toString());\n    }\n    // Strip common suffix off of local dir and repo url.\n    Pair<File, File> /*@Nullable*/\n    /*@Nullable*/\n    stripped = removeCommonSuffixDirs(dir, new File(url.getPath()), new File(repoRoot.getPath()), \".svn\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n        System.out.printf(\"dir (%s) is parent of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    if (stripped.b == null) {\n        System.out.printf(\"dir (%s) is child of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    String pathInRepoAtCheckout = stripped.b.toString();\n    try {\n        url = url.setPath(pathInRepoAtCheckout, false);\n    } catch (SVNException e) {\n        throw new Error(e);\n    }\n    if (debug) {\n        System.out.println(\"stripped: \" + stripped);\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"    cDir = \" + cDir.toString());\n    }\n    assert url.toString().startsWith(repoRoot.toString()) : \"repoRoot=\" + repoRoot + \", url=\" + url;\n    return new Checkout(RepoType.SVN, cDir, url.toString(), null);\n    /// Old implementation\n    // String module = url.toString().substring(repoRoot.toString().length());\n    // if (module.startsWith(\"/\")) {\n    //   module = module.substring(1);\n    // }\n    // if (module.equals(\"\")) {\n    //   module = null;\n    // }\n    // return new Checkout(RepoType.SVN, cDir, repoRoot.toString(), module);\n}"
            ],
            [
                "removeCommonSuffixDirs",
                "plume",
                "MultiVersionControl",
                "/**\n * Strip identical elements off the end of both paths, and then return\n * what is left of each.  Returned elements can be null!  If p2_limit is\n * non-null, then it should be a parent of p2, and the stripping stops\n * when p2 becomes p2_limit.  If p1_contains is non-null, then p1 must\n * contain a subdirectory of that name.\n */\nstatic Pair</*@Nullable*/\nFile, /*@Nullable*/\nFile> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains) {\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\", p1, p2, p2_limit, p1_contains);\n    }\n    // new names for results, because we will be side-effecting them\n    File r1 = p1;\n    File r2 = p2;\n    while (r1 != null && r2 != null && (p2_limit == null || !r2.equals(p2_limit)) && r1.getName().equals(r2.getName())) {\n        if (p1_contains != null && !new File(r1.getParentFile(), p1_contains).isDirectory()) {\n            break;\n        }\n        r1 = r1.getParentFile();\n        r2 = r2.getParentFile();\n    }\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs => %s %s%n\", r1, r2);\n    }\n    return Pair.of(r1, r2);\n}"
            ],
            [
                "eq",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Check for equality of non-null reference x and possibly-null y.  Uses\n * identity equality.\n */\n/*@Pure*/\nstatic boolean eq(Object x, /*@Nullable*/\nObject y) {\n    return x == y;\n}"
            ],
            [
                "hasher",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return the hash code for x\n */\n/*@Pure*/\nstatic int hasher(Object x) {\n    return System.identityHashCode(x);\n}"
            ],
            [
                "indexFor",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return index for hash code h.\n */\n/*@Pure*/\nstatic int indexFor(int h, int length) {\n    return h & (length - 1);\n}"
            ],
            [
                "old_get_entry",
                "plume",
                "Lookup",
                "/**\n * Returns the next entry.  If no more entries are available, returns null.\n * @param reader where to read the entry from\n * @return the next entry, or null\n * @throws IOException if there is a problem reading a file\n */\npublic static /*@Nullable*/\nEntry old_get_entry(EntryReader reader) throws IOException {\n    try {\n        // Skip any preceeding blank lines\n        String line = reader.readLine();\n        while ((line != null) && (line.trim().length() == 0)) {\n            line = reader.readLine();\n        }\n        if (line == null) {\n            return (null);\n        }\n        Entry entry = null;\n        String filename = reader.getFileName();\n        long line_number = reader.getLineNumber();\n        // If this is a long entry\n        if (line.startsWith(\">entry\")) {\n            // Get the current filename\n            String current_filename = reader.getFileName();\n            // Remove '>entry' from the line\n            line = line.replaceFirst(\"^>entry *\", \"\");\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find the termination of the entry\n            while ((line != null) && !line.startsWith(\">entry\") && !line.equals(\"<entry\") && current_filename.equals(reader.getFileName())) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            // If this entry was terminated by the start of the next one,\n            // put that line back\n            if ((line != null) && (line.startsWith(\">entry\") || !current_filename.equals(reader.getFileName()))) {\n                reader.putback(line);\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, false);\n        } else {\n            // blank separated entry\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find another blank line\n            while ((line != null) && (line.trim().length() != 0)) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, true);\n        }\n        return (entry);\n    } catch (FileNotFoundException e) {\n        System.out.printf(\"Error: Can't read %s at line %d in file %s%n\", e.getMessage(), reader.getLineNumber(), reader.getFileName());\n        System.exit(254);\n        return (null);\n    }\n}"
            ],
            [
                "first_line",
                "plume",
                "Lookup",
                "/**\n * Returns the first line of entry.\n * @param entry the entry whose first line to return\n * @return the first line of entry\n */\npublic static String first_line(String entry) {\n    int ii = entry.indexOf(lineSep);\n    if (ii == -1) {\n        return entry;\n    }\n    return entry.substring(0, ii);\n}"
            ],
            [
                "of",
                "plume",
                "Pair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a pair of the values (a, b)\n */\npublic static <A extends /*@Nullable*/\nObject, B extends /*@Nullable*/\nObject> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "short_str",
                "plume",
                "TaskManager",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "short_str",
                "plume",
                "Task",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "versionNumbers",
                "plume",
                "ClassFileVersion",
                "/**\n * Return an array of the major vernios, minor version, and JDK version\n * of the class read from the input stream.\n * Return null if there is an error or the input isn't a class file.\n * @param is input stream from which to read a class\n * @return array of three version numbers\n */\npublic static double[] versionNumbers(InputStream is) {\n    try {\n        DataInputStream dis = new DataInputStream(is);\n        int magic = dis.readInt();\n        if (magic != 0xcafebabe) {\n            return null;\n        }\n        double minor = dis.readShort();\n        double major = dis.readShort();\n        double jdkVersion;\n        if (major < 48) {\n            // really 1.3.1\n            jdkVersion = 1.3;\n        } else if (major == 48) {\n            // really 1.4.2\n            jdkVersion = 1.4;\n        } else if (major == 49) {\n            jdkVersion = 1.5;\n        } else if (major == 50) {\n            jdkVersion = 6;\n        } else {\n            jdkVersion = 7;\n        }\n        return new double[] { major, minor, jdkVersion };\n    } catch (IOException e) {\n        return null;\n    }\n}"
            ],
            [
                "of",
                "plume",
                "WeakIdentityPair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a WeakIdentityPair of (a, b)\n */\npublic static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b) {\n    return new WeakIdentityPair<A, B>(a, b);\n}"
            ],
            [
                "start",
                "plume",
                "OptionsDoclet",
                "// Doclet-specific methods\n/**\n * Entry point for the doclet.\n * @param root the root document\n * @return true if processing completed without an error\n */\npublic static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n        // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n        // returns a fully qualified name.  I do not know a good way to convert\n        // between these two name formats.  For now, we simply ignore inner\n        // classes.  This limitation can be removed when we figure out a better\n        // way to go from ClassDoc to Class<?>.\n        if (doc.containingClass() != null) {\n            continue;\n        }\n        Class<?> clazz;\n        try {\n            // Javadoc source code is not yet annotated\n            @SuppressWarnings(\"signature\")\n            String /*@BinaryNameForNonArray*/\n            className = doc.qualifiedName();\n            clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        }\n        if (needsInstantiation(clazz)) {\n            try {\n                Constructor<?> c = clazz.getDeclaredConstructor();\n                c.setAccessible(true);\n                objs.add(c.newInstance(new Object[0]));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            objs.add(clazz);\n        }\n    }\n    if (objs.isEmpty()) {\n        System.out.println(\"Error: no classes found\");\n        return false;\n    }\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n        System.out.println(\"Error: no @Option-annotated fields found\");\n        return false;\n    }\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n        o.write();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "optionLength",
                "plume",
                "OptionsDoclet",
                "/**\n * Given a command-line option of this doclet, returns the number of\n * arguments you must specify on the command line for the given option.\n * Returns 0 if the argument is not recognized.  This method is\n * automatically invoked.\n *\n * @param option the command-line option\n * @return the number of command-line arguments needed when using the option\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n        System.out.printf(USAGE);\n        return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n        return 1;\n    }\n    if (option.equals(\"-docfile\") || option.equals(\"-outfile\") || option.equals(\"-format\") || option.equals(\"-d\")) {\n        return 2;\n    }\n    return 0;\n}"
            ],
            [
                "validOptions",
                "plume",
                "OptionsDoclet",
                "/**\n * Tests the validity of command-line arguments passed to this doclet.\n * Returns true if the option usage is valid, and false otherwise.  This\n * method is automatically invoked.\n *\n * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n * @param reporter where to report errors\n * @return true iff the command-line options are valid\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            if (hasDocFile) {\n                reporter.printError(\"-docfile option specified twice\");\n                return false;\n            }\n            File f = new File(os[1]);\n            if (!f.exists()) {\n                reporter.printError(\"-docfile file not found: \" + os[1]);\n                return false;\n            }\n            docFile = os[1];\n            hasDocFile = true;\n        }\n        if (opt.equals(\"-outfile\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-outfile option specified twice\");\n                return false;\n            }\n            if (inPlace) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            outFile = os[1];\n            hasOutFile = true;\n        }\n        if (opt.equals(\"-i\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            inPlace = true;\n        }\n        if (opt.equals(\"-format\")) {\n            if (hasFormat) {\n                reporter.printError(\"-format option specified twice\");\n                return false;\n            }\n            if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n                reporter.printError(\"unrecognized output format: \" + os[1]);\n                return false;\n            }\n            hasFormat = true;\n        }\n        if (opt.equals(\"-d\")) {\n            if (hasDestDir) {\n                reporter.printError(\"-d specified twice\");\n                return false;\n            }\n            hasDestDir = true;\n        }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n        reporter.printError(\"docfile must be different from outfile\");\n        return false;\n    }\n    if (inPlace && docFile == null) {\n        reporter.printError(\"-i supplied but -docfile was not\");\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "javadocToHtml",
                "plume",
                "OptionsDoclet",
                "/**\n * Replace the @link tags and block @see tags in a Javadoc comment with\n * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n * comment while still being presentable. <p>\n *\n * This is only a temporary solution.  Ideally, @link/@see tags would be\n * converted to HTML links that point to actual documentation.\n *\n * @param doc a Javadoc comment to convert to HTML\n * @return HTML version of doc\n */\npublic static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n        if (tag instanceof SeeTag) {\n            b.append(\"<code>\" + tag.text() + \"</code>\");\n        } else {\n            b.append(tag.text());\n        }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n        b.append(\" See: \");\n        {\n            StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n            for (SeeTag tag : seetags) {\n                bb.append(\"<code>\" + tag.text() + \"</code>\");\n            }\n            b.append(bb);\n        }\n        b.append(\".\");\n    }\n    return b.toString();\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param s string to check for being a regular expression\n * @return true iff s is a regular expression\n */\n/*@Pure*/\n/*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\npublic static boolean isRegex(String s) {\n    return isRegex(s, 0);\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression with at least the given number of groups.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return true iff s is a regular expression with groups groups\n */\n// RegexUtil; for purity, catches an exception\n@SuppressWarnings({ \"regex\", \"deterministic\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(String s, int groups) {\n    Pattern p;\n    try {\n        p = Pattern.compile(s);\n    } catch (PatternSyntaxException e) {\n        return false;\n    }\n    return getGroupCount(p) >= groups;\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param c char to check for being a regular expression\n * @return true iff c is a regular expression\n */\n@SuppressWarnings({ \"regex\", \"purity.not.deterministic.call\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(char c) {\n    return isRegex(Character.toString(c));\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a string describing why the argument is\n * not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nString regexError(String s) {\n    return regexError(s, 0);\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns\n * a string describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil;\n@SuppressWarnings({ \"regex\", \"not.sef\" })\npublic static /*@Nullable*/\nString regexError(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return regexErrorMessage(s, groups, actualGroups);\n        }\n    } catch (PatternSyntaxException e) {\n        return e.getMessage();\n    }\n    return null;\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a PatternSyntaxException describing\n * why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s) {\n    return regexException(s, 0);\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns a\n * PatternSyntaxException describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return new PatternSyntaxException(regexErrorMessage(s, groups, actualGroups), s, -1);\n        }\n    } catch (PatternSyntaxException pse) {\n        return pse;\n    }\n    return null;\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex String} if it is a regex,\n * otherwise throws an error. The purpose of this method is to suppress Regex\n * Checker warnings. It should be very rarely needed.\n * @param s string to check for being a regular expression\n * @return its argument\n * @throws Error if argument is not a regex\n */\n/*@SideEffectFree*/\n// The return type annotation is a conservative bound.\npublic static /*@Regex*/\nString asRegex(String s) {\n    return asRegex(s, 0);\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex(groups) String} if it is a regex\n * with at least the given number of groups, otherwise throws an error. The\n * purpose of this method is to suppress Regex Checker warnings. It should\n * be very rarely needed.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return its argument\n * @throws Error if argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Regex*/\nString asRegex(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            throw new Error(regexErrorMessage(s, groups, actualGroups));\n        }\n        return s;\n    } catch (PatternSyntaxException e) {\n        throw new Error(e);\n    }\n}"
            ],
            [
                "findClass",
                "plume",
                "JWhich",
                "/**\n * Returns the URL of the resource denoted by the specified\n * class name, as prescribed by the class path.\n *\n * @param className name of the class\n * @return class URL, or null of the class was not found\n */\npublic static /*@Nullable*/\nURL findClass(final String className) {\n    return JWhich.class.getResource(asResourceName(className));\n}"
            ],
            [
                "asResourceName",
                "plume",
                "JWhich",
                "protected static String asResourceName(String resource) {\n    if (!resource.startsWith(\"/\")) {\n        resource = \"/\" + resource;\n    }\n    resource = resource.replace('.', '/');\n    resource = resource + \".class\";\n    return resource;\n}"
            ],
            [
                "getClasspath",
                "plume",
                "JWhich",
                "/**\n * Return the classpath.\n * @return the classpath\n */\n/*@EnsuresNonNull(\"CLASSPATH\")*/\nprotected static String getClasspath() {\n    if (CLASSPATH == null) {\n        String classpath = System.getProperty(\"java.class.path\");\n        setClasspath(classpath);\n    }\n    return CLASSPATH;\n}"
            ],
            [
                "internStrings",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Strings\n///\n/**\n * Replace each element of the array by its interned version.\n * Side-effects the array, but also returns it.\n * @param a the array whose elements to intern in place\n * @return an interned version of a\n * @see String#intern\n */\n// side-effects the array in place (dangerous, but convenient)\n@SuppressWarnings(\"interning\")\npublic static String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] != null) {\n            a[i] = a[i].intern();\n        }\n    }\n    return a;\n}"
            ],
            [
                "isInterned",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Testing interning\n///\n/**\n * Return true if the argument is interned (is canonical among all\n * objects equal to itself).\n * @param value the value to test for interning\n * @return true iff value is interned\n */\n// interning implementation\n@SuppressWarnings(\"interning\")\npublic static /*@Pure*/\nboolean isInterned(/*@Nullable*/\nObject value) {\n    if (value == null) {\n        // nothing to do\n        return true;\n    } else if (value instanceof String) {\n        return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n        return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n        return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n        return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n        return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n        return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n        return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n        return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n        return (value == intern((Object[]) value));\n    } else {\n        // Nothing to do, because we don't intern other types.\n        // System.out.println(\"What type? \" + value.getClass().getName());\n        return true;\n    }\n}"
            ],
            [
                "numIntegers",
                "plume",
                "Intern",
                "// For testing only\npublic static int numIntegers() {\n    return internedIntegers.size();\n}"
            ],
            [
                "numLongs",
                "plume",
                "Intern",
                "public static int numLongs() {\n    return internedLongs.size();\n}"
            ],
            [
                "numIntArrays",
                "plume",
                "Intern",
                "public static int numIntArrays() {\n    return internedIntArrays.size();\n}"
            ],
            [
                "numLongArrays",
                "plume",
                "Intern",
                "public static int numLongArrays() {\n    return internedLongArrays.size();\n}"
            ],
            [
                "numDoubles",
                "plume",
                "Intern",
                "public static int numDoubles() {\n    return internedDoubles.size();\n}"
            ],
            [
                "numDoubleArrays",
                "plume",
                "Intern",
                "public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n}"
            ],
            [
                "numStringArrays",
                "plume",
                "Intern",
                "public static int numStringArrays() {\n    return internedStringArrays.size();\n}"
            ],
            [
                "numObjectArrays",
                "plume",
                "Intern",
                "public static int numObjectArrays() {\n    return internedObjectArrays.size();\n}"
            ],
            [
                "integers",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nInteger> integers() {\n    return internedIntegers.keySet().iterator();\n}"
            ],
            [
                "longs",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nLong> longs() {\n    return internedLongs.keySet().iterator();\n}"
            ],
            [
                "intArrays",
                "plume",
                "Intern",
                "public static Iterator<int[]> intArrays() {\n    return internedIntArrays.keySet().iterator();\n}"
            ],
            [
                "longArrays",
                "plume",
                "Intern",
                "public static Iterator<long[]> longArrays() {\n    return internedLongArrays.keySet().iterator();\n}"
            ],
            [
                "doubles",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nDouble> doubles() {\n    return internedDoubles.keySet().iterator();\n}"
            ],
            [
                "doubleArrays",
                "plume",
                "Intern",
                "public static Iterator<double[]> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n}"
            ],
            [
                "stringArrays",
                "plume",
                "Intern",
                "public static Iterator<String[]> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n}"
            ],
            [
                "objectArrays",
                "plume",
                "Intern",
                "public static Iterator<Object[]> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a String.\n * Delegates to the builtin String.intern() method.\n * Provided for completeness.\n * @param a the string to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static /*@Interned*/\n/*@PolyNull*/\nString intern(/*@PolyNull*/\nString a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n        return null;\n    }\n    return a.intern();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a long.\n * A no-op.  Provided for completeness.\n * @param l the long to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static long intern(long l) {\n    return l;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a double\n * A no-op.  Provided for completeness.\n * @param d the double to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static double intern(double d) {\n    return d;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Integer.\n * Return a canonical representation for the Integer.\n * @param a an Integer to canonicalize\n * @return a canonical representation for the Integer\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Intern.valueOf is intended to promise\n// the same).  This does not currently take advantage of that.\n// interning implementation\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nInteger intern(Integer a) {\n    WeakReference<Integer> /*@Interned*/\n    lookup = internedIntegers.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Integer /*@Interned*/\n        result = (/*@Interned*/\n        Integer) a;\n        internedIntegers.put(result, new WeakReference</*@Interned*/\n        Integer>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nInteger internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value parsed from the string.\n * @param s the string to parse\n * @return an interned Integer parsed from s\n */\npublic static /*@Interned*/\nInteger internedInteger(String s) {\n    return intern(Integer.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Long.\n * Return a canonical representation for the Long.\n * @param a the value to intern\n * @return a canonical representation for the Long\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Long.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nLong intern(Long a) {\n    WeakReference<Long> /*@Interned*/\n    lookup = internedLongs.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Long /*@Interned*/\n        result = (/*@Interned*/\n        Long) a;\n        internedLongs.put(result, new WeakReference</*@Interned*/\n        Long>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nLong internedLong(long i) {\n    return intern(Long.valueOf(i));\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value parsed from the string.\n * @param s the string to parse\n * @return an interned Long parsed from s\n */\npublic static /*@Interned*/\nLong internedLong(String s) {\n    return intern(Long.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) an int[].\n * Return a canonical representation for the int[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the int[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static int[] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        int[] /*@Interned*/\n        result = (int[]) a;\n        internedIntArrays.put(result, new WeakReference<int[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a long[].\n * Return a canonical representation for the long[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the long[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static long[] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        long[] /*@Interned*/\n        result = (long[]) a;\n        internedLongArrays.put(result, new WeakReference<long[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Double.\n * Return a canonical representation for the Double.\n * @param a the Double to canonicalize\n * @return a canonical representation for the Double\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Double.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nDouble intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n        return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) {\n        // catches both positive and negative zero\n        return internedDoubleZero;\n    }\n    WeakReference<Double> /*@Interned*/\n    lookup = internedDoubles.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Double /*@Interned*/\n        result = (/*@Interned*/\n        Double) a;\n        internedDoubles.put(result, new WeakReference</*@Interned*/\n        Double>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value i.\n * @param d the value to intern\n * @return an interned Double with value d\n */\npublic static /*@Interned*/\nDouble internedDouble(double d) {\n    return intern(Double.valueOf(d));\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value parsed from the string.\n * @param s the string to parse\n * @return an interned Double parsed from s\n */\npublic static /*@Interned*/\nDouble internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) a double[].\n * Return a canonical representation for the double[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the double[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static double[] intern(double[] a) {\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        double[] /*@Interned*/\n        result = (double[]) a;\n        internedDoubleArrays.put(result, new WeakReference<double[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an String[].\n * Return a canonical representation for the String[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the String[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static String[] intern(/*@PolyNull*/\n/*@Interned*/\nString[] a) {\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n        assert a[k] == Intern.intern(a[k]);\n    }\n    WeakReference<String[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    String[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (String[]) a;\n        internedStringArrays.put(result, new WeakReference<String[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    String[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Object[].\n * Return a canonical representation for the Object[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the Object[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static Object[] intern(/*@PolyNull*/\n/*@Interned*/\nObject[] a) {\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    WeakReference<Object[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    Object[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (Object[]) a;\n        internedObjectArrays.put(result, new WeakReference<Object[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    Object[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Convenince method to intern an Object when we don't know its\n * runtime type.  Its runtime type must be one of the types for\n * which we have an intern() method, else an exception is thrown.\n * If the argument is an array, its elements should themselves be\n * interned.\n * @param a an Object to canonicalize\n * @return a canonical version of a\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Interned*/\n/*@PolyNull*/\nObject intern(/*@PolyNull*/\nObject a) {\n    if (a == null) {\n        return null;\n    } else if (a instanceof String) {\n        return intern((String) a);\n    } else if (a instanceof String[]) {\n        @SuppressWarnings(\"interning\")\n        String[] /*@Interned*/\n        asArray = (String[]) a;\n        return intern(asArray);\n    } else if (a instanceof Integer) {\n        return intern((Integer) a);\n    } else if (a instanceof Long) {\n        return intern((Long) a);\n    } else if (a instanceof int[]) {\n        return intern((int[]) a);\n    } else if (a instanceof long[]) {\n        return intern((long[]) a);\n    } else if (a instanceof Double) {\n        return intern((Double) a);\n    } else if (a instanceof double[]) {\n        return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n        @SuppressWarnings(\"interning\")\n        Object[] /*@Interned*/\n        asArray = (Object[]) a;\n        return intern(asArray);\n    } else {\n        throw new IllegalArgumentException(\"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * Return the subsequence of seq from start (inclusive) to end\n * (exclusive) that is interned.  What's different about this method\n * from manually finding the subsequence and interning the\n * subsequence is that if the subsequence is already interned, we\n * can avoid having to compute the sequence.  Since derived\n * variables in Daikon compute the subsequence many times, this\n * shortcut saves quite a bit of computation.  It saves even more\n * when there may be many derived variables that are non-canonical,\n * since they are guaranteed to be ==.\n * <p>\n * Requires that seq is already interned.\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n */\npublic static int[] internSubsequence(int[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int[]> /*@Interned*/\n    sai = new SequenceAndIndices<int[]>(seq, start, end);\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n        int[] /*@Interned*/\n        subseq = Intern.intern(subseqUninterned);\n        internedIntSequenceAndIndices.put(sai, new WeakReference<int[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static long[] internSubsequence(long[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long[]> /*@Interned*/\n    sai = new SequenceAndIndices<long[]>(seq, start, end);\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        long[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedLongSequenceAndIndices.put(sai, new WeakReference<long[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static double[] internSubsequence(double[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double[]> /*@Interned*/\n    sai = new SequenceAndIndices<double[]>(seq, start, end);\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        double[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedDoubleSequenceAndIndices.put(sai, new WeakReference<double[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static Object[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nObject[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<Object[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedObjectSequenceAndIndices.put(sai, new WeakReference<Object[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static String[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nString[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<String[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedStringSequenceAndIndices.put(sai, new WeakReference<String[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "dominators",
                "plume",
                "GraphMDE",
                "// Algorithms for computing dominators:\n//\n// Wikipedia:\n//  // dominator of the start node is the start itself\n//  Dom(n_0) = {n_0}\n//  // for all other nodes, set all nodes as the dominators\n//  for each n in N - {n_0}\n//      Dom(n) = N;\n//  // iteratively eliminate nodes that are not dominators\n//  while changes in any Dom(n)\n//      for each n in N - {n_0}:\n//          Dom(n) = {n} union with intersection over all p in pred(n) of Dom(p)\n//\n// Cooper/Harvey/Kennedy:\n//  for all nodes, n\n//    DOM[n] := {1 . . .N}\n//  Changed := true\n//  while (Changed)\n//    Changed := false\n//    for all nodes, n, in reverse postorder\n//      new_set := (Intersect_{p:=preds(n)} DOM[p]) union {n}\n//      if (new_set != DOM[n])\n//        DOM[n] := new_set\n//        Changed := true\n// The two algorithms are essentially the same; this implementation\n// follows the Wikipedia one.\n/**\n * Computes, for each node in the graph, its set of (pre-)dominators.\n * Supply a successor graph if you want post-dominators.\n * @param <T> type of the graph nodes\n * @param predecessors a graph, represented as a predecessor map\n * @return a map from each node to a list of its pre-dominators\n */\npublic static <T> Map<T, List<T>> dominators(Map<T, List</*@KeyFor(\"#1\")*/\nT>> predecessors) {\n    // Map</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>> dom = new HashMap</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>>();\n    Map<T, List<T>> dom = new HashMap<T, List<T>>();\n    // every element of pred's value will be a key for dom\n    @SuppressWarnings(\"keyfor\")\n    Map<T, List<T>> /*@KeyFor({\"dom\"})*/\n    preds = predecessors;\n    List<T> nodes = new ArrayList<T>(preds.keySet());\n    // Compute roots & non-roots, for convenience\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    roots = new ArrayList<T>();\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    non_roots = new ArrayList<T>();\n    // Initialize result:  for roots just the root, otherwise everything\n    for (T node : preds.keySet()) {\n        if (preds.get(node).isEmpty()) {\n            // This is a root.  Its only dominator is itself.\n            Set<T> set = Collections.singleton(node);\n            dom.put(node, new ArrayList<T>(set));\n            roots.add(node);\n        } else {\n            // Initially, set all nodes as dominators;\n            // will later remove nodes that aren't dominators.\n            dom.put(node, new ArrayList<T>(nodes));\n            non_roots.add(node);\n        }\n    }\n    assert roots.size() + non_roots.size() == nodes.size();\n    // Invariants:\n    // preds and dom have the same keyset.\n    // All of the following are keys for both preds and dom:\n    //  * every key in pred\n    //  * elery element of every pred value\n    //  * every key in dom\n    //  * elery element of every dom value\n    // So, the type of pred is now\n    //\n    // rather than its original type\n    //   Map<T,List</*@KeyFor(\"preds\")*/ T>> preds\n    boolean changed = true;\n    while (changed) {\n        changed = false;\n        for (T node : non_roots) {\n            List<T> new_doms = null;\n            assert preds.containsKey(node);\n            for (T pred : preds.get(node)) {\n                assert dom.containsKey(pred);\n                /*@NonNull*/\n                List<T> dom_of_pred = dom.get(pred);\n                if (new_doms == null) {\n                    // make copy because we may side-effect new_doms\n                    new_doms = new ArrayList<T>(dom_of_pred);\n                } else {\n                    new_doms.retainAll(dom_of_pred);\n                }\n            }\n            assert new_doms != null : \"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\";\n            new_doms.add(node);\n            assert dom.containsKey(node);\n            if (!dom.get(node).equals(new_doms)) {\n                dom.put(node, new_doms);\n                changed = true;\n            }\n        }\n    }\n    for (T node : preds.keySet()) {\n        // TODO: The following two assert statements would be easier to read\n        // than the one combined one, but a bug (TODO:  Jonathan will add a\n        // bug number) prevents it from type-checking.\n        // assert dom.containsKey(node);\n        // assert dom.get(node).contains(node);\n        assert dom.containsKey(node) && dom.get(node).contains(node);\n    }\n    return dom;\n}"
            ],
            [
                "canonicalizeTimezone",
                "plume",
                "ICalAvailable",
                "static String canonicalizeTimezone(String timezone) {\n    String result = canonicalTimezones.get(timezone.toLowerCase());\n    return (result == null) ? timezone : result;\n}"
            ],
            [
                "printedTimezone",
                "plume",
                "ICalAvailable",
                "/*@Pure*/\nstatic String printedTimezone(TimeZone tz) {\n    String tzString = tz.getDisplayName();\n    String result = printedTimezones.get(tzString);\n    return (result == null) ? tzString : result;\n}"
            ],
            [
                "parseTime",
                "plume",
                "ICalAvailable",
                "// Parse a time like \"9:30pm\"\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nDateTime parseTime(String time) {\n    Matcher m = timeRegexp.matcher(time);\n    if (!m.matches()) {\n        System.err.println(\"Bad time: \" + time);\n        System.exit(1);\n    }\n    @SuppressWarnings(// Regex Checker imprecision:  matches() guarantees that group 1 exists in regexp\n    \"nullness\")\n    String /*@NonNull*/\n    hourString = m.group(1);\n    String minuteString = m.group(3);\n    String ampmString = m.group(4);\n    int hour = Integer.parseInt(hourString);\n    if ((ampmString != null) && ampmString.toLowerCase().equals(\"pm\")) {\n        hour += 12;\n    }\n    int minute = 0;\n    if (minuteString != null) {\n        minute = Integer.parseInt(minuteString);\n    }\n    DateTime result = new DateTime();\n    result.setTimeZone(tz1);\n    result.setHours(hour);\n    result.setMinutes(minute);\n    result.setSeconds(0);\n    return result;\n}"
            ],
            [
                "rangeString",
                "plume",
                "ICalAvailable",
                "static String rangeString(Period p, TimeZone tz) {\n    tf.setTimeZone(tz);\n    DateTime pstart = p.getStart();\n    DateTime pend = p.getEnd();\n    String rangeString = tf.format(pstart) + \" to \" + tf.format(pend);\n    rangeString = rangeString.replace(\" AM\", \"am\");\n    rangeString = rangeString.replace(\" PM\", \"pm\");\n    return rangeString;\n}"
            ],
            [
                "periodListString",
                "plume",
                "ICalAvailable",
                "static String periodListString(PeriodList pl, TimeZone tz) {\n    tf.setTimeZone(tz);\n    StringBuilder result = new StringBuilder();\n    // \"Object\" because PeriodList extends TreeSet, but it really ought to\n    // extend TreeSet</*@NonNull*/ Period>\n    for (Object p : pl) {\n        assert p != null : \"@AssumeAssertion(nullness): non-generic container class; elements are non-null\";\n        result.append(rangeString((Period) p, tz) + \"\\n\");\n    }\n    return result.toString();\n}"
            ],
            [
                "mergeDateAndTime",
                "plume",
                "ICalAvailable",
                "/**\n * Creates a new DateTime with date taken from the first argument and\n * time taken from the second argument.\n * @return the merged DateTime\n */\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic DateTime mergeDateAndTime(DateTime date, DateTime time) {\n    if (!date.getTimeZone().equals(time.getTimeZone())) {\n        throw new Error(String.format(\"non-matching timezones: %s %s\", date.getTimeZone(), time.getTimeZone()));\n    }\n    DateTime result = new DateTime(date);\n    result.setHours(time.getHours());\n    result.setMinutes(time.getMinutes());\n    result.setSeconds(time.getSeconds());\n    return result;\n}"
            ],
            [
                "oneDayAvailable",
                "plume",
                "ICalAvailable",
                "// TODO:  don't propose times that are before the current moment.\n// Process day-by-day because otherwise weekends and evenings are included.\n// for iCal4j\n@SuppressWarnings(\"unchecked\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nList<Period> oneDayAvailable(DateTime day, List<Calendar> calendars) {\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...)%n\", day);\n    }\n    List<Period> result = new ArrayList<Period>();\n    // for iCal4j\n    @SuppressWarnings(\"deprecation\")\n    int dayOfWeek = day.getDay();\n    if (!businessDays.contains(dayOfWeek)) {\n        return result;\n    }\n    for (Period bh : businessHours) {\n        DateTime start = mergeDateAndTime(day, bh.getStart());\n        DateTime end = mergeDateAndTime(day, bh.getEnd());\n        VFreeBusy request = new VFreeBusy(start, end, new Dur(0, 0, 0, 1));\n        if (debug) {\n            System.out.println(\"Request = \" + request);\n        }\n        ComponentList busyTimes = new ComponentList();\n        // Problem:  any all-day events will be treated as UTC.\n        // Instead, they should be converted to local time (tz1).\n        // But VFreeBusy does not support this, so I may need to convert\n        // daily events into a different format before inserting them.\n        for (Calendar calendar : calendars) {\n            // getComponents() returns a raw ArrayList.  Expose its element type.\n            ArrayList<Component> /*@NonNull*/\n            clist = calendar.getComponents();\n            for (Component c : clist) {\n                if (c instanceof VEvent) {\n                    VEvent v = (VEvent) c;\n                    DtStart dts = v.getStartDate();\n                    Parameter dtsValue = dts.getParameter(\"VALUE\");\n                    boolean allDay = (dtsValue != null) && dtsValue.getValue().equals(\"DATE\");\n                    // TODO: convert to the proper timezone.\n                    // Tricky: must deal with the possibility of RRULE:FREQ=\n                }\n                busyTimes.add(c);\n            }\n        }\n        VFreeBusy response = new VFreeBusy(request, busyTimes);\n        if (debug) {\n            System.out.println(\"Response = \" + response);\n        }\n        FreeBusy freefb = (FreeBusy) response.getProperty(\"FREEBUSY\");\n        if (freefb == null) {\n            if (debug) {\n                System.out.println(\"FREEBUSY property is null\");\n            }\n            continue;\n        }\n        // interned fields from a library, but not annotated so\n        @SuppressWarnings(\"interning\")\n        boolean isFree = (freefb.getParameter(Parameter.FBTYPE) == FbType.FREE);\n        assert isFree;\n        PeriodList freePeriods = freefb.getPeriods();\n        if (debug) {\n            System.out.printf(\"Free periods: %n%s%n\", periodListString(freePeriods, tz1));\n        }\n        result.addAll(freePeriods);\n    }\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...) => %s elements%n\", day, result.size());\n    }\n    return result;\n}"
            ],
            [
                "parseDate",
                "plume",
                "ICalAvailable",
                "/**\n * Parses a date when formatted in several common formats.\n * @return a Date read from the given string\n * @see dateFormats\n */\nstatic java.util.Date parseDate(String strDate) throws ParseException {\n    if (Pattern.matches(\"^[0-9][0-9]?/[0-9][0-9]?$\", date)) {\n        // for iCal4j\n        @SuppressWarnings(\"deprecation\")\n        int year = new Date().getYear() + 1900;\n        strDate = strDate + \"/\" + year;\n    }\n    for (DateFormat this_df : dateFormats) {\n        this_df.setLenient(false);\n        try {\n            java.util.Date result = this_df.parse(strDate);\n            return result;\n        } catch (ParseException e) {\n            // Try the next format in the list.\n        }\n    }\n    throw new ParseException(\"bad date \" + strDate, 0);\n}"
            ],
            [
                "formatDate",
                "plume",
                "ICalAvailable",
                "static String formatDate(DateTime d, TimeZone tz) {\n    df.setTimeZone(tz);\n    String result = df.format(d);\n    // Don't remove trailing year; it's a good double-check.\n    // Remove trailing year, such as \", 1952\".\n    // result = result.substring(0, result.length() - 6);\n    // Prepend day of week.\n    result = dffull.format(d).substring(0, 3) + \" \" + result;\n    return result;\n}"
            ],
            [
                "get_method_declaration",
                "plume",
                "BCELUtil",
                "/**\n * Returns a string describing a method declaration. It contains the access\n * flags (public, private, static, etc), the return type, the method name, and\n * the types of each of its arguments.\n * @param m the method\n * @return a string describing the method declaration\n */\npublic static String get_method_declaration(Method m) {\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n        f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n}"
            ],
            [
                "get_access_flags",
                "plume",
                "BCELUtil",
                "/**\n * Return a string representation of the access flags of method m.\n * @param m the method whose access flags to retrieve\n * @return a string representation of the access flags of method m\n */\nstatic String get_access_flags(Method m) {\n    int flags = m.getAccessFlags();\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n        if ((flags & pow) != 0) {\n            if (buf.length() > 0) {\n                buf.append(\" \");\n            }\n            if (i < Const.ACCESS_NAMES_LENGTH) {\n                buf.append(Const.getAccessName(i));\n            } else {\n                buf.append(String.format(\"ACC_BIT %x\", pow));\n            }\n        }\n        pow <<= 1;\n    }\n    return (buf.toString());\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a) {\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "get_constant_str",
                "plume",
                "BCELUtil",
                "/**\n * Returns the constant string at the specified offset.\n * @param pool the constant pool\n * @param index the index in the constant pool\n * @return the constant string at the specified offset in the constant pool\n */\npublic static String get_constant_str(ConstantPool pool, int index) {\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n        return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n        ConstantClass cc = (ConstantClass) c;\n        return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n        throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param mg the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param m the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param mg the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param m the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param gen the class to test\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in the format of Class.getName();\n *   the class should not be an array\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(/*@ClassGetName*/\nString classname) {\n    return classname.startsWith(\"java.\") || classname.startsWith(\"com.\") || classname.startsWith(\"javax.\") || classname.startsWith(\"org.\") || classname.startsWith(\"sun.\") || classname.startsWith(\"sunw.\");\n}"
            ],
            [
                "in_jdk_internalform",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in internal form\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk_internalform(/*@InternalForm*/\nString classname) {\n    return classname.startsWith(\"java/\") || classname.startsWith(\"com/\") || classname.startsWith(\"javax/\") || classname.startsWith(\"org/\") || classname.startsWith(\"sun/\") || classname.startsWith(\"sunw/\");\n}"
            ],
            [
                "instruction_descr",
                "plume",
                "BCELUtil",
                "// TODO: write Javadoc\n@SuppressWarnings(\"rawtypes\")\npublic static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n        @SuppressWarnings(// BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n        \"nullness\")\n        InstructionHandle /*@NonNull*/\n        handle = (InstructionHandle) i.next();\n        out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n}"
            ],
            [
                "local_var_descr",
                "plume",
                "BCELUtil",
                "/**\n * Return a description of the local variables (one per line).\n * @param mg the method whose local variables to describe\n * @return a description of the local variables (one per line)\n */\npublic static String local_var_descr(MethodGen mg) {\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n        for (LocalVariableGen lvg : lvgs) {\n            out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n        }\n    }\n    return (out.toString());\n}"
            ],
            [
                "is_local_variable_type_table",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the specified attribute is a local variable type\n * table.\n * @param a the attribute\n * @param pool the constant pool\n * @return true iff the attribute is a local variable type table\n */\npublic static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @param pool the constant pool\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "is_main",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not this is a standard main method (static,\n * name is 'main', and one argument of string array).\n * @param mg the method to check\n * @return true iff the method is a main method\n */\npublic static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic() && mg.getName().equals(\"main\") && (arg_types.length == 1) && arg_types[0].equals(string_array));\n}"
            ],
            [
                "type_to_classgetname",
                "plume",
                "BCELUtil",
                "/**\n * Returns the Java class name, in the format of {@link Class#getName()},\n * that corresponds to type.\n * @param type the type\n * @return the Java classname that corresponds to type\n */\npublic static /*@ClassGetName*/\nString type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n}"
            ],
            [
                "type_to_class",
                "plume",
                "BCELUtil",
                "/**\n * Returns the class that corresponds to type.\n * @param type the type\n * @return the Java class that corresponds to type\n */\npublic static Class<?> type_to_class(Type type) {\n    String classname = type_to_classgetname(type);\n    try {\n        Class<?> c = UtilMDE.classForName(classname);\n        return c;\n    } catch (Exception e) {\n        throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n}"
            ],
            [
                "add_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type added to the end of types.\n * @param types the array to extend\n * @param new_type the element to add to the end of the types array\n * @return the array (or a new one), with new_type at the end\n */\npublic static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "insert_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type inserted at the beginning.\n * @param types the array to extend\n * @param new_type the element to add to the beginning of the types array\n * @return the array (or a new one), with new_type at the beginning\n */\npublic static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "classname_to_type",
                "plume",
                "BCELUtil",
                "/**\n * Return the type corresponding to a given class name.\n * @param classname the class to convert to a type\n * @return the type corresponding to the given class name\n */\npublic static Type classname_to_type(String classname) {\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n        classname = classname.substring(0, classname.length() - 2);\n        array_depth++;\n    }\n    classname = classname.intern();\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") {\n        // interned\n        t = Type.INT;\n    } else if (classname == \"boolean\") {\n        // interned\n        t = Type.BOOLEAN;\n    } else if (classname == \"byte\") {\n        // interned\n        t = Type.BYTE;\n    } else if (classname == \"char\") {\n        // interned\n        t = Type.CHAR;\n    } else if (classname == \"double\") {\n        // interned\n        t = Type.DOUBLE;\n    } else if (classname == \"float\") {\n        // interned\n        t = Type.FLOAT;\n    } else if (classname == \"long\") {\n        // interned\n        t = Type.LONG;\n    } else if (classname == \"short\") {\n        // interned\n        t = Type.SHORT;\n    } else {\n        // must be a non-primitive\n        t = new ObjectType(classname);\n    }\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n        t = new ArrayType(t, array_depth);\n    }\n    return t;\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Array\n///\n// For arrays, see ArraysMDE.java.\n///////////////////////////////////////////////////////////////////////////\n/// BitSet\n///\n/**\n * Returns true if the cardinality of the intersection of the two\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b) >= i);\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "/**\n * Returns true if the cardinality of the intersection of the three\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b intersect c) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        intersection.and(c);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the two BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @return size(a intersect b)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the three BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @return size(a intersect b intersect c)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n}"
            ],
            [
                "fileInputStream",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// BufferedFileReader\n///\n// Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n/**\n * Returns an InputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStream for file\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            in = new GZIPInputStream(new FileInputStream(file));\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        in = new FileInputStream(file);\n    }\n    return in;\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return an InputStream for filename\n * @throws IOException if there is trouble reading the file\n * @throws FileNotFoundException if the file is not found\n */\npublic static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName null, or the name of a Charset to use when reading the file\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibility-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a LineNumberReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return a LineNumberReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedWriter appends to the end\n * of the file instead of the beginning\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\n// Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\npublic static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n        file_writer = new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n        file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n}"
            ],
            [
                "bufferedFileOutputStream",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedOutputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedOutputStream appends to the end\n * of the file instead of the beginning\n * @return a BufferedOutputStream for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}"
            ],
            [
                "isSubtype",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Class\n///\n/**\n * Return true iff sub is a subtype of sup.\n * If sub == sup, then sub is considered a subtype of sub and this method\n * returns true.\n * @param sub class to test for being a subtype\n * @param sup class to test for being a supertype\n * @return true iff sub is a subtype of sup\n */\n/*@Pure*/\npublic static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n        return true;\n    }\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n        return true;\n    }\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n        if (ifc == sup || isSubtype(ifc, sup)) {\n            return true;\n        }\n    }\n    return false;\n}"
            ],
            [
                "classForName",
                "plume",
                "UtilMDE",
                "/**\n * Like {@link Class#forName(String)}, but also works when the string\n * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n * <p>\n * If the given name can't be found, this method changes the last '.'  to\n * a dollar sign ($) and tries again.  This accounts for inner classes\n * that are incorrectly passed in in fully-qualified format instead of\n * binary format.\n * <p>\n * Recall the rather odd specification for {@link Class#forName(String)}:\n * the argument is a binary name for non-arrays, but a field descriptor\n * for arrays.  This method uses the same rules, but additionally handles\n * primitive types and, for non-arrays, fully-qualified names.\n * @param className name of the class\n * @return the Class corresponding to className\n * @throws ClassNotFoundException if the class is not found\n */\n// The annotation encourages proper use, even though this can take a\n// fully-qualified name (only for a non-array).\npublic static Class<?> classForName(/*@ClassGetName*/\nString className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n        return result;\n    } else {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            int pos = className.lastIndexOf('.');\n            if (pos < 0) {\n                throw e;\n            }\n            // checked below & exception is handled\n            @SuppressWarnings(\"signature\")\n            String /*@ClassGetName*/\n            inner_name = className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n            try {\n                return Class.forName(inner_name);\n            } catch (ClassNotFoundException ee) {\n                throw e;\n            }\n        }\n    }\n}"
            ],
            [
                "binaryNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a binary name to a field descriptor.\n * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n * or \"int\" to \"I\".\n * @param classname name of the class, in binary class name format\n * @return name of the class, in field descriptor format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@FieldDescriptor*/\nString binaryNameToFieldDescriptor(/*@BinaryName*/\nString classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n        dims++;\n        sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n        result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n        result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n}"
            ],
            [
                "primitiveTypeNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n * a field descriptor (e.g., \"I\", \"D\", etc.).\n * @param primitive_name name of the type, in Java format\n * @return name of the type, in field descriptor format\n * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n */\npublic static /*@FieldDescriptor*/\nString primitiveTypeNameToFieldDescriptor(String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n        throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n}"
            ],
            [
                "binaryNameToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a BinaryName to the format of {@link Class#getName()}.\n * @param bn the binary name to convert\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString binaryNameToClassGetName(/*BinaryName*/\nString bn) {\n    if (bn.endsWith(\"[]\")) {\n        return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n        return bn;\n    }\n}"
            ],
            [
                "fieldDescriptorToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n * @param fd the class, in field descriptor format\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString fieldDescriptorToClassGetName(/*FieldDescriptor*/\nString fd) {\n    if (fd.startsWith(\"[\")) {\n        return fd.replace('/', '.');\n    } else {\n        return fieldDescriptorToBinaryName(fd);\n    }\n}"
            ],
            [
                "arglistToJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert a fully-qualified argument list from Java format to JVML format.\n * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n * @param arglist an argument list, in Java format\n * @return argument list, in JVML format\n */\npublic static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n        // substring\n        @SuppressWarnings(\"signature\")\n        String /*@BinaryName*/\n        arg = args_tokenizer.nextToken().trim();\n        result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n}"
            ],
            [
                "fieldDescriptorToBinaryName",
                "plume",
                "UtilMDE",
                "// does not convert \"V\" to \"void\".  Should it?\n/**\n * Convert a field descriptor to a binary name.\n * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n * or \"I\" to \"int\".\n * @param classname name of the type, in JVML format\n * @return name of the type, in Java format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@BinaryName*/\nString fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n        throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n        dims++;\n        classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n        result = classname.substring(1, classname.length() - 1);\n    } else {\n        result = primitiveClassesFromJvm.get(classname);\n        if (result == null) {\n            throw new Error(\"Malformed base class: \" + classname);\n        }\n    }\n    for (int i = 0; i < dims; i++) {\n        result += \"[]\";\n    }\n    return result.replace('/', '.');\n}"
            ],
            [
                "arglistFromJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert an argument list from JVML format to Java format.\n * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n * @param arglist an argument list, in JVML format\n * @return argument list, in Java format\n */\npublic static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n        if (pos > 1) {\n            result += \", \";\n        }\n        int nonarray_pos = pos;\n        while (arglist.charAt(nonarray_pos) == '[') {\n            nonarray_pos++;\n        }\n        char c = arglist.charAt(nonarray_pos);\n        if (c == 'L') {\n            int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n            result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n            pos = semi_pos + 1;\n        } else {\n            String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n            if (maybe == null) {\n                // return null;\n                throw new Error(\"Malformed arglist: \" + arglist);\n            }\n            result += maybe;\n            pos = nonarray_pos + 1;\n        }\n    }\n    return result + \")\";\n}"
            ],
            [
                "defineClassFromFile",
                "plume",
                "UtilMDE",
                "/**\n * Converts the bytes in a file into an instance of class Class, and\n * resolves (links) the class.\n * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n * file name rather than an array of bytes as an argument, and also resolves\n * (links) the class.\n * @see ClassLoader#defineClass(String,byte[],int,int)\n * @param className the name of the class to define, or null if not known\n * @param pathname the pathname of a .class file\n * @return a Java Object corresponding to the Class defined in the .class file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\n// Also throws UnsupportedClassVersionError and some other exceptions.\npublic static Class<?> defineClassFromFile(/*@BinaryName*/\nString className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n}"
            ],
            [
                "count_lines",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// File\n///\n/**\n * Count the number of lines in the specified file.\n * @param filename file whose size to count\n * @return number of lines in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n        while (reader.readLine() != null) {\n            count++;\n        }\n    }\n    return count;\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param filename the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param file the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n        int unix = 0;\n        int dos = 0;\n        int mac = 0;\n        while (true) {\n            String s = r.readLine();\n            if (s == null) {\n                break;\n            }\n            if (s.endsWith(\"\\r\\n\")) {\n                dos++;\n            } else if (s.endsWith(\"\\r\")) {\n                mac++;\n            } else if (s.endsWith(\"\\n\")) {\n                unix++;\n            } else {\n                // This can happen only if the last line is not terminated.\n            }\n        }\n        if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n            return \"\\r\\n\";\n        }\n        if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n            return \"\\r\";\n        }\n        if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n            return \"\\n\";\n        }\n        // The two non-preferred line endings are tied and have more votes than\n        // the preferred line ending.  Give up and return the line separator\n        // for the system on which Java is currently running.\n        return lineSep;\n    }\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @return true iff the files have the same contents\n */\n/*@Pure*/\npublic static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff the files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @param trimLines if true, call String.trim on each line before comparing\n * @return true iff the files have the same contents\n */\n// reads files, side effects local state\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2)) {\n        String line1 = reader1.readLine();\n        String line2 = reader2.readLine();\n        while (line1 != null && line2 != null) {\n            if (trimLines) {\n                line1 = line1.trim();\n                line2 = line2.trim();\n            }\n            if (!(line1.equals(line2))) {\n                return false;\n            }\n            line1 = reader1.readLine();\n            line2 = reader2.readLine();\n        }\n        if (line1 == null && line2 == null) {\n            return true;\n        }\n        return false;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}"
            ],
            [
                "canCreateAndWrite",
                "plume",
                "UtilMDE",
                "/**\n * Returns true\n *  if the file exists and is writable, or\n *  if the file can be created.\n * @param file the file to create and write\n * @return true iff the file can be created and written\n */\npublic static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n        return file.canWrite();\n    } else {\n        File directory = file.getParentFile();\n        if (directory == null) {\n            directory = new File(\".\");\n        }\n        // Does this test need \"directory.canRead()\" also?\n        return directory.canWrite();\n    }\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n}"
            ],
            [
                "createTempDir",
                "plume",
                "UtilMDE",
                "///\n/// Directories\n///\n/**\n * Creates an empty directory in the default temporary-file directory,\n * using the given prefix and suffix to generate its name. For example,\n * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n * someString is internally generated to ensure no temporary files of the\n * same name are generated.\n * @param prefix the prefix string to be used in generating the file's\n *  name; must be at least three characters long\n * @param suffix the suffix string to be used in generating the file's\n *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n *  An abstract pathname denoting a newly-created empty file\n * @return a File representing the newly-created temporary directory\n * @throws IllegalArgumentException If the prefix argument contains fewer\n *  than three characters\n * @throws IOException If a file could not be created\n * @throws SecurityException If a security manager exists and its\n *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n *  file to be created\n * @see java.io.File#createTempFile(String, String, File)\n */\npublic static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dirName and all its files.\n * @param dirName the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dir and all its files.\n * @param dir the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n        return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    return dir.delete();\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name file whose name to expand\n * @return file with expanded file\n */\npublic static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n        return new File(newname);\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name filename to expand\n * @return expanded filename\n */\npublic static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n        return (name.replace(\"~\", userHome));\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "java_source",
                "plume",
                "UtilMDE",
                "/**\n * Return a string version of the name that can be used in Java source.\n * On Windows, the file will return a backslash separated string.  Since\n * backslash is an escape character, it must be quoted itself inside\n * the string.\n * <p>\n * The current implementation presumes that backslashes don't appear\n * in filenames except as windows path separators.  That seems like a\n * reasonable assumption.\n *\n * @param name file to quote\n * @return a string version of the name that can be used in Java source\n */\npublic static String java_source(File name) {\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n}"
            ],
            [
                "readObject",
                "plume",
                "UtilMDE",
                "/**\n * Reads an Object from a File.\n * @param file the file from which to read\n * @return the object read from the file\n * @throws IOException if there is trouble reading the file\n * @throws ClassNotFoundException if the object's class cannot be found\n */\npublic static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            istream = new GZIPInputStream(istream);\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n}"
            ],
            [
                "readerContents",
                "plume",
                "UtilMDE",
                "/**\n * Reads the entire contents of the reader and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param r the Reader to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readerContents(Reader r) {\n    try {\n        StringBuilder contents = new StringBuilder();\n        int ch;\n        while ((ch = r.read()) != -1) {\n            contents.append((char) ch);\n        }\n        r.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n}"
            ],
            [
                "readFile",
                "plume",
                "UtilMDE",
                "// an alternate name would be \"fileContents\".\n/**\n * Reads the entire contents of the file and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param file the file to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readFile(File file) {\n    try {\n        BufferedReader reader = UtilMDE.bufferedFileReader(file);\n        StringBuilder contents = new StringBuilder();\n        String line = reader.readLine();\n        while (line != null) {\n            contents.append(line);\n            // Note that this converts line terminators!\n            contents.append(lineSep);\n            line = reader.readLine();\n        }\n        reader.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Hashing\n///\n// In hashing, there are two separate issues.  First, one must convert\n// the input datum into an integer.  Then, one must transform the\n// resulting integer in a pseudorandom way so as to result in a number\n// that is far separated from other values that may have been near it to\n// begin with.  Often these two steps are combined, particularly if\n// one wishes to avoid creating too large an integer (losing information\n// off the top bits).\n// http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n//  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n//    h += (h<<3); h ^= (h>>11); h += (h<<15);\n//    is good.\n//  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n//  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n// In this part of the file, perhaps I will eventually write good hash\n// functions.  For now, write cheesy ones that primarily deal with the\n// first issue, transforming a data structure into a single number.  This\n// is also known as fingerprinting.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Double#hashCode()}.\n * @param x value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a) {\n    double result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a, double[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/// Don't define hash with int args; use the long versions instead.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Long#hashCode()}.\n * But it doesn't map -1 and 0 to the same value.\n * @param l value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n        return (int) l;\n    }\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a, long[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a) {\n    return (a == null) ? 0 : a.hashCode();\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b, /*@Nullable*/\nString c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + hash(a[i]);\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @param random the Random instance to use to make selections\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n    while (itor.hasNext()) {\n        rs.accept(itor.next());\n    }\n    return rs.getValues();\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n}"
            ],
            [
                "incrementMap",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Map\n///\n// In Python, inlining this gave a 10x speed improvement.\n// Will the same be true for Java?\n/**\n * Increment the Integer which is indexed by key in the Map.\n * If the key isn't in the Map, it is added.\n * @param <T> type of keys in the map\n * @param m map to have one of its values incremented\n * @param key the key for the element whose value will be incremented\n * @param count how much to increment the value by\n * @return the old value, before it was incremented\n * @throws Error if the key is in the Map but maps to a non-Integer.\n */\npublic static <T> /*@Nullable*/\nInteger incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n        new_total = count;\n    } else {\n        new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n}"
            ],
            [
                "mapToString",
                "plume",
                "UtilMDE",
                "/**\n * Returns a multi-line string representation of a map.\n * @param <K> type of map keys\n * @param <V> type of map values\n * @param m map to be converted to a string\n * @return a multi-line string representation of m\n */\npublic static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @return a sorted version of m.keySet()\n */\npublic static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @param comparator the Comparator to use for sorting\n * @return a sorted version of m.keySet()\n */\npublic static <K, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m, Comparator<K> comparator) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a method signature, return the method.\n * Example calls are:\n * <pre>\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n * </pre>\n * @param method a method signature\n * @return the method corresponding to the given signature\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n        throw new Error(\"malformed method name should contain a period, open paren, and close paren: \" + method + \" <<\" + dotpos + \",\" + oparenpos + \",\" + cparenpos + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n        if (!Character.isWhitespace(method.charAt(i))) {\n            throw new Error(\"malformed method name should contain only whitespace following close paren\");\n        }\n    }\n    // throws exception if class does not exist\n    @SuppressWarnings(\"signature\")\n    String /*@BinaryNameForNonArray*/\n    classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n        String[] argnames;\n        if (all_argnames.equals(\"\")) {\n            argnames = new String[0];\n        } else {\n            argnames = split(all_argnames, ',');\n        }\n        /*@MonotonicNonNull*/\n        Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n        for (int i = 0; i < argnames.length; i++) {\n            String bnArgname = argnames[i].trim();\n            /*@ClassGetName*/\n            String cgnArgname = binaryNameToClassGetName(bnArgname);\n            argclasses_tmp[i] = classForName(cgnArgname);\n        }\n        @SuppressWarnings(\"cast\")\n        Class<?>[] argclasses_res = (Class<?>[]) argclasses_tmp;\n        argclasses = argclasses_res;\n        args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a class name and a method name in that class, return the method.\n * @param classname class in which to find the method\n * @param methodname the method name\n * @param params the parameters of the method\n * @return the method named classname.methodname with parameters params\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(/*@BinaryNameForNonArray*/\nString classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// ProcessBuilder\n///\n/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line\n * @return all the output of the command\n */\npublic static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line, as a list of\n * strings (the command, then its arguments)\n * @return all the output of the command\n */\npublic static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n        Process p = pb.start();\n        @SuppressWarnings(// input stream is non-null because we didn't redirect the input stream\n        \"nullness\")\n        String output = UtilMDE.streamString(p.getInputStream());\n        return output;\n    } catch (IOException e) {\n        return \"IOException: \" + e.getMessage();\n    }\n}"
            ],
            [
                "propertyIsTrue",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Properties\n///\n/**\n * Determines whether a property has value \"true\", \"yes\", or \"1\".\n * @see Properties#getProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @return true iff the property has value \"true\", \"yes\", or \"1\"\n */\n// does not depend on object identity\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n        return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n}"
            ],
            [
                "appendProperty",
                "plume",
                "UtilMDE",
                "/**\n * Set the property to its previous value concatenated to the given value.\n * Return the previous value.\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to concatenate to the previous value of the property\n * @return the previous value of the property\n * @see Properties#getProperty\n * @see Properties#setProperty\n */\npublic static /*@Nullable*/\nString appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n}"
            ],
            [
                "setDefaultMaybe",
                "plume",
                "UtilMDE",
                "/**\n * Set the property only if it was not previously set.\n * @see Properties#getProperty\n * @see Properties#setProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to set the property to, if it is not already set\n * @return the previous value of the property\n */\npublic static /*@Nullable*/\nString setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n        p.setProperty(key, value);\n    }\n    return currentValue;\n}"
            ],
            [
                "getPrivateField",
                "plume",
                "UtilMDE",
                "// TODO: set the field back to private after is is accessed.\n/**\n * Reads the given field, which may be private.\n * Leaves the field accessible.\n * Use with care!\n * @param o object in which to set the field\n * @param fieldName name of field to set\n * @return new value of field\n * @throws NoSuchFieldException if the field does not exist in the object\n */\npublic static /*@Nullable*/\nObject getPrivateField(Object o, String fieldName) throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) {\n        // Class is interned\n        // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n        try {\n            Field f = c.getDeclaredField(fieldName);\n            f.setAccessible(true);\n            return f.get(o);\n        } catch (IllegalAccessException e) {\n            System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n            throw new Error(\"This can't happen: \" + e);\n        } catch (NoSuchFieldException e) {\n            if (c.getSuperclass() == Object.class) {\n                // Class is interned\n                throw e;\n            }\n            // nothing to do; will now examine superclass\n        }\n        c = c.getSuperclass();\n        assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n}"
            ],
            [
                "getFromSet",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set\n///\n/**\n * Return the object in this set that is equal to key.\n * The Set abstraction doesn't provide this; it only provides \"contains\".\n * Returns null if the argument is null, or if it isn't in the set.\n * @param set a set in which to look up the value\n * @param key the value to look up in the set\n * @return the object in this set that is equal to key, or null\n */\npublic static /*@Nullable*/\nObject getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n        return null;\n    }\n    for (Object elt : set) {\n        if (key.equals(elt)) {\n            return elt;\n        }\n    }\n    return null;\n}"
            ],
            [
                "streamString",
                "plume",
                "UtilMDE",
                "/**\n * Return a String containing all the characters from the input stream.\n * @param is input stream to read\n * @return a String containing all the characters from the input stream\n */\npublic static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n}"
            ],
            [
                "replaceString",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// String\n///\n/**\n * Return a new string which is the text of target with all instances of\n * oldStr replaced by newStr.\n * @param target the string to do replacement in\n * @param oldStr the substring to replace\n * @param newStr the replacement\n * @return target with all instances of oldStr replaced by newStr\n */\npublic static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n        throw new IllegalArgumentException();\n    }\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n        result.append(target.substring(lastend, pos));\n        result.append(newStr);\n        lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter character.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, String delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter String.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, char delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n        throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "splitLines",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings, one for each line in the argument.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n * are supported.  Note that a string that ends with a line separator\n * will return an empty string as the last element of the array.\n * @see #split(String s, char delim)\n * @param s the string to split\n * @return an array of Strings, one for each line in the argument\n */\npublic static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the array elements, placing the\n * delimiter between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n        return \"\";\n    }\n    if (a.length == 1) {\n        return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n        sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(Object... a) {\n    return join(a, lineSep);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * delimiter between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n        return \"\";\n    }\n    if (v.size() == 1) {\n        return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n        sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(List<String> v) {\n    return join(v, lineSep);\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Escape \\, \", newline, and carriage-return characters in the\n * target as \\\\, \\\", \\n, and \\r; return a new string if any\n * modifications were necessary.  The intent is that by surrounding\n * the return value with double quote marks, the result will be a\n * Java string literal denoting the original string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        switch(c) {\n            case '\\\"':\n            case '\\\\':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append('\\\\');\n                post_esc = i;\n                break;\n            case // not lineSep\n            '\\n':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                // not lineSep\n                sb.append(\"\\\\n\");\n                post_esc = i + 1;\n                break;\n            case '\\r':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append(\"\\\\r\");\n                post_esc = i + 1;\n                break;\n            default:\n        }\n    }\n    if (sb.length() == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "// The overhead of this is too high to call in escapeNonJava(String), so\n// it is inlined there.\n/**\n * Like {@link #escapeNonJava(String)}, but for a single character.\n * @param ch character to quote\n * @return quoted version och ch\n */\npublic static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch(c) {\n        case '\\\"':\n            return \"\\\\\\\"\";\n        case '\\\\':\n            return \"\\\\\\\\\";\n        case // not lineSep\n        '\\n':\n            // not lineSep\n            return \"\\\\n\";\n        case '\\r':\n            return \"\\\\r\";\n        default:\n            return new String(new char[] { c });\n    }\n}"
            ],
            [
                "escapeNonASCII",
                "plume",
                "UtilMDE",
                "/**\n * Escape unprintable characters in the target, following the usual\n * Java backslash conventions, so that the result is sure to be\n * printable ASCII.  Returns a new string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n}"
            ],
            [
                "unescapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n * one-character equivalents.  All other backslashes are removed\n * (for instance, octal/hex escape sequences are not turned into\n * their respective characters). This is the inverse operation of\n * escapeNonJava(). Previously known as unquote().\n * @param orig string to quoto\n * @return quoted version of orig\n */\npublic static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n        if (this_esc == orig.length() - 1) {\n            sb.append(orig.substring(post_esc, this_esc + 1));\n            post_esc = this_esc + 1;\n            break;\n        }\n        switch(orig.charAt(this_esc + 1)) {\n            case 'n':\n                sb.append(orig.substring(post_esc, this_esc));\n                // not lineSep\n                sb.append('\\n');\n                post_esc = this_esc + 2;\n                break;\n            case 'r':\n                sb.append(orig.substring(post_esc, this_esc));\n                sb.append('\\r');\n                post_esc = this_esc + 2;\n                break;\n            case '\\\\':\n                // This is not in the default case because the search would find\n                // the quoted backslash.  Here we incluce the first backslash in\n                // the output, but not the first.\n                sb.append(orig.substring(post_esc, this_esc + 1));\n                post_esc = this_esc + 2;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                sb.append(orig.substring(post_esc, this_esc));\n                char octal_char = 0;\n                int ii = this_esc + 1;\n                while (ii < orig.length()) {\n                    char ch = orig.charAt(ii++);\n                    if ((ch < '0') || (ch > '8')) {\n                        break;\n                    }\n                    octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n                }\n                sb.append(octal_char);\n                post_esc = ii - 1;\n                break;\n            default:\n                // In the default case, retain the character following the backslash,\n                // but discard the backslash itself.  \"\\*\" is just a one-character string.\n                sb.append(orig.substring(post_esc, this_esc));\n                post_esc = this_esc + 1;\n                break;\n        }\n        this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "removeWhitespaceAround",
                "plume",
                "UtilMDE",
                "// Use the built-in String.trim()!\n// /** Return the string with all leading and trailing whitespace stripped. */\n// public static String trimWhitespace(String s) {\n//   int len = s.length();\n//   if (len == 0)\n//     return s;\n//   int first_non_ws = 0;\n//   int last_non_ws = len-1;\n//   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n//     first_non_ws++;\n//   if (first_non_ws == len)\n//     return \"\";\n//   while (Character.isWhitespace(s.charAt(last_non_ws)))\n//     last_non_ws--;\n//   if ((first_non_ws == 0) && (last_non_ws == len)) {\n//     return s;\n//   } else {\n//     return s.substring(first_non_ws, last_non_ws+1);\n//   }\n// }\n// // // Testing:\n// // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n// // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n// // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n/**\n * Remove all whitespace before or after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace abutting\n * @return version of arg, with whitespace abutting delimiter removed\n */\npublic static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n}"
            ],
            [
                "removeWhitespaceAfter",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace after\n * @return version of arg, with whitespace after delimiter removed\n */\npublic static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index + delim_len;\n        while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index++;\n        }\n        // if (non_ws_index == arg.length()) {\n        //   System.out.println(\"No nonspace character at end of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index + delim_len) {\n            arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n        }\n        delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n}"
            ],
            [
                "removeWhitespaceBefore",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace before instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace before\n * @return version of arg, with whitespace before delimiter removed\n */\npublic static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index - 1;\n        while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index--;\n        }\n        // if (non_ws_index == -1) {\n        //   System.out.println(\"No nonspace character at front of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index - 1) {\n            arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n        }\n        delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n}"
            ],
            [
                "nplural",
                "plume",
                "UtilMDE",
                "/**\n * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n * @param n count of nouns\n * @param noun word being counted\n * @return noun, if n==1; otherwise, pluralization of noun\n */\npublic static String nplural(int n, String noun) {\n    if (n == 1) {\n        return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\") || noun.endsWith(\"s\") || noun.endsWith(\"sh\") || noun.endsWith(\"x\")) {\n        return n + \" \" + noun + \"es\";\n    } else {\n        return n + \" \" + noun + \"s\";\n    }\n}"
            ],
            [
                "lpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the left if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String lpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString() + s;\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the right if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String rpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n * @param num int whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n * @param num double whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the character appears in the string.\n * @param s string to search in\n * @param ch character to search for\n * @return number of times the character appears in the string\n */\npublic static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the second string appears in the first.\n * @param s string to search in\n * @param sub string to search for\n * @return number of times the substring appears in the string\n */\npublic static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// StringTokenizer\n///\n/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n * <p>\n * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n * (probably due to backward-compatibility).\n * @param str a string to be parsed\n * @param delim the delimiters\n * @param returnDelims flag indicating whether to return the delimiters as tokens\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n * @param str a string to be parsed\n * @param delim the delimiters\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n * @param str a string to be parsed\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n}"
            ],
            [
                "backTrace",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Throwable\n///\n/**\n * Return a String representation of the backtrace of the given Throwable.\n * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n * @param t the Throwable to obtain a backtrace of\n * @return a String representation of the backtrace of the given Throwable\n */\npublic static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n}"
            ],
            [
                "sortList",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Collections\n///\n/**\n * Return the sorted version of the list.  Does not alter the list.\n * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n * @return a sorted version of the list\n * @param <T> type of elements of the list\n * @param l a list to sort\n * @param c a sorted version of the list\n */\npublic static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n}"
            ],
            [
                "removeDuplicates",
                "plume",
                "UtilMDE",
                "// This should perhaps be named withoutDuplicates to emphasize that\n// it does not side-effect its argument.\n/**\n * Return a copy of the list with duplicates removed.\n * Retains the original order.\n * @param <T> type of elements of the list\n * @param l a list to remove duplicates from\n * @return a copy of the list with duplicates removed\n */\npublic static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n}"
            ],
            [
                "deepEquals",
                "plume",
                "UtilMDE",
                "/**\n * Determines deep equality for the elements.\n * <ul>\n * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n * <li>If both are lists, uses deepEquals recursively on each element.\n * <li>For other types, just uses equals() and does not recursively call this method.\n * </ul>\n * @param o1 first value to compare\n * @param o2 second value to comare\n * @return true iff o1 and o2 are deeply equal\n */\n// side effect to static field deepEqualsUnderway\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean deepEquals(/*@Nullable*/\nObject o1, /*@Nullable*/\nObject o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    // creates local state\n    @SuppressWarnings(\"purity\")\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n        return true;\n    }\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n        List<?> l1 = (List<?>) o1;\n        List<?> l2 = (List<?>) o2;\n        if (l1.size() != l2.size()) {\n            return false;\n        }\n        try {\n            deepEqualsUnderway.add(mypair);\n            for (int i = 0; i < l1.size(); i++) {\n                Object e1 = l1.get(i);\n                Object e2 = l2.get(i);\n                if (!deepEquals(e1, e2)) {\n                    return false;\n                }\n            }\n        } finally {\n            deepEqualsUnderway.remove(mypair);\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}"
            ],
            [
                "makeVector",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Vector\n///\n/**\n * Returns a vector containing the elements of the enumeration.\n * @param <T> type of the enumeration and vector elements\n * @param e an enumeration to convert to a Vector\n * @return a vector containing the elements of the enumeration\n */\npublic static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n        result.addElement(e.nextElement());\n    }\n    return result;\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "// Rather than writing something like VectorToStringArray, use\n//   v.toArray(new String[0])\n/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of the specified objects starting at index\n * start over dims dimensions, for dims &gt; 0.\n * <p>\n * For example, create_combinations (1, 0, {a, b, c}) returns:\n * <pre>\n *    {a}, {b}, {c}\n * </pre>\n * And create_combinations (2, 0, {a, b, c}) returns:\n * <pre>\n *    {a, a}, {a, b}, {a, c}\n *    {b, b}, {b, c},\n *    {c, c}\n * </pre>\n * @param <T> type of the input list elements, and type of the innermost output list elements\n * @param dims number of dimensions:  that is, size of each innermost list\n * @param start initial index\n * @param objs list of elements to\n * @return list of lists of length dims, each of which combines elements from objs\n */\npublic static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n    if (dims < 1) {\n        throw new IllegalArgumentException();\n    }\n    List<List<T>> results = new ArrayList<List<T>>();\n    for (int i = start; i < objs.size(); i++) {\n        if (dims == 1) {\n            List<T> simple = new ArrayList<T>();\n            simple.add(objs.get(i));\n            results.add(simple);\n        } else {\n            List<List<T>> combos = create_combinations(dims - 1, i, objs);\n            for (List<T> lt : combos) {\n                List<T> simple = new ArrayList<T>();\n                simple.add(objs.get(i));\n                simple.addAll(lt);\n                results.add(simple);\n            }\n        }\n    }\n    return (results);\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of integers from start to cnt (inclusive) over\n * arity dimensions.\n * <p>\n * For example, create_combinations (1, 0, 2) returns:\n * <pre>\n *    {0}, {1}, {2}\n * </pre>\n * And create_combinations (2, 0, 2) returns:\n * <pre>\n *    {0, 0}, {0, 1}, {0, 2}\n *    {1, 1}  {1, 2},\n *    {2, 2}\n * </pre>\n * @param arity size of each innermost list\n * @param start initial value\n * @param cnt maximum element value\n * @return list of lists of length arity, each of which combines integers from start to cnt\n */\npublic static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n        results.add(new ArrayList<Integer>());\n        return (results);\n    }\n    for (int i = start; i <= cnt; i++) {\n        ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n        for (ArrayList<Integer> li : combos) {\n            ArrayList<Integer> simple = new ArrayList<Integer>();\n            simple.add(new Integer(i));\n            simple.addAll(li);\n            results.add(simple);\n        }\n    }\n    return (results);\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(/*@FullyQualifiedName*/\nString qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n}"
            ],
            [
                "fullyQualifiedNameToSimpleName",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n// TODO: does not follow the specification for inner classes (where the\n// type name should be empty), but I think this is more informative anyway.\n// string conversion\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetSimpleName*/\nString fullyQualifiedNameToSimpleName(/*@FullyQualifiedName*/\nString qualified_name) {\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n        return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified class.  For example if qualified name of the class\n * is java.lang.String, String will be returned.\n *\n * @deprecated use {@link Class#getSimpleName()} instead.\n *\n * @param cls a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n}"
            ],
            [
                "abbreviateNumber",
                "plume",
                "UtilMDE",
                "/**\n * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n * of precision in the result (counting both sides of the decimal point).\n * @param val a numeric value\n * @return an abbreviated string representation of the value\n */\npublic static String abbreviateNumber(long val) {\n    double dval = (double) val;\n    String mag = \"\";\n    if (val < 1000) {\n        // nothing to do\n    } else if (val < 1000000) {\n        dval = val / 1000.0;\n        mag = \"K\";\n    } else if (val < 1000000000) {\n        dval = val / 1000000.0;\n        mag = \"M\";\n    } else {\n        dval = val / 1000000000.0;\n        mag = \"G\";\n    }\n    String precision = \"0\";\n    if (dval < 10) {\n        precision = \"2\";\n    } else if (dval < 100) {\n        precision = \"1\";\n    }\n    // format string computed from precision and mag\n    @SuppressWarnings(\"formatter\")\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeIntSet",
                "/**\n * Merges a list of LimitedSizeIntSet objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param max_values the maximum size for the returned LimitedSizeIntSet\n * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n * @return a LimitedSizeIntSet that merges the elements of slist\n */\npublic static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist) {\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ],
            [
                "of",
                "plume",
                "Triple",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param <C> type of third argument\n * @param a first argument\n * @param b second argument\n * @param c third argument\n * @return a triple of the values (a, b, c)\n */\npublic static <A, B, C> Triple<A, B, C> of(A a, B b, C c) {\n    return new Triple<A, B, C>(a, b, c);\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// min, max\n///\n// Could also add linear-time orderStatistics if I liked.\n/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int min(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long min(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double min(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer min(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long min(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() < result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double min(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int max(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long max(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double max(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer max(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long max(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() > result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double max(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int[] min_max(int[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] { result_min, result_max };\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long[] min_max(long[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] { result_min, result_max };\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int element_range(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long element_range(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of integers.\n * @param a an array\n * @return the sum of an array of integers\n */\npublic static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of integers.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of integers\n */\npublic static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of doubles.\n * @param a an array\n * @return the sum of an array of doubles\n */\npublic static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of doubles.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of doubles\n */\npublic static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf\n///\n/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> type of the elements of the array\n * @param a an array\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt) {\n    if (elt == null) {\n        return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> the type of the elements\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n *    Identical to List.indexOf, but included for completeness.\n * @param a a list\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    return a.indexOf(elt);\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a.get(i))) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyNull*/\nObject[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.size(); i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf, for finding subarrays\n///\n// This is analogous to Common Lisp's \"search\" function.\n// This implementation is very inefficient; I could use tricky Boyer-Moore\n// search techniques if I liked, but it's not worth it to me yet.\n/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n// The signature on this method is unnecessarily strict because it\n// requires that the component types be identical.  The signature should\n// be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n// @PolyAll qualifier does not yet take an argument.\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// mismatch\n///\n// This is analogous to Common Lisp's \"mismatch\" function.\n// Put it off until later; for now, use the simpler subarray function,\n// which is a specialization of mismatch,\n///////////////////////////////////////////////////////////////////////////\n/// subarray extraction\n///\n// Note that the second argument is a length, not an end position.\n// That's to avoid confusion over whether it would be the last included\n// index or the first non-included index.\n/**\n * Return a subarray of the given array.\n * @return a subarray of the given array\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n */\n/*@SideEffectFree*/\npublic static Object[] subarray(/*@PolyAll*/\nObject[] a, int startindex, int length) {\n    /*@PolyAll*/\n    Object[] result = new /*@PolyAll*/\n    Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a sublist of the given list.\n * @param <T> type of the elements\n * @param a the original list\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a sublist of the given list\n */\n/*@SideEffectFree*/\npublic static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static String[] subarray(/*@PolyAll*/\nString[] a, int startindex, int length) {\n    /*@PolyAll*/\n    String[] result = new /*@PolyAll*/\n    String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// subarray testing\n///\n/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, /*@PolyNull*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.size()];\n            System.arraycopy(a, 0, result, 0, a.length);\n            // System.arraycopy(b, 0, result, a.length, b.size());\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.length] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.length];\n            // System.arraycopy(a, 0, result, 0, a.size());\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            System.arraycopy(b, 0, result, a.size(), b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.size()];\n            // System.arraycopy(a, 0, result, 0, a.length);\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            // System.arraycopy(b, 0, result, a.length, b.length);\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.size()] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "// Note: PolyAll is not quite right.  Need to review.\n/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first array to concatenate\n * @param b the second array to concatenate\n * @return an array that concatenates the arguments\n */\npublic static String[] concat(/*@PolyAll*/\nString[] a, /*@PolyAll*/\nString[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new String[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            /*@PolyAll*/\n            String[] result = new String[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static byte[] concat(byte[] a, byte[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new byte[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            byte[] result = new byte[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static boolean[] concat(boolean[] a, boolean[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new boolean[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            boolean[] result = new boolean[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static char[] concat(char[] a, char[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new char[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            char[] result = new char[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static double[] concat(double[] a, double[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new double[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            double[] result = new double[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static float[] concat(float[] a, float[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new float[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            float[] result = new float[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static int[] concat(int[] a, int[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new int[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            int[] result = new int[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static long[] concat(long[] a, long[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new long[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            long[] result = new long[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static short[] concat(short[] a, short[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new short[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            short[] result = new short[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Printing\n///\n// This should be extended to all types, when I get around to it.  The\n// methods are patterned after that of java.util.Vector (and use its\n// output format).\n/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@PolyAll*/\nObject[] a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, each element is quoted like a Java String.\n * @param a an array\n * @return a string representation of the array, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@PolyAll*/\nObject[] a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, if quoted is true, then each element is quoted like a Java String.\n * @param a an array\n * @param quoted whether to quote the array elements\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@PolyAll*/\nObject[] a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            if (quoted && a[i] instanceof String) {\n                String elt = (String) a[i];\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava(elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(a[i]);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @param quoted whether to quote the collection elements that are Java strings\n * @return a string representation of the list\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@Nullable*/\nCollection<?> a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n        Iterator<?> itor = a.iterator();\n        sb.append(itor.next());\n        while (itor.hasNext()) {\n            sb.append(\", \");\n            Object elt = itor.next();\n            if (quoted && elt instanceof String) {\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava((String) elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(elt);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(int[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(long[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(double[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(float[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(boolean[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls the appropriate\n * toString() method.  Only call this method if obj is a boolean, double,\n * int, long, or Object array.\n * @param obj an array\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n        return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n        return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n        return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n        return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n        return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n        return toString((List<?>) obj);\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "length",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls .length.\n * Only call this method if obj is a boolean, double, int, long, or Object array.\n * @param obj a list\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n        return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n        return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n        return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n        return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n        return ((List<?>) obj).size();\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Sortedness\n///\n/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Boolean n = Boolean.valueOf(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Byte n = new Byte(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Float n = new Float(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Short n = new Short(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Integer n = new Integer(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space. Equality checking\n * uses the .equals() method for java.lang.Double.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Double n = new Double(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Long n = new Long(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param <T> the type of the elements\n * @param a a list\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static </*@Pure*/\nT> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n        if (hs.contains(a.get(i))) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a.get(i));\n    }\n    return true;\n}"
            ],
            [
                "fn_is_permutation",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Arrays as partial functions of int->int\n///\n/**\n * Returns true if the array is a permutation of [0..a.length).\n * @param a an array, representing a function\n * @return true iff all elements of a are in [0..a.length) and a\n * contains no duplicates.\n */\n// side effect to local state (array)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int n = a[i];\n        if (n < 0 || n >= a.length || see[n]) {\n            return false;\n        }\n        see[n] = true;\n    }\n    return true;\n}"
            ],
            [
                "fn_is_total",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff the array does not contain -1.\n * @param a an array, representing a function\n * @return true iff no element of a maps to -1\n */\n/*@Pure*/\npublic static boolean fn_is_total(int[] a) {\n    // not found\n    return indexOf(a, -1) == -1;\n}"
            ],
            [
                "fn_identity",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array [0..lenth).\n * @param length the length of the result\n * @return fresh array that is the identity function of the given length\n */\npublic static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n        result[i] = i;\n    }\n    return result;\n}"
            ],
            [
                "fn_inverse_permutation",
                "plume",
                "ArraysMDE",
                "/**\n * Requires that fn_is_permutation(a) holds.\n * @param a the input permutation\n * @return fresh array which is the inverse of the given permutation\n * @see #fn_is_permutation(int[])\n */\npublic static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n}"
            ],
            [
                "fn_inverse",
                "plume",
                "ArraysMDE",
                "/**\n * Return the inverse of the given function, which is represented as an array.\n * @param a an array representing a function from [0..a.length) to [0..arange);\n *  each element of a is between 0 and arange inclusive\n * @param arange length of the argument's range and the result's domain\n * @return function from [0..arange) to [0..a.length) that is the inverse of a\n * @throws IllegalArgumentException if a value of a is outside of arange\n * @exception UnsupportedOperationException when the function is not invertible\n */\npublic static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n        int ai = a[i];\n        if (ai < -1 || ai >= arange) {\n            throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n        }\n        // ai is either -1 or a valid index\n        if (ai >= 0) {\n            if (result[ai] != -1) {\n                throw new UnsupportedOperationException(String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n            }\n            result[ai] = i;\n        }\n    }\n    return result;\n}"
            ],
            [
                "fn_compose",
                "plume",
                "ArraysMDE",
                "/**\n * Return the composition of the given two functions, all of which are\n * represented as arrays.\n * @param a function from [0..a.length) to [0..b.length)\n * @param b function from [0..b.length) to range R\n * @return function from [0..a.length) to range R that is the\n * composition of a and b\n */\npublic static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int inner = a[i];\n        if (inner == -1) {\n            result[i] = -1;\n        } else {\n            result[i] = b[inner];\n        }\n    }\n    return result;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set operations, such as subset, unions, and intersections\n///\n// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Long(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Long elt = new Long(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Double(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Double elt = new Double(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(bigger[i]);\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        if (!setBigger.contains(smaller[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// nullness\n///\n/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(/*@PolyAll*/\nObject[] a) {\n    if (a.length == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(/*@PolyAll*/\nObject[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (!(a[i] == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n        if (!(a.get(i) == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "int_array_iterator",
                "plume",
                "TestPlume",
                "///////////////////////////////////////////////////////////////////////////\n/// Utility functions\n///\npublic static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n        asList.add(nums[i]);\n    }\n    return asList.iterator();\n}"
            ],
            [
                "int_iterator_array",
                "plume",
                "TestPlume",
                "public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    return v;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n        v.add(e.nextElement());\n    }\n    return v;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeSet",
                "/**\n * Merges a list of LimitedSizeSet&lt;T&gt; objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param <T> (super)type of elements of the sets\n * @param max_values the maximum size for the returned LimitedSizeSet\n * @param slist a list of LimitedSizeSet, whose elements will be merged\n * @return a LimitedSizeSet that merges the elements of slist\n */\npublic static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist) {\n    LimitedSizeSet<T> result = new LimitedSizeSet<T>(max_values);\n    for (LimitedSizeSet<? extends T> s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "serialVersionUID",
                "plume",
                "FileIOException",
                "static final long serialVersionUID = 20050923L;"
            ],
            [
                "counter",
                "plume",
                "DeterministicObject",
                "/**\n * The number of objects created so far.\n */\nstatic int counter = 0;"
            ],
            [
                "home",
                "plume",
                "MultiVersionControl",
                "@Option(value = \"User home directory\", noDocDefault = true)\npublic static String home = System.getProperty(\"user.home\");"
            ],
            [
                "debug",
                "plume",
                "MultiVersionControl",
                "// It would be good to be able to set this per-checkout.\n// This variable is static because it is used in static methods.\n@Option(\"Print debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "idf",
                "plume",
                "MultiVersionControl",
                "static IsDirectoryFilter idf = new IsDirectoryFilter();"
            ],
            [
                "help",
                "plume",
                "Lookup",
                "/**\n * Show detailed help information and exit.\n */\n@OptionGroup(\"Getting help\")\n@Option(\"-h Show detailed help information\")\npublic static boolean help = false;"
            ],
            [
                "verbose",
                "plume",
                "Lookup",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "entry_file",
                "plume",
                "Lookup",
                "// This uses only the first file because the default search path might be\n// something like user:system and you might want only your version of the\n// system files.  It might be useful to also support (via another flag,\n// or by taking over this one, or by the syntax of the separator, or in\n// some other way) specifying multiple files on the command line.\n/**\n * Specify the colon-separated search list for the file that contains\n * information to be searched.  Only the first file found is used, though\n * it may itself contain include directives.\n */\n@OptionGroup(\"Where to search\")\n@Option(\"-f Specify the colon-separated search list of files of information; may only be supplied once\")\npublic static String entry_file = \"~/lookup/root\";"
            ],
            [
                "search_body",
                "plume",
                "Lookup",
                "/**\n * Search the body of long entries in addition to the entry's\n * description.  The bodies of short entries are always searched.\n */\n@Option(\"-b Search body of long entries for matches\")\npublic static boolean search_body = false;"
            ],
            [
                "regular_expressions",
                "plume",
                "Lookup",
                "/**\n * Specifies that keywords are regular expressions.  If false, keywords\n * are text matches.\n */\n@OptionGroup(\"What to search for\")\n@Option(\"-e Keywords are regular expressions\")\npublic static boolean regular_expressions = false;"
            ],
            [
                "case_sensitive",
                "plume",
                "Lookup",
                "/**\n * If true, keywords matching is case sensistive.  By default, both\n * regular expressions and text keywords are case-insensitive.\n */\n@Option(\"-c Keywords are case sensistive\")\npublic static boolean case_sensitive = false;"
            ],
            [
                "word_match",
                "plume",
                "Lookup",
                "/**\n * If true, match a text keyword only as a separate word, not as a\n * substring of a word.  This option is ignored if\n * regular_expressions is true.\n */\n@Option(\"-w Only match text keywords against complete words\")\npublic static boolean word_match = false;"
            ],
            [
                "print_all",
                "plume",
                "Lookup",
                "/**\n * By default, if multiple entries are matched, only a synopsis\n * of each entry is printed.  If 'print_all' is selected then\n * the body of each matching entry is printed.\n */\n@OptionGroup(\"How to print matches\")\n@Option(\"-a Print the entire entry for each match\")\npublic static boolean print_all = false;"
            ],
            [
                "item_num",
                "plume",
                "Lookup",
                "/**\n * Specifies which item to print when there are multiple matches.\n * The index is 1-based; that is, it starts counting at 1.\n */\n@Option(\"-i Choose a specific item when there are multiple matches; index is 1-based\")\npublic static Integer /*@Nullable*/\nitem_num;"
            ],
            [
                "show_location",
                "plume",
                "Lookup",
                "/**\n * If true, show the filename/line number of each matching entry\n * in the output.\n */\n@Option(\"-l Show the location of each matching entry\")\npublic static boolean show_location = false;"
            ],
            [
                "entry_start_re",
                "plume",
                "Lookup",
                "@OptionGroup(\"Customizing format of files to be searched\")\n@Option(\"Regex that denotes the start of a long entry\")\npublic static Pattern /*@Regex(1)*/\nentry_start_re = Pattern.compile(\"^>entry *()\");"
            ],
            [
                "entry_stop_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that denotes the end of a long entry\")\npublic static Pattern entry_stop_re = Pattern.compile(\"^<entry\");"
            ],
            [
                "description_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that finds an entry's description (for long entries)\")\npublic static Pattern /*@Nullable*/\ndescription_re = null;"
            ],
            [
                "comment_re",
                "plume",
                "Lookup",
                "// If \"\", gets set to null immediately after option processing.\n@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Nullable*/\n/*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "runtime",
                "plume",
                "FileCompiler",
                "/**\n * The Runtime of the JVM.\n */\npublic static Runtime runtime = java.lang.Runtime.getRuntime();"
            ],
            [
                "java_filename_pattern",
                "plume",
                "FileCompiler",
                "/**\n * Matches the names of Java source files.\n * Match group 1 is the complete filename.\n */\nstatic Pattern /*@Regex(1)*/\njava_filename_pattern;"
            ],
            [
                "responsible",
                "plume",
                "TaskManager",
                "// Command line options\n@Option(\"-r Include only those tasks assigned to the specified person\")\npublic static String /*@Nullable*/\nresponsible = null;"
            ],
            [
                "milestone",
                "plume",
                "TaskManager",
                "@Option(\"-m Include only those tasks required for the specified milestone\")\npublic static String /*@Nullable*/\nmilestone = null;"
            ],
            [
                "completed",
                "plume",
                "TaskManager",
                "@Option(\"-c Include only completed tasks\")\npublic static boolean completed = false;"
            ],
            [
                "open",
                "plume",
                "TaskManager",
                "@Option(\"-o Include only open tasks\")\npublic static boolean open = false;"
            ],
            [
                "verbose",
                "plume",
                "TaskManager",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "format",
                "plume",
                "TaskManager",
                "@Option(\"-f Specify output format\")\npublic static OutputFormat format = OutputFormat.short_ascii;"
            ],
            [
                "comment_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "lineSep",
                "plume",
                "TaskManager",
                "// line.separator property is a legal regex\n@SuppressWarnings(\"regex\")\npublic static final String /*@Regex*/\nlineSep = System.getProperty(\"line.separator\");"
            ],
            [
                "minversion",
                "plume",
                "ClassFileVersion",
                "/**\n * Only report versions that are at least this large.\n */\nstatic double minversion = 0;"
            ],
            [
                "debug",
                "plume",
                "DeclarationAnnotations",
                "static boolean debug = false;"
            ],
            [
                "date",
                "plume",
                "ICalAvailable",
                "/// User options\n@Option(\"first date to summarize\")\npublic static String date = \"today\";"
            ],
            [
                "start_date",
                "plume",
                "ICalAvailable",
                "public static DateTime start_date = new DateTime();"
            ],
            [
                "days",
                "plume",
                "ICalAvailable",
                "@Option(\"number of calendar days to summarize\")\npublic static int days = 8;"
            ],
            [
                "iCal_URL",
                "plume",
                "ICalAvailable",
                "/**\n * For a Google calendar:  go to settings, then click on the green \"ICAL\"\n * icon for the \"private address\".\n */\n@Option(\"<url> schedule in iCal format\")\npublic static List<String> iCal_URL = new ArrayList<String>();"
            ],
            [
                "business_hours",
                "plume",
                "ICalAvailable",
                "/**\n * A list of time ranges, expressed as a String.\n * Example: 9am-5pm,7:30pm-9:30pm\n */\n@Option(\"time ranges during which appointments are permitted\")\npublic static String business_hours = \"9am-5pm\";"
            ],
            [
                "businessHours",
                "plume",
                "ICalAvailable",
                "// initialize to 9am-5pm\nstatic List<Period> businessHours = new ArrayList<Period>();"
            ],
            [
                "businessDays",
                "plume",
                "ICalAvailable",
                "// initialize to Mon-Fri\nstatic List<Integer> businessDays = new ArrayList<Integer>();"
            ],
            [
                "tzRegistry",
                "plume",
                "ICalAvailable",
                "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();"
            ],
            [
                "timezone1",
                "plume",
                "ICalAvailable",
                "/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * Available times are printed in this time zone.  It defaults to the\n * system time zone.\n */\n// don't need \"e.g.: America/New_York\" in message:  the default is an example\n@Option(value = \"<timezone> time zone, e.g.: America/New_York\", noDocDefault = true)\npublic static String timezone1 = TimeZone.getDefault().getID();"
            ],
            [
                "tz1",
                "plume",
                "ICalAvailable",
                "// Either of these initializations causes a NullPointerException\n// at net.fortuna.ical4j.model.TimeZone.<init>(TimeZone.java:67)\n// static TimeZone tz1 = new TimeZone(new VTimeZone());\n// static TimeZone tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));\nstatic TimeZone /*@MonotonicNonNull*/\ntz1;"
            ],
            [
                "timezone2",
                "plume",
                "ICalAvailable",
                "// If I'm outputting in a different timezone, then my notion of a \"day\"\n// may be different than the other timezone's notion of a \"day\".  This\n// doesn't seem important enough to fix right now.\n/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * If set, then free times are printed in two time zones.\n */\n@Option(\"<timezone> optional second time zone, e.g.: America/New_York\")\npublic static String /*@Nullable*/\ntimezone2;"
            ],
            [
                "tz2",
                "plume",
                "ICalAvailable",
                "static TimeZone /*@Nullable*/\ntz2;"
            ],
            [
                "debug",
                "plume",
                "ICalAvailable",
                "/// Other variables\n@Option(\"enable debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "calendars",
                "plume",
                "ICalAvailable",
                "/**\n * The appointments (the times that are unavailable for a meeting).\n */\nstatic List<Calendar> calendars = new ArrayList<Calendar>();"
            ],
            [
                "tf",
                "plume",
                "ICalAvailable",
                "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);"
            ],
            [
                "df",
                "plume",
                "ICalAvailable",
                "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);"
            ],
            [
                "dffull",
                "plume",
                "ICalAvailable",
                "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);"
            ],
            [
                "canonicalTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> canonicalTimezones = new HashMap<String, String>();"
            ],
            [
                "printedTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> printedTimezones = new HashMap<String, String>();"
            ],
            [
                "timeRegexp",
                "plume",
                "ICalAvailable",
                "static Pattern /*@Regex(4)*/\ntimeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");"
            ],
            [
                "dateFormats",
                "plume",
                "ICalAvailable",
                "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};"
            ],
            [
                "skip_checks",
                "plume",
                "BCELUtil",
                "/**\n * Controls whether the checks in checkMgen are actually performed.\n */\npublic static boolean skip_checks = false;"
            ],
            [
                "userHome",
                "plume",
                "UtilMDE",
                "static final String userHome = System.getProperty(\"user.home\");"
            ],
            [
                "args_seen",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Method\n///\n/**\n * Maps from a comma-delimited string of arg types, such as appears in a\n * method signature, to an array of Class objects, one for each arg\n * type. Example keys include: \"java.lang.String, java.lang.String,\n * java.lang.Class[]\" and \"int,int\".\n */\nstatic HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();"
            ],
            [
                "serialVersionUID",
                "plume",
                "UtilMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "NullableStringComparator",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeIntSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "split_lists",
                "plume",
                "Options",
                "/**\n * When true, an argument to a option of list type is split, on\n * whitespace, into multiple arguments each of which is added to the\n * list.  When false, each argument to an option of list type is treated\n * as a single element, no matter what characters it contains.\n */\n@Option(\"Treat arguments to lists as space-separated.\")\npublic static boolean split_lists = false;"
            ],
            [
                "serialVersionUID",
                "plume",
                "Options",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArgException",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "StringArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "short_run",
                "plume",
                "TestPlume",
                "// If true, do 100 instead of 100000 iterations when testing randomElements.\n// This saves only a little time.  However, it is significant when running\n// under instrumentation such as that of Chicory.\nstatic boolean short_run = false;"
            ],
            [
                "mass",
                "plume",
                "TestPlume",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestPlume",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestPlume",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "mass",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestOptionGroups1",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups2",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups3",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "FuzzyFloat",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "base",
                "",
                "int"
            ],
            [
                "expt",
                "",
                "int"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 10057,
        "oracle": ";",
        "oracleType": "NORMAL_POST",
        "projectName": "plume-lib-1.1.0",
        "packageName": "plume",
        "className": "MathMDE",
        "javadocTag": "@return base to the expt power",
        "methodJavadoc": "    /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */",
        "methodSourceCode": "public static long pow(long base, long expt) throws ArithmeticException{\n    return pow_fast(base, expt);\n}",
        "classJavadoc": "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
        "classSourceCode": "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "FileIOException",
                "plume"
            ],
            [
                "MathMDE",
                "plume"
            ],
            [
                "DeterministicObject",
                "plume"
            ],
            [
                "Digest",
                "plume"
            ],
            [
                "StringBuilderDelimited",
                "plume"
            ],
            [
                "OrderedPairIterator",
                "plume"
            ],
            [
                "CountingPrintWriter",
                "plume"
            ],
            [
                "MultiVersionControl",
                "plume"
            ],
            [
                "WeakIdentityHashMap",
                "plume"
            ],
            [
                "IterableIterator",
                "plume"
            ],
            [
                "Lookup",
                "plume"
            ],
            [
                "Pair",
                "plume"
            ],
            [
                "FileCompiler",
                "plume"
            ],
            [
                "MultiRandSelector",
                "plume"
            ],
            [
                "RandoopMappedCalls",
                "plume"
            ],
            [
                "Stopwatch",
                "plume"
            ],
            [
                "TaskManager",
                "plume"
            ],
            [
                "WeakHasherMap",
                "plume"
            ],
            [
                "ClassFileVersion",
                "plume"
            ],
            [
                "WeakIdentityPair",
                "plume"
            ],
            [
                "OptionsDoclet",
                "plume"
            ],
            [
                "DeclarationAnnotations",
                "plume"
            ],
            [
                "Option",
                "plume"
            ],
            [
                "RegexUtil",
                "plume"
            ],
            [
                "JWhich",
                "plume"
            ],
            [
                "TimeLimitProcess",
                "plume"
            ],
            [
                "Intern",
                "plume"
            ],
            [
                "GraphMDE",
                "plume"
            ],
            [
                "HtmlPrettyPrint",
                "plume"
            ],
            [
                "SimpleLog",
                "plume"
            ],
            [
                "OptionGroup",
                "plume"
            ],
            [
                "ICalAvailable",
                "plume"
            ],
            [
                "RandomSelector",
                "plume"
            ],
            [
                "BCELUtil",
                "plume"
            ],
            [
                "UtilMDE",
                "plume"
            ],
            [
                "Hasher",
                "plume"
            ],
            [
                "BibtexClean",
                "plume"
            ],
            [
                "LimitedSizeIntSet",
                "plume"
            ],
            [
                "Partitioner",
                "plume"
            ],
            [
                "Triple",
                "plume"
            ],
            [
                "Options",
                "plume"
            ],
            [
                "ArraysMDE",
                "plume"
            ],
            [
                "StrTok",
                "plume"
            ],
            [
                "Unpublicized",
                "plume"
            ],
            [
                "TestPlume",
                "plume"
            ],
            [
                "LimitedSizeSet",
                "plume"
            ],
            [
                "EntryReader",
                "plume"
            ],
            [
                "Filter",
                "plume"
            ],
            [
                "FuzzyFloat",
                "plume"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "negate",
                "plume",
                "MathMDE",
                "///\n/// Function versions of Java operators\n///\n/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static int negate(int a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static long negate(long a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static double negate(double a) {\n    return -a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static int bitwiseComplement(int a) {\n    return ~a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static long bitwiseComplement(long a) {\n    return ~a;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static int mul(int x, int y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static long mul(long x, long y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static double mul(double x, double y) {\n    return x * y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static int div(int x, int y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static long div(long x, long y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static double div(double x, double y) {\n    return x / y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static int mod(int x, int y) {\n    return x % y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static long mod(long x, long y) {\n    return x % y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static int lshift(int x, int y) {\n    return x << y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static long lshift(long x, long y) {\n    return x << y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static int rshiftSigned(int x, int y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static long rshiftSigned(long x, long y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static int bitwiseAnd(int x, int y) {\n    return x & y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static long bitwiseAnd(long x, long y) {\n    return x & y;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static int logicalAnd(int x, int y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static long logicalAnd(long x, long y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static int bitwiseXor(int x, int y) {\n    return x ^ y;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static long bitwiseXor(long x, long y) {\n    return x ^ y;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static int logicalXor(int x, int y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static long logicalXor(long x, long y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static int bitwiseOr(int x, int y) {\n    return x | y;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static long bitwiseOr(long x, long y) {\n    return x | y;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static int logicalOr(int x, int y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static long logicalOr(long x, long y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "sign",
                "plume",
                "MathMDE",
                "///\n/// sign\n///\n/**\n * Returns the sign of its argument.  The result is always -1, 0, or 1.\n * @param a value to have its sign taken\n * @return the sign of a: -1, 0, or 1\n */\npublic static int sign(int a) {\n    if (a == 0) {\n        return 0;\n    } else if (a > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "///\n/// exponentiation\n///\n/**\n * Returns of value of the first argument raised to the\n * power of the second argument.  The arguments are integers.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "/**\n * Returns of value of the first argument raised to the\n * power of the second argument.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "///\n/// gcd\n///\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static int gcd(int a, int b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        int tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/// gcd -- version for manipulating long (rather than int) values\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static long gcd(long a, long b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static double gcd(double a, double b) {\n    if (a == Double.POSITIVE_INFINITY || a == Double.NEGATIVE_INFINITY || Double.isNaN(a) || b == Double.POSITIVE_INFINITY || b == Double.NEGATIVE_INFINITY || Double.isNaN(b)) {\n        return Double.NaN;\n    }\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        double tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "///\n/// Modulus\n///\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nint mod_positive(int x, /*@PolyUpperBound*/\nint y) {\n    int result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static int[] modulus(int[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new int[] { remainder, modulus };\n}"
            ],
            [
                "modulus_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(int[])\n */\npublic static int[] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static int[] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    int modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(int[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().intValue();\n    }\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().intValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "/// modulus for long (as opposed to int) values\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nlong mod_positive(long x, /*@PolyUpperBound*/\nlong y) {\n    long result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static long[] modulus(long[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new long[] { remainder, modulus };\n}"
            ],
            [
                "modulus_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(long[])\n */\npublic static long[] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        long i = itor.next().longValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static long[] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    long modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(long[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().longValue();\n    }\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().longValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "///\n/// Non-Modulus\n///\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] missing_numbers(int[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length - 1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static int[] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   int range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2);\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = mod_positive(nums[i], m);\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new int[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "/// non-modulus for long (as opposed to int) values\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] missing_numbers(long[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length - 1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static long[] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   long range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2)));\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = ((int) (mod_positive(nums[i], m)));\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new long[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "getFileDigest",
                "plume",
                "Digest",
                "/**\n * This convenience method is used by both create() and verify().  It\n * reads the contents of a named file and computes a message digest\n * for it, using the specified MessageDigest object.\n * @param filename the file to read\n * @param md the MessageDigest\n * @return the message digest\n * @throws IOException if there is a problem reading the file\n */\npublic static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    // Read to the end of the file, discarding everything we read. {\n    // The DigestInputStream automatically passes all the bytes read to\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) {\n        /* do nothing */\n    }\n    // Finally, compute and return the digest value.\n    byte[] result = md.digest();\n    in.close();\n    return result;\n}"
            ],
            [
                "hexEncode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert an array of bytes to a String.  We do\n * this simply by converting each byte to two hexadecimal digits.  Something\n * like Base 64 encoding is more compact, but harder to encode.\n * @param bytes the bytes to convert to a String\n * @return a String representation of the input bytes\n */\npublic static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}"
            ],
            [
                "hexDecode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert from a string\n * of hexadecimal digits to an array of bytes.\n * This method is the reverse of {@link #hexEncode(byte[])}.\n * @param s the String to convert to an array of bytes\n * @return the bytes equivalent to the input String\n */\npublic static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9')) {\n                digit1 -= '0';\n            } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n                digit1 -= 'a' - 10;\n            }\n            if ((digit2 >= '0') && (digit2 <= '9')) {\n                digit2 -= '0';\n            } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n                digit2 -= 'a' - 10;\n            }\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}"
            ],
            [
                "dirToCheckoutHg",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".hg\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutHg(File hgDir, File dir) {\n    String repository = null;\n    File hgrcFile = new File(hgDir, \"hgrc\");\n    Ini ini;\n    // There also exist Hg commands that will do this same thing.\n    if (hgrcFile.exists()) {\n        try {\n            ini = new Ini(new FileReader(hgrcFile));\n        } catch (IOException e) {\n            throw new Error(\"Problem reading file \" + hgrcFile);\n        }\n        Ini.Section pathsSection = ini.get(\"paths\");\n        if (pathsSection != null) {\n            repository = pathsSection.get(\"default\");\n            if (repository != null && repository.endsWith(\"/\")) {\n                repository = repository.substring(0, repository.length() - 1);\n            }\n        }\n    }\n    return new Checkout(RepoType.HG, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutGit",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".git\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutGit(File gitDir, File dir) {\n    String repository = UtilMDE.backticks(\"git\", \"config\", \"remote.origin.url\");\n    return new Checkout(RepoType.GIT, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutSvn",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory that contains a .svn subdirectory, create a\n * corresponding Checkout object.\n * Returns null if this is not possible.\n */\nstatic /*@Nullable*/\nCheckout dirToCheckoutSvn(File dir) {\n    // For SVN, do\n    //   svn info\n    // and grep out these lines:\n    //   URL: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository/trunk/www\n    //   Repository Root: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository\n    // Use SVNKit?\n    // Con: introduces dependency on external library.\n    // Pro: no need to re-implement or to call external process (which\n    //   might be slow for large checkouts).\n    // unannotated library: SVNKit\n    @SuppressWarnings(\"nullness\")\n    SVNWCClient wcClient = new SVNWCClient((/*@Nullable*/\n    ISVNAuthenticationManager) null, null);\n    SVNInfo info;\n    try {\n        info = wcClient.doInfo(new File(dir.toString()), SVNRevision.WORKING);\n    } catch (SVNException e) {\n        // throw new Error(\"Problem in dirToCheckoutSvn(\" + dir + \"): \", e);\n        System.err.println(\"Problem in dirToCheckoutSvn(\" + dir + \"): \" + e.getMessage());\n        if (e.getMessage() != null && e.getMessage().contains(\"This client is too old\")) {\n            System.err.println(\"plume-lib needs a newer version of SVNKit.\");\n        }\n        return null;\n    }\n    // getFile is null when operating on a working copy, as I am\n    // String relativeFile = info.getPath(); // relative to repository root -- can use to determine root of checkout\n    // getFile is just the (absolute) local file name for local items -- same as \"dir\"\n    // File relativeFile = info.getFile();\n    SVNURL url = info.getURL();\n    // This can be null (example: dir /afs/csail.mit.edu/u/m/mernst/.snapshot/class/6170/2006-spring/3dphysics).  I don't know under what circumstances.\n    SVNURL repoRoot = info.getRepositoryRootURL();\n    if (repoRoot == null) {\n        System.err.println(\"Problem:  old svn working copy in \" + dir.toString());\n        System.err.println(\"Check it out again to get a 'Repository Root' entry in the svn info output.\");\n        System.err.println(\"  repoUrl = \" + url);\n        System.exit(2);\n    }\n    if (debug) {\n        System.out.println();\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"     dir = \" + dir.toString());\n    }\n    // Strip common suffix off of local dir and repo url.\n    Pair<File, File> /*@Nullable*/\n    /*@Nullable*/\n    stripped = removeCommonSuffixDirs(dir, new File(url.getPath()), new File(repoRoot.getPath()), \".svn\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n        System.out.printf(\"dir (%s) is parent of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    if (stripped.b == null) {\n        System.out.printf(\"dir (%s) is child of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    String pathInRepoAtCheckout = stripped.b.toString();\n    try {\n        url = url.setPath(pathInRepoAtCheckout, false);\n    } catch (SVNException e) {\n        throw new Error(e);\n    }\n    if (debug) {\n        System.out.println(\"stripped: \" + stripped);\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"    cDir = \" + cDir.toString());\n    }\n    assert url.toString().startsWith(repoRoot.toString()) : \"repoRoot=\" + repoRoot + \", url=\" + url;\n    return new Checkout(RepoType.SVN, cDir, url.toString(), null);\n    /// Old implementation\n    // String module = url.toString().substring(repoRoot.toString().length());\n    // if (module.startsWith(\"/\")) {\n    //   module = module.substring(1);\n    // }\n    // if (module.equals(\"\")) {\n    //   module = null;\n    // }\n    // return new Checkout(RepoType.SVN, cDir, repoRoot.toString(), module);\n}"
            ],
            [
                "removeCommonSuffixDirs",
                "plume",
                "MultiVersionControl",
                "/**\n * Strip identical elements off the end of both paths, and then return\n * what is left of each.  Returned elements can be null!  If p2_limit is\n * non-null, then it should be a parent of p2, and the stripping stops\n * when p2 becomes p2_limit.  If p1_contains is non-null, then p1 must\n * contain a subdirectory of that name.\n */\nstatic Pair</*@Nullable*/\nFile, /*@Nullable*/\nFile> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains) {\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\", p1, p2, p2_limit, p1_contains);\n    }\n    // new names for results, because we will be side-effecting them\n    File r1 = p1;\n    File r2 = p2;\n    while (r1 != null && r2 != null && (p2_limit == null || !r2.equals(p2_limit)) && r1.getName().equals(r2.getName())) {\n        if (p1_contains != null && !new File(r1.getParentFile(), p1_contains).isDirectory()) {\n            break;\n        }\n        r1 = r1.getParentFile();\n        r2 = r2.getParentFile();\n    }\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs => %s %s%n\", r1, r2);\n    }\n    return Pair.of(r1, r2);\n}"
            ],
            [
                "eq",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Check for equality of non-null reference x and possibly-null y.  Uses\n * identity equality.\n */\n/*@Pure*/\nstatic boolean eq(Object x, /*@Nullable*/\nObject y) {\n    return x == y;\n}"
            ],
            [
                "hasher",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return the hash code for x\n */\n/*@Pure*/\nstatic int hasher(Object x) {\n    return System.identityHashCode(x);\n}"
            ],
            [
                "indexFor",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return index for hash code h.\n */\n/*@Pure*/\nstatic int indexFor(int h, int length) {\n    return h & (length - 1);\n}"
            ],
            [
                "old_get_entry",
                "plume",
                "Lookup",
                "/**\n * Returns the next entry.  If no more entries are available, returns null.\n * @param reader where to read the entry from\n * @return the next entry, or null\n * @throws IOException if there is a problem reading a file\n */\npublic static /*@Nullable*/\nEntry old_get_entry(EntryReader reader) throws IOException {\n    try {\n        // Skip any preceeding blank lines\n        String line = reader.readLine();\n        while ((line != null) && (line.trim().length() == 0)) {\n            line = reader.readLine();\n        }\n        if (line == null) {\n            return (null);\n        }\n        Entry entry = null;\n        String filename = reader.getFileName();\n        long line_number = reader.getLineNumber();\n        // If this is a long entry\n        if (line.startsWith(\">entry\")) {\n            // Get the current filename\n            String current_filename = reader.getFileName();\n            // Remove '>entry' from the line\n            line = line.replaceFirst(\"^>entry *\", \"\");\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find the termination of the entry\n            while ((line != null) && !line.startsWith(\">entry\") && !line.equals(\"<entry\") && current_filename.equals(reader.getFileName())) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            // If this entry was terminated by the start of the next one,\n            // put that line back\n            if ((line != null) && (line.startsWith(\">entry\") || !current_filename.equals(reader.getFileName()))) {\n                reader.putback(line);\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, false);\n        } else {\n            // blank separated entry\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find another blank line\n            while ((line != null) && (line.trim().length() != 0)) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, true);\n        }\n        return (entry);\n    } catch (FileNotFoundException e) {\n        System.out.printf(\"Error: Can't read %s at line %d in file %s%n\", e.getMessage(), reader.getLineNumber(), reader.getFileName());\n        System.exit(254);\n        return (null);\n    }\n}"
            ],
            [
                "first_line",
                "plume",
                "Lookup",
                "/**\n * Returns the first line of entry.\n * @param entry the entry whose first line to return\n * @return the first line of entry\n */\npublic static String first_line(String entry) {\n    int ii = entry.indexOf(lineSep);\n    if (ii == -1) {\n        return entry;\n    }\n    return entry.substring(0, ii);\n}"
            ],
            [
                "of",
                "plume",
                "Pair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a pair of the values (a, b)\n */\npublic static <A extends /*@Nullable*/\nObject, B extends /*@Nullable*/\nObject> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "short_str",
                "plume",
                "TaskManager",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "short_str",
                "plume",
                "Task",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "versionNumbers",
                "plume",
                "ClassFileVersion",
                "/**\n * Return an array of the major vernios, minor version, and JDK version\n * of the class read from the input stream.\n * Return null if there is an error or the input isn't a class file.\n * @param is input stream from which to read a class\n * @return array of three version numbers\n */\npublic static double[] versionNumbers(InputStream is) {\n    try {\n        DataInputStream dis = new DataInputStream(is);\n        int magic = dis.readInt();\n        if (magic != 0xcafebabe) {\n            return null;\n        }\n        double minor = dis.readShort();\n        double major = dis.readShort();\n        double jdkVersion;\n        if (major < 48) {\n            // really 1.3.1\n            jdkVersion = 1.3;\n        } else if (major == 48) {\n            // really 1.4.2\n            jdkVersion = 1.4;\n        } else if (major == 49) {\n            jdkVersion = 1.5;\n        } else if (major == 50) {\n            jdkVersion = 6;\n        } else {\n            jdkVersion = 7;\n        }\n        return new double[] { major, minor, jdkVersion };\n    } catch (IOException e) {\n        return null;\n    }\n}"
            ],
            [
                "of",
                "plume",
                "WeakIdentityPair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a WeakIdentityPair of (a, b)\n */\npublic static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b) {\n    return new WeakIdentityPair<A, B>(a, b);\n}"
            ],
            [
                "start",
                "plume",
                "OptionsDoclet",
                "// Doclet-specific methods\n/**\n * Entry point for the doclet.\n * @param root the root document\n * @return true if processing completed without an error\n */\npublic static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n        // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n        // returns a fully qualified name.  I do not know a good way to convert\n        // between these two name formats.  For now, we simply ignore inner\n        // classes.  This limitation can be removed when we figure out a better\n        // way to go from ClassDoc to Class<?>.\n        if (doc.containingClass() != null) {\n            continue;\n        }\n        Class<?> clazz;\n        try {\n            // Javadoc source code is not yet annotated\n            @SuppressWarnings(\"signature\")\n            String /*@BinaryNameForNonArray*/\n            className = doc.qualifiedName();\n            clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        }\n        if (needsInstantiation(clazz)) {\n            try {\n                Constructor<?> c = clazz.getDeclaredConstructor();\n                c.setAccessible(true);\n                objs.add(c.newInstance(new Object[0]));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            objs.add(clazz);\n        }\n    }\n    if (objs.isEmpty()) {\n        System.out.println(\"Error: no classes found\");\n        return false;\n    }\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n        System.out.println(\"Error: no @Option-annotated fields found\");\n        return false;\n    }\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n        o.write();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "optionLength",
                "plume",
                "OptionsDoclet",
                "/**\n * Given a command-line option of this doclet, returns the number of\n * arguments you must specify on the command line for the given option.\n * Returns 0 if the argument is not recognized.  This method is\n * automatically invoked.\n *\n * @param option the command-line option\n * @return the number of command-line arguments needed when using the option\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n        System.out.printf(USAGE);\n        return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n        return 1;\n    }\n    if (option.equals(\"-docfile\") || option.equals(\"-outfile\") || option.equals(\"-format\") || option.equals(\"-d\")) {\n        return 2;\n    }\n    return 0;\n}"
            ],
            [
                "validOptions",
                "plume",
                "OptionsDoclet",
                "/**\n * Tests the validity of command-line arguments passed to this doclet.\n * Returns true if the option usage is valid, and false otherwise.  This\n * method is automatically invoked.\n *\n * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n * @param reporter where to report errors\n * @return true iff the command-line options are valid\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            if (hasDocFile) {\n                reporter.printError(\"-docfile option specified twice\");\n                return false;\n            }\n            File f = new File(os[1]);\n            if (!f.exists()) {\n                reporter.printError(\"-docfile file not found: \" + os[1]);\n                return false;\n            }\n            docFile = os[1];\n            hasDocFile = true;\n        }\n        if (opt.equals(\"-outfile\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-outfile option specified twice\");\n                return false;\n            }\n            if (inPlace) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            outFile = os[1];\n            hasOutFile = true;\n        }\n        if (opt.equals(\"-i\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            inPlace = true;\n        }\n        if (opt.equals(\"-format\")) {\n            if (hasFormat) {\n                reporter.printError(\"-format option specified twice\");\n                return false;\n            }\n            if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n                reporter.printError(\"unrecognized output format: \" + os[1]);\n                return false;\n            }\n            hasFormat = true;\n        }\n        if (opt.equals(\"-d\")) {\n            if (hasDestDir) {\n                reporter.printError(\"-d specified twice\");\n                return false;\n            }\n            hasDestDir = true;\n        }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n        reporter.printError(\"docfile must be different from outfile\");\n        return false;\n    }\n    if (inPlace && docFile == null) {\n        reporter.printError(\"-i supplied but -docfile was not\");\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "javadocToHtml",
                "plume",
                "OptionsDoclet",
                "/**\n * Replace the @link tags and block @see tags in a Javadoc comment with\n * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n * comment while still being presentable. <p>\n *\n * This is only a temporary solution.  Ideally, @link/@see tags would be\n * converted to HTML links that point to actual documentation.\n *\n * @param doc a Javadoc comment to convert to HTML\n * @return HTML version of doc\n */\npublic static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n        if (tag instanceof SeeTag) {\n            b.append(\"<code>\" + tag.text() + \"</code>\");\n        } else {\n            b.append(tag.text());\n        }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n        b.append(\" See: \");\n        {\n            StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n            for (SeeTag tag : seetags) {\n                bb.append(\"<code>\" + tag.text() + \"</code>\");\n            }\n            b.append(bb);\n        }\n        b.append(\".\");\n    }\n    return b.toString();\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param s string to check for being a regular expression\n * @return true iff s is a regular expression\n */\n/*@Pure*/\n/*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\npublic static boolean isRegex(String s) {\n    return isRegex(s, 0);\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression with at least the given number of groups.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return true iff s is a regular expression with groups groups\n */\n// RegexUtil; for purity, catches an exception\n@SuppressWarnings({ \"regex\", \"deterministic\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(String s, int groups) {\n    Pattern p;\n    try {\n        p = Pattern.compile(s);\n    } catch (PatternSyntaxException e) {\n        return false;\n    }\n    return getGroupCount(p) >= groups;\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param c char to check for being a regular expression\n * @return true iff c is a regular expression\n */\n@SuppressWarnings({ \"regex\", \"purity.not.deterministic.call\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(char c) {\n    return isRegex(Character.toString(c));\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a string describing why the argument is\n * not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nString regexError(String s) {\n    return regexError(s, 0);\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns\n * a string describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil;\n@SuppressWarnings({ \"regex\", \"not.sef\" })\npublic static /*@Nullable*/\nString regexError(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return regexErrorMessage(s, groups, actualGroups);\n        }\n    } catch (PatternSyntaxException e) {\n        return e.getMessage();\n    }\n    return null;\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a PatternSyntaxException describing\n * why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s) {\n    return regexException(s, 0);\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns a\n * PatternSyntaxException describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return new PatternSyntaxException(regexErrorMessage(s, groups, actualGroups), s, -1);\n        }\n    } catch (PatternSyntaxException pse) {\n        return pse;\n    }\n    return null;\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex String} if it is a regex,\n * otherwise throws an error. The purpose of this method is to suppress Regex\n * Checker warnings. It should be very rarely needed.\n * @param s string to check for being a regular expression\n * @return its argument\n * @throws Error if argument is not a regex\n */\n/*@SideEffectFree*/\n// The return type annotation is a conservative bound.\npublic static /*@Regex*/\nString asRegex(String s) {\n    return asRegex(s, 0);\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex(groups) String} if it is a regex\n * with at least the given number of groups, otherwise throws an error. The\n * purpose of this method is to suppress Regex Checker warnings. It should\n * be very rarely needed.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return its argument\n * @throws Error if argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Regex*/\nString asRegex(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            throw new Error(regexErrorMessage(s, groups, actualGroups));\n        }\n        return s;\n    } catch (PatternSyntaxException e) {\n        throw new Error(e);\n    }\n}"
            ],
            [
                "findClass",
                "plume",
                "JWhich",
                "/**\n * Returns the URL of the resource denoted by the specified\n * class name, as prescribed by the class path.\n *\n * @param className name of the class\n * @return class URL, or null of the class was not found\n */\npublic static /*@Nullable*/\nURL findClass(final String className) {\n    return JWhich.class.getResource(asResourceName(className));\n}"
            ],
            [
                "asResourceName",
                "plume",
                "JWhich",
                "protected static String asResourceName(String resource) {\n    if (!resource.startsWith(\"/\")) {\n        resource = \"/\" + resource;\n    }\n    resource = resource.replace('.', '/');\n    resource = resource + \".class\";\n    return resource;\n}"
            ],
            [
                "getClasspath",
                "plume",
                "JWhich",
                "/**\n * Return the classpath.\n * @return the classpath\n */\n/*@EnsuresNonNull(\"CLASSPATH\")*/\nprotected static String getClasspath() {\n    if (CLASSPATH == null) {\n        String classpath = System.getProperty(\"java.class.path\");\n        setClasspath(classpath);\n    }\n    return CLASSPATH;\n}"
            ],
            [
                "internStrings",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Strings\n///\n/**\n * Replace each element of the array by its interned version.\n * Side-effects the array, but also returns it.\n * @param a the array whose elements to intern in place\n * @return an interned version of a\n * @see String#intern\n */\n// side-effects the array in place (dangerous, but convenient)\n@SuppressWarnings(\"interning\")\npublic static String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] != null) {\n            a[i] = a[i].intern();\n        }\n    }\n    return a;\n}"
            ],
            [
                "isInterned",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Testing interning\n///\n/**\n * Return true if the argument is interned (is canonical among all\n * objects equal to itself).\n * @param value the value to test for interning\n * @return true iff value is interned\n */\n// interning implementation\n@SuppressWarnings(\"interning\")\npublic static /*@Pure*/\nboolean isInterned(/*@Nullable*/\nObject value) {\n    if (value == null) {\n        // nothing to do\n        return true;\n    } else if (value instanceof String) {\n        return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n        return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n        return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n        return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n        return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n        return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n        return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n        return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n        return (value == intern((Object[]) value));\n    } else {\n        // Nothing to do, because we don't intern other types.\n        // System.out.println(\"What type? \" + value.getClass().getName());\n        return true;\n    }\n}"
            ],
            [
                "numIntegers",
                "plume",
                "Intern",
                "// For testing only\npublic static int numIntegers() {\n    return internedIntegers.size();\n}"
            ],
            [
                "numLongs",
                "plume",
                "Intern",
                "public static int numLongs() {\n    return internedLongs.size();\n}"
            ],
            [
                "numIntArrays",
                "plume",
                "Intern",
                "public static int numIntArrays() {\n    return internedIntArrays.size();\n}"
            ],
            [
                "numLongArrays",
                "plume",
                "Intern",
                "public static int numLongArrays() {\n    return internedLongArrays.size();\n}"
            ],
            [
                "numDoubles",
                "plume",
                "Intern",
                "public static int numDoubles() {\n    return internedDoubles.size();\n}"
            ],
            [
                "numDoubleArrays",
                "plume",
                "Intern",
                "public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n}"
            ],
            [
                "numStringArrays",
                "plume",
                "Intern",
                "public static int numStringArrays() {\n    return internedStringArrays.size();\n}"
            ],
            [
                "numObjectArrays",
                "plume",
                "Intern",
                "public static int numObjectArrays() {\n    return internedObjectArrays.size();\n}"
            ],
            [
                "integers",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nInteger> integers() {\n    return internedIntegers.keySet().iterator();\n}"
            ],
            [
                "longs",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nLong> longs() {\n    return internedLongs.keySet().iterator();\n}"
            ],
            [
                "intArrays",
                "plume",
                "Intern",
                "public static Iterator<int[]> intArrays() {\n    return internedIntArrays.keySet().iterator();\n}"
            ],
            [
                "longArrays",
                "plume",
                "Intern",
                "public static Iterator<long[]> longArrays() {\n    return internedLongArrays.keySet().iterator();\n}"
            ],
            [
                "doubles",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nDouble> doubles() {\n    return internedDoubles.keySet().iterator();\n}"
            ],
            [
                "doubleArrays",
                "plume",
                "Intern",
                "public static Iterator<double[]> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n}"
            ],
            [
                "stringArrays",
                "plume",
                "Intern",
                "public static Iterator<String[]> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n}"
            ],
            [
                "objectArrays",
                "plume",
                "Intern",
                "public static Iterator<Object[]> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a String.\n * Delegates to the builtin String.intern() method.\n * Provided for completeness.\n * @param a the string to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static /*@Interned*/\n/*@PolyNull*/\nString intern(/*@PolyNull*/\nString a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n        return null;\n    }\n    return a.intern();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a long.\n * A no-op.  Provided for completeness.\n * @param l the long to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static long intern(long l) {\n    return l;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a double\n * A no-op.  Provided for completeness.\n * @param d the double to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static double intern(double d) {\n    return d;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Integer.\n * Return a canonical representation for the Integer.\n * @param a an Integer to canonicalize\n * @return a canonical representation for the Integer\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Intern.valueOf is intended to promise\n// the same).  This does not currently take advantage of that.\n// interning implementation\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nInteger intern(Integer a) {\n    WeakReference<Integer> /*@Interned*/\n    lookup = internedIntegers.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Integer /*@Interned*/\n        result = (/*@Interned*/\n        Integer) a;\n        internedIntegers.put(result, new WeakReference</*@Interned*/\n        Integer>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nInteger internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value parsed from the string.\n * @param s the string to parse\n * @return an interned Integer parsed from s\n */\npublic static /*@Interned*/\nInteger internedInteger(String s) {\n    return intern(Integer.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Long.\n * Return a canonical representation for the Long.\n * @param a the value to intern\n * @return a canonical representation for the Long\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Long.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nLong intern(Long a) {\n    WeakReference<Long> /*@Interned*/\n    lookup = internedLongs.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Long /*@Interned*/\n        result = (/*@Interned*/\n        Long) a;\n        internedLongs.put(result, new WeakReference</*@Interned*/\n        Long>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nLong internedLong(long i) {\n    return intern(Long.valueOf(i));\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value parsed from the string.\n * @param s the string to parse\n * @return an interned Long parsed from s\n */\npublic static /*@Interned*/\nLong internedLong(String s) {\n    return intern(Long.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) an int[].\n * Return a canonical representation for the int[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the int[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static int[] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        int[] /*@Interned*/\n        result = (int[]) a;\n        internedIntArrays.put(result, new WeakReference<int[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a long[].\n * Return a canonical representation for the long[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the long[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static long[] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        long[] /*@Interned*/\n        result = (long[]) a;\n        internedLongArrays.put(result, new WeakReference<long[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Double.\n * Return a canonical representation for the Double.\n * @param a the Double to canonicalize\n * @return a canonical representation for the Double\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Double.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nDouble intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n        return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) {\n        // catches both positive and negative zero\n        return internedDoubleZero;\n    }\n    WeakReference<Double> /*@Interned*/\n    lookup = internedDoubles.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Double /*@Interned*/\n        result = (/*@Interned*/\n        Double) a;\n        internedDoubles.put(result, new WeakReference</*@Interned*/\n        Double>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value i.\n * @param d the value to intern\n * @return an interned Double with value d\n */\npublic static /*@Interned*/\nDouble internedDouble(double d) {\n    return intern(Double.valueOf(d));\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value parsed from the string.\n * @param s the string to parse\n * @return an interned Double parsed from s\n */\npublic static /*@Interned*/\nDouble internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) a double[].\n * Return a canonical representation for the double[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the double[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static double[] intern(double[] a) {\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        double[] /*@Interned*/\n        result = (double[]) a;\n        internedDoubleArrays.put(result, new WeakReference<double[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an String[].\n * Return a canonical representation for the String[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the String[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static String[] intern(/*@PolyNull*/\n/*@Interned*/\nString[] a) {\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n        assert a[k] == Intern.intern(a[k]);\n    }\n    WeakReference<String[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    String[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (String[]) a;\n        internedStringArrays.put(result, new WeakReference<String[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    String[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Object[].\n * Return a canonical representation for the Object[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the Object[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static Object[] intern(/*@PolyNull*/\n/*@Interned*/\nObject[] a) {\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    WeakReference<Object[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    Object[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (Object[]) a;\n        internedObjectArrays.put(result, new WeakReference<Object[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    Object[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Convenince method to intern an Object when we don't know its\n * runtime type.  Its runtime type must be one of the types for\n * which we have an intern() method, else an exception is thrown.\n * If the argument is an array, its elements should themselves be\n * interned.\n * @param a an Object to canonicalize\n * @return a canonical version of a\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Interned*/\n/*@PolyNull*/\nObject intern(/*@PolyNull*/\nObject a) {\n    if (a == null) {\n        return null;\n    } else if (a instanceof String) {\n        return intern((String) a);\n    } else if (a instanceof String[]) {\n        @SuppressWarnings(\"interning\")\n        String[] /*@Interned*/\n        asArray = (String[]) a;\n        return intern(asArray);\n    } else if (a instanceof Integer) {\n        return intern((Integer) a);\n    } else if (a instanceof Long) {\n        return intern((Long) a);\n    } else if (a instanceof int[]) {\n        return intern((int[]) a);\n    } else if (a instanceof long[]) {\n        return intern((long[]) a);\n    } else if (a instanceof Double) {\n        return intern((Double) a);\n    } else if (a instanceof double[]) {\n        return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n        @SuppressWarnings(\"interning\")\n        Object[] /*@Interned*/\n        asArray = (Object[]) a;\n        return intern(asArray);\n    } else {\n        throw new IllegalArgumentException(\"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * Return the subsequence of seq from start (inclusive) to end\n * (exclusive) that is interned.  What's different about this method\n * from manually finding the subsequence and interning the\n * subsequence is that if the subsequence is already interned, we\n * can avoid having to compute the sequence.  Since derived\n * variables in Daikon compute the subsequence many times, this\n * shortcut saves quite a bit of computation.  It saves even more\n * when there may be many derived variables that are non-canonical,\n * since they are guaranteed to be ==.\n * <p>\n * Requires that seq is already interned.\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n */\npublic static int[] internSubsequence(int[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int[]> /*@Interned*/\n    sai = new SequenceAndIndices<int[]>(seq, start, end);\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n        int[] /*@Interned*/\n        subseq = Intern.intern(subseqUninterned);\n        internedIntSequenceAndIndices.put(sai, new WeakReference<int[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static long[] internSubsequence(long[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long[]> /*@Interned*/\n    sai = new SequenceAndIndices<long[]>(seq, start, end);\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        long[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedLongSequenceAndIndices.put(sai, new WeakReference<long[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static double[] internSubsequence(double[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double[]> /*@Interned*/\n    sai = new SequenceAndIndices<double[]>(seq, start, end);\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        double[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedDoubleSequenceAndIndices.put(sai, new WeakReference<double[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static Object[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nObject[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<Object[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedObjectSequenceAndIndices.put(sai, new WeakReference<Object[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static String[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nString[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<String[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedStringSequenceAndIndices.put(sai, new WeakReference<String[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "dominators",
                "plume",
                "GraphMDE",
                "// Algorithms for computing dominators:\n//\n// Wikipedia:\n//  // dominator of the start node is the start itself\n//  Dom(n_0) = {n_0}\n//  // for all other nodes, set all nodes as the dominators\n//  for each n in N - {n_0}\n//      Dom(n) = N;\n//  // iteratively eliminate nodes that are not dominators\n//  while changes in any Dom(n)\n//      for each n in N - {n_0}:\n//          Dom(n) = {n} union with intersection over all p in pred(n) of Dom(p)\n//\n// Cooper/Harvey/Kennedy:\n//  for all nodes, n\n//    DOM[n] := {1 . . .N}\n//  Changed := true\n//  while (Changed)\n//    Changed := false\n//    for all nodes, n, in reverse postorder\n//      new_set := (Intersect_{p:=preds(n)} DOM[p]) union {n}\n//      if (new_set != DOM[n])\n//        DOM[n] := new_set\n//        Changed := true\n// The two algorithms are essentially the same; this implementation\n// follows the Wikipedia one.\n/**\n * Computes, for each node in the graph, its set of (pre-)dominators.\n * Supply a successor graph if you want post-dominators.\n * @param <T> type of the graph nodes\n * @param predecessors a graph, represented as a predecessor map\n * @return a map from each node to a list of its pre-dominators\n */\npublic static <T> Map<T, List<T>> dominators(Map<T, List</*@KeyFor(\"#1\")*/\nT>> predecessors) {\n    // Map</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>> dom = new HashMap</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>>();\n    Map<T, List<T>> dom = new HashMap<T, List<T>>();\n    // every element of pred's value will be a key for dom\n    @SuppressWarnings(\"keyfor\")\n    Map<T, List<T>> /*@KeyFor({\"dom\"})*/\n    preds = predecessors;\n    List<T> nodes = new ArrayList<T>(preds.keySet());\n    // Compute roots & non-roots, for convenience\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    roots = new ArrayList<T>();\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    non_roots = new ArrayList<T>();\n    // Initialize result:  for roots just the root, otherwise everything\n    for (T node : preds.keySet()) {\n        if (preds.get(node).isEmpty()) {\n            // This is a root.  Its only dominator is itself.\n            Set<T> set = Collections.singleton(node);\n            dom.put(node, new ArrayList<T>(set));\n            roots.add(node);\n        } else {\n            // Initially, set all nodes as dominators;\n            // will later remove nodes that aren't dominators.\n            dom.put(node, new ArrayList<T>(nodes));\n            non_roots.add(node);\n        }\n    }\n    assert roots.size() + non_roots.size() == nodes.size();\n    // Invariants:\n    // preds and dom have the same keyset.\n    // All of the following are keys for both preds and dom:\n    //  * every key in pred\n    //  * elery element of every pred value\n    //  * every key in dom\n    //  * elery element of every dom value\n    // So, the type of pred is now\n    //\n    // rather than its original type\n    //   Map<T,List</*@KeyFor(\"preds\")*/ T>> preds\n    boolean changed = true;\n    while (changed) {\n        changed = false;\n        for (T node : non_roots) {\n            List<T> new_doms = null;\n            assert preds.containsKey(node);\n            for (T pred : preds.get(node)) {\n                assert dom.containsKey(pred);\n                /*@NonNull*/\n                List<T> dom_of_pred = dom.get(pred);\n                if (new_doms == null) {\n                    // make copy because we may side-effect new_doms\n                    new_doms = new ArrayList<T>(dom_of_pred);\n                } else {\n                    new_doms.retainAll(dom_of_pred);\n                }\n            }\n            assert new_doms != null : \"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\";\n            new_doms.add(node);\n            assert dom.containsKey(node);\n            if (!dom.get(node).equals(new_doms)) {\n                dom.put(node, new_doms);\n                changed = true;\n            }\n        }\n    }\n    for (T node : preds.keySet()) {\n        // TODO: The following two assert statements would be easier to read\n        // than the one combined one, but a bug (TODO:  Jonathan will add a\n        // bug number) prevents it from type-checking.\n        // assert dom.containsKey(node);\n        // assert dom.get(node).contains(node);\n        assert dom.containsKey(node) && dom.get(node).contains(node);\n    }\n    return dom;\n}"
            ],
            [
                "canonicalizeTimezone",
                "plume",
                "ICalAvailable",
                "static String canonicalizeTimezone(String timezone) {\n    String result = canonicalTimezones.get(timezone.toLowerCase());\n    return (result == null) ? timezone : result;\n}"
            ],
            [
                "printedTimezone",
                "plume",
                "ICalAvailable",
                "/*@Pure*/\nstatic String printedTimezone(TimeZone tz) {\n    String tzString = tz.getDisplayName();\n    String result = printedTimezones.get(tzString);\n    return (result == null) ? tzString : result;\n}"
            ],
            [
                "parseTime",
                "plume",
                "ICalAvailable",
                "// Parse a time like \"9:30pm\"\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nDateTime parseTime(String time) {\n    Matcher m = timeRegexp.matcher(time);\n    if (!m.matches()) {\n        System.err.println(\"Bad time: \" + time);\n        System.exit(1);\n    }\n    @SuppressWarnings(// Regex Checker imprecision:  matches() guarantees that group 1 exists in regexp\n    \"nullness\")\n    String /*@NonNull*/\n    hourString = m.group(1);\n    String minuteString = m.group(3);\n    String ampmString = m.group(4);\n    int hour = Integer.parseInt(hourString);\n    if ((ampmString != null) && ampmString.toLowerCase().equals(\"pm\")) {\n        hour += 12;\n    }\n    int minute = 0;\n    if (minuteString != null) {\n        minute = Integer.parseInt(minuteString);\n    }\n    DateTime result = new DateTime();\n    result.setTimeZone(tz1);\n    result.setHours(hour);\n    result.setMinutes(minute);\n    result.setSeconds(0);\n    return result;\n}"
            ],
            [
                "rangeString",
                "plume",
                "ICalAvailable",
                "static String rangeString(Period p, TimeZone tz) {\n    tf.setTimeZone(tz);\n    DateTime pstart = p.getStart();\n    DateTime pend = p.getEnd();\n    String rangeString = tf.format(pstart) + \" to \" + tf.format(pend);\n    rangeString = rangeString.replace(\" AM\", \"am\");\n    rangeString = rangeString.replace(\" PM\", \"pm\");\n    return rangeString;\n}"
            ],
            [
                "periodListString",
                "plume",
                "ICalAvailable",
                "static String periodListString(PeriodList pl, TimeZone tz) {\n    tf.setTimeZone(tz);\n    StringBuilder result = new StringBuilder();\n    // \"Object\" because PeriodList extends TreeSet, but it really ought to\n    // extend TreeSet</*@NonNull*/ Period>\n    for (Object p : pl) {\n        assert p != null : \"@AssumeAssertion(nullness): non-generic container class; elements are non-null\";\n        result.append(rangeString((Period) p, tz) + \"\\n\");\n    }\n    return result.toString();\n}"
            ],
            [
                "mergeDateAndTime",
                "plume",
                "ICalAvailable",
                "/**\n * Creates a new DateTime with date taken from the first argument and\n * time taken from the second argument.\n * @return the merged DateTime\n */\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic DateTime mergeDateAndTime(DateTime date, DateTime time) {\n    if (!date.getTimeZone().equals(time.getTimeZone())) {\n        throw new Error(String.format(\"non-matching timezones: %s %s\", date.getTimeZone(), time.getTimeZone()));\n    }\n    DateTime result = new DateTime(date);\n    result.setHours(time.getHours());\n    result.setMinutes(time.getMinutes());\n    result.setSeconds(time.getSeconds());\n    return result;\n}"
            ],
            [
                "oneDayAvailable",
                "plume",
                "ICalAvailable",
                "// TODO:  don't propose times that are before the current moment.\n// Process day-by-day because otherwise weekends and evenings are included.\n// for iCal4j\n@SuppressWarnings(\"unchecked\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nList<Period> oneDayAvailable(DateTime day, List<Calendar> calendars) {\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...)%n\", day);\n    }\n    List<Period> result = new ArrayList<Period>();\n    // for iCal4j\n    @SuppressWarnings(\"deprecation\")\n    int dayOfWeek = day.getDay();\n    if (!businessDays.contains(dayOfWeek)) {\n        return result;\n    }\n    for (Period bh : businessHours) {\n        DateTime start = mergeDateAndTime(day, bh.getStart());\n        DateTime end = mergeDateAndTime(day, bh.getEnd());\n        VFreeBusy request = new VFreeBusy(start, end, new Dur(0, 0, 0, 1));\n        if (debug) {\n            System.out.println(\"Request = \" + request);\n        }\n        ComponentList busyTimes = new ComponentList();\n        // Problem:  any all-day events will be treated as UTC.\n        // Instead, they should be converted to local time (tz1).\n        // But VFreeBusy does not support this, so I may need to convert\n        // daily events into a different format before inserting them.\n        for (Calendar calendar : calendars) {\n            // getComponents() returns a raw ArrayList.  Expose its element type.\n            ArrayList<Component> /*@NonNull*/\n            clist = calendar.getComponents();\n            for (Component c : clist) {\n                if (c instanceof VEvent) {\n                    VEvent v = (VEvent) c;\n                    DtStart dts = v.getStartDate();\n                    Parameter dtsValue = dts.getParameter(\"VALUE\");\n                    boolean allDay = (dtsValue != null) && dtsValue.getValue().equals(\"DATE\");\n                    // TODO: convert to the proper timezone.\n                    // Tricky: must deal with the possibility of RRULE:FREQ=\n                }\n                busyTimes.add(c);\n            }\n        }\n        VFreeBusy response = new VFreeBusy(request, busyTimes);\n        if (debug) {\n            System.out.println(\"Response = \" + response);\n        }\n        FreeBusy freefb = (FreeBusy) response.getProperty(\"FREEBUSY\");\n        if (freefb == null) {\n            if (debug) {\n                System.out.println(\"FREEBUSY property is null\");\n            }\n            continue;\n        }\n        // interned fields from a library, but not annotated so\n        @SuppressWarnings(\"interning\")\n        boolean isFree = (freefb.getParameter(Parameter.FBTYPE) == FbType.FREE);\n        assert isFree;\n        PeriodList freePeriods = freefb.getPeriods();\n        if (debug) {\n            System.out.printf(\"Free periods: %n%s%n\", periodListString(freePeriods, tz1));\n        }\n        result.addAll(freePeriods);\n    }\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...) => %s elements%n\", day, result.size());\n    }\n    return result;\n}"
            ],
            [
                "parseDate",
                "plume",
                "ICalAvailable",
                "/**\n * Parses a date when formatted in several common formats.\n * @return a Date read from the given string\n * @see dateFormats\n */\nstatic java.util.Date parseDate(String strDate) throws ParseException {\n    if (Pattern.matches(\"^[0-9][0-9]?/[0-9][0-9]?$\", date)) {\n        // for iCal4j\n        @SuppressWarnings(\"deprecation\")\n        int year = new Date().getYear() + 1900;\n        strDate = strDate + \"/\" + year;\n    }\n    for (DateFormat this_df : dateFormats) {\n        this_df.setLenient(false);\n        try {\n            java.util.Date result = this_df.parse(strDate);\n            return result;\n        } catch (ParseException e) {\n            // Try the next format in the list.\n        }\n    }\n    throw new ParseException(\"bad date \" + strDate, 0);\n}"
            ],
            [
                "formatDate",
                "plume",
                "ICalAvailable",
                "static String formatDate(DateTime d, TimeZone tz) {\n    df.setTimeZone(tz);\n    String result = df.format(d);\n    // Don't remove trailing year; it's a good double-check.\n    // Remove trailing year, such as \", 1952\".\n    // result = result.substring(0, result.length() - 6);\n    // Prepend day of week.\n    result = dffull.format(d).substring(0, 3) + \" \" + result;\n    return result;\n}"
            ],
            [
                "get_method_declaration",
                "plume",
                "BCELUtil",
                "/**\n * Returns a string describing a method declaration. It contains the access\n * flags (public, private, static, etc), the return type, the method name, and\n * the types of each of its arguments.\n * @param m the method\n * @return a string describing the method declaration\n */\npublic static String get_method_declaration(Method m) {\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n        f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n}"
            ],
            [
                "get_access_flags",
                "plume",
                "BCELUtil",
                "/**\n * Return a string representation of the access flags of method m.\n * @param m the method whose access flags to retrieve\n * @return a string representation of the access flags of method m\n */\nstatic String get_access_flags(Method m) {\n    int flags = m.getAccessFlags();\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n        if ((flags & pow) != 0) {\n            if (buf.length() > 0) {\n                buf.append(\" \");\n            }\n            if (i < Const.ACCESS_NAMES_LENGTH) {\n                buf.append(Const.getAccessName(i));\n            } else {\n                buf.append(String.format(\"ACC_BIT %x\", pow));\n            }\n        }\n        pow <<= 1;\n    }\n    return (buf.toString());\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a) {\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "get_constant_str",
                "plume",
                "BCELUtil",
                "/**\n * Returns the constant string at the specified offset.\n * @param pool the constant pool\n * @param index the index in the constant pool\n * @return the constant string at the specified offset in the constant pool\n */\npublic static String get_constant_str(ConstantPool pool, int index) {\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n        return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n        ConstantClass cc = (ConstantClass) c;\n        return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n        throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param mg the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param m the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param mg the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param m the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param gen the class to test\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in the format of Class.getName();\n *   the class should not be an array\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(/*@ClassGetName*/\nString classname) {\n    return classname.startsWith(\"java.\") || classname.startsWith(\"com.\") || classname.startsWith(\"javax.\") || classname.startsWith(\"org.\") || classname.startsWith(\"sun.\") || classname.startsWith(\"sunw.\");\n}"
            ],
            [
                "in_jdk_internalform",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in internal form\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk_internalform(/*@InternalForm*/\nString classname) {\n    return classname.startsWith(\"java/\") || classname.startsWith(\"com/\") || classname.startsWith(\"javax/\") || classname.startsWith(\"org/\") || classname.startsWith(\"sun/\") || classname.startsWith(\"sunw/\");\n}"
            ],
            [
                "instruction_descr",
                "plume",
                "BCELUtil",
                "// TODO: write Javadoc\n@SuppressWarnings(\"rawtypes\")\npublic static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n        @SuppressWarnings(// BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n        \"nullness\")\n        InstructionHandle /*@NonNull*/\n        handle = (InstructionHandle) i.next();\n        out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n}"
            ],
            [
                "local_var_descr",
                "plume",
                "BCELUtil",
                "/**\n * Return a description of the local variables (one per line).\n * @param mg the method whose local variables to describe\n * @return a description of the local variables (one per line)\n */\npublic static String local_var_descr(MethodGen mg) {\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n        for (LocalVariableGen lvg : lvgs) {\n            out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n        }\n    }\n    return (out.toString());\n}"
            ],
            [
                "is_local_variable_type_table",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the specified attribute is a local variable type\n * table.\n * @param a the attribute\n * @param pool the constant pool\n * @return true iff the attribute is a local variable type table\n */\npublic static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @param pool the constant pool\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "is_main",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not this is a standard main method (static,\n * name is 'main', and one argument of string array).\n * @param mg the method to check\n * @return true iff the method is a main method\n */\npublic static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic() && mg.getName().equals(\"main\") && (arg_types.length == 1) && arg_types[0].equals(string_array));\n}"
            ],
            [
                "type_to_classgetname",
                "plume",
                "BCELUtil",
                "/**\n * Returns the Java class name, in the format of {@link Class#getName()},\n * that corresponds to type.\n * @param type the type\n * @return the Java classname that corresponds to type\n */\npublic static /*@ClassGetName*/\nString type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n}"
            ],
            [
                "type_to_class",
                "plume",
                "BCELUtil",
                "/**\n * Returns the class that corresponds to type.\n * @param type the type\n * @return the Java class that corresponds to type\n */\npublic static Class<?> type_to_class(Type type) {\n    String classname = type_to_classgetname(type);\n    try {\n        Class<?> c = UtilMDE.classForName(classname);\n        return c;\n    } catch (Exception e) {\n        throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n}"
            ],
            [
                "add_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type added to the end of types.\n * @param types the array to extend\n * @param new_type the element to add to the end of the types array\n * @return the array (or a new one), with new_type at the end\n */\npublic static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "insert_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type inserted at the beginning.\n * @param types the array to extend\n * @param new_type the element to add to the beginning of the types array\n * @return the array (or a new one), with new_type at the beginning\n */\npublic static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "classname_to_type",
                "plume",
                "BCELUtil",
                "/**\n * Return the type corresponding to a given class name.\n * @param classname the class to convert to a type\n * @return the type corresponding to the given class name\n */\npublic static Type classname_to_type(String classname) {\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n        classname = classname.substring(0, classname.length() - 2);\n        array_depth++;\n    }\n    classname = classname.intern();\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") {\n        // interned\n        t = Type.INT;\n    } else if (classname == \"boolean\") {\n        // interned\n        t = Type.BOOLEAN;\n    } else if (classname == \"byte\") {\n        // interned\n        t = Type.BYTE;\n    } else if (classname == \"char\") {\n        // interned\n        t = Type.CHAR;\n    } else if (classname == \"double\") {\n        // interned\n        t = Type.DOUBLE;\n    } else if (classname == \"float\") {\n        // interned\n        t = Type.FLOAT;\n    } else if (classname == \"long\") {\n        // interned\n        t = Type.LONG;\n    } else if (classname == \"short\") {\n        // interned\n        t = Type.SHORT;\n    } else {\n        // must be a non-primitive\n        t = new ObjectType(classname);\n    }\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n        t = new ArrayType(t, array_depth);\n    }\n    return t;\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Array\n///\n// For arrays, see ArraysMDE.java.\n///////////////////////////////////////////////////////////////////////////\n/// BitSet\n///\n/**\n * Returns true if the cardinality of the intersection of the two\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b) >= i);\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "/**\n * Returns true if the cardinality of the intersection of the three\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b intersect c) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        intersection.and(c);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the two BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @return size(a intersect b)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the three BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @return size(a intersect b intersect c)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n}"
            ],
            [
                "fileInputStream",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// BufferedFileReader\n///\n// Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n/**\n * Returns an InputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStream for file\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            in = new GZIPInputStream(new FileInputStream(file));\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        in = new FileInputStream(file);\n    }\n    return in;\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return an InputStream for filename\n * @throws IOException if there is trouble reading the file\n * @throws FileNotFoundException if the file is not found\n */\npublic static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName null, or the name of a Charset to use when reading the file\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibility-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a LineNumberReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return a LineNumberReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedWriter appends to the end\n * of the file instead of the beginning\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\n// Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\npublic static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n        file_writer = new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n        file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n}"
            ],
            [
                "bufferedFileOutputStream",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedOutputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedOutputStream appends to the end\n * of the file instead of the beginning\n * @return a BufferedOutputStream for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}"
            ],
            [
                "isSubtype",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Class\n///\n/**\n * Return true iff sub is a subtype of sup.\n * If sub == sup, then sub is considered a subtype of sub and this method\n * returns true.\n * @param sub class to test for being a subtype\n * @param sup class to test for being a supertype\n * @return true iff sub is a subtype of sup\n */\n/*@Pure*/\npublic static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n        return true;\n    }\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n        return true;\n    }\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n        if (ifc == sup || isSubtype(ifc, sup)) {\n            return true;\n        }\n    }\n    return false;\n}"
            ],
            [
                "classForName",
                "plume",
                "UtilMDE",
                "/**\n * Like {@link Class#forName(String)}, but also works when the string\n * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n * <p>\n * If the given name can't be found, this method changes the last '.'  to\n * a dollar sign ($) and tries again.  This accounts for inner classes\n * that are incorrectly passed in in fully-qualified format instead of\n * binary format.\n * <p>\n * Recall the rather odd specification for {@link Class#forName(String)}:\n * the argument is a binary name for non-arrays, but a field descriptor\n * for arrays.  This method uses the same rules, but additionally handles\n * primitive types and, for non-arrays, fully-qualified names.\n * @param className name of the class\n * @return the Class corresponding to className\n * @throws ClassNotFoundException if the class is not found\n */\n// The annotation encourages proper use, even though this can take a\n// fully-qualified name (only for a non-array).\npublic static Class<?> classForName(/*@ClassGetName*/\nString className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n        return result;\n    } else {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            int pos = className.lastIndexOf('.');\n            if (pos < 0) {\n                throw e;\n            }\n            // checked below & exception is handled\n            @SuppressWarnings(\"signature\")\n            String /*@ClassGetName*/\n            inner_name = className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n            try {\n                return Class.forName(inner_name);\n            } catch (ClassNotFoundException ee) {\n                throw e;\n            }\n        }\n    }\n}"
            ],
            [
                "binaryNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a binary name to a field descriptor.\n * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n * or \"int\" to \"I\".\n * @param classname name of the class, in binary class name format\n * @return name of the class, in field descriptor format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@FieldDescriptor*/\nString binaryNameToFieldDescriptor(/*@BinaryName*/\nString classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n        dims++;\n        sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n        result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n        result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n}"
            ],
            [
                "primitiveTypeNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n * a field descriptor (e.g., \"I\", \"D\", etc.).\n * @param primitive_name name of the type, in Java format\n * @return name of the type, in field descriptor format\n * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n */\npublic static /*@FieldDescriptor*/\nString primitiveTypeNameToFieldDescriptor(String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n        throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n}"
            ],
            [
                "binaryNameToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a BinaryName to the format of {@link Class#getName()}.\n * @param bn the binary name to convert\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString binaryNameToClassGetName(/*BinaryName*/\nString bn) {\n    if (bn.endsWith(\"[]\")) {\n        return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n        return bn;\n    }\n}"
            ],
            [
                "fieldDescriptorToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n * @param fd the class, in field descriptor format\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString fieldDescriptorToClassGetName(/*FieldDescriptor*/\nString fd) {\n    if (fd.startsWith(\"[\")) {\n        return fd.replace('/', '.');\n    } else {\n        return fieldDescriptorToBinaryName(fd);\n    }\n}"
            ],
            [
                "arglistToJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert a fully-qualified argument list from Java format to JVML format.\n * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n * @param arglist an argument list, in Java format\n * @return argument list, in JVML format\n */\npublic static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n        // substring\n        @SuppressWarnings(\"signature\")\n        String /*@BinaryName*/\n        arg = args_tokenizer.nextToken().trim();\n        result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n}"
            ],
            [
                "fieldDescriptorToBinaryName",
                "plume",
                "UtilMDE",
                "// does not convert \"V\" to \"void\".  Should it?\n/**\n * Convert a field descriptor to a binary name.\n * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n * or \"I\" to \"int\".\n * @param classname name of the type, in JVML format\n * @return name of the type, in Java format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@BinaryName*/\nString fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n        throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n        dims++;\n        classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n        result = classname.substring(1, classname.length() - 1);\n    } else {\n        result = primitiveClassesFromJvm.get(classname);\n        if (result == null) {\n            throw new Error(\"Malformed base class: \" + classname);\n        }\n    }\n    for (int i = 0; i < dims; i++) {\n        result += \"[]\";\n    }\n    return result.replace('/', '.');\n}"
            ],
            [
                "arglistFromJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert an argument list from JVML format to Java format.\n * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n * @param arglist an argument list, in JVML format\n * @return argument list, in Java format\n */\npublic static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n        if (pos > 1) {\n            result += \", \";\n        }\n        int nonarray_pos = pos;\n        while (arglist.charAt(nonarray_pos) == '[') {\n            nonarray_pos++;\n        }\n        char c = arglist.charAt(nonarray_pos);\n        if (c == 'L') {\n            int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n            result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n            pos = semi_pos + 1;\n        } else {\n            String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n            if (maybe == null) {\n                // return null;\n                throw new Error(\"Malformed arglist: \" + arglist);\n            }\n            result += maybe;\n            pos = nonarray_pos + 1;\n        }\n    }\n    return result + \")\";\n}"
            ],
            [
                "defineClassFromFile",
                "plume",
                "UtilMDE",
                "/**\n * Converts the bytes in a file into an instance of class Class, and\n * resolves (links) the class.\n * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n * file name rather than an array of bytes as an argument, and also resolves\n * (links) the class.\n * @see ClassLoader#defineClass(String,byte[],int,int)\n * @param className the name of the class to define, or null if not known\n * @param pathname the pathname of a .class file\n * @return a Java Object corresponding to the Class defined in the .class file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\n// Also throws UnsupportedClassVersionError and some other exceptions.\npublic static Class<?> defineClassFromFile(/*@BinaryName*/\nString className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n}"
            ],
            [
                "count_lines",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// File\n///\n/**\n * Count the number of lines in the specified file.\n * @param filename file whose size to count\n * @return number of lines in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n        while (reader.readLine() != null) {\n            count++;\n        }\n    }\n    return count;\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param filename the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param file the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n        int unix = 0;\n        int dos = 0;\n        int mac = 0;\n        while (true) {\n            String s = r.readLine();\n            if (s == null) {\n                break;\n            }\n            if (s.endsWith(\"\\r\\n\")) {\n                dos++;\n            } else if (s.endsWith(\"\\r\")) {\n                mac++;\n            } else if (s.endsWith(\"\\n\")) {\n                unix++;\n            } else {\n                // This can happen only if the last line is not terminated.\n            }\n        }\n        if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n            return \"\\r\\n\";\n        }\n        if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n            return \"\\r\";\n        }\n        if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n            return \"\\n\";\n        }\n        // The two non-preferred line endings are tied and have more votes than\n        // the preferred line ending.  Give up and return the line separator\n        // for the system on which Java is currently running.\n        return lineSep;\n    }\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @return true iff the files have the same contents\n */\n/*@Pure*/\npublic static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff the files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @param trimLines if true, call String.trim on each line before comparing\n * @return true iff the files have the same contents\n */\n// reads files, side effects local state\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2)) {\n        String line1 = reader1.readLine();\n        String line2 = reader2.readLine();\n        while (line1 != null && line2 != null) {\n            if (trimLines) {\n                line1 = line1.trim();\n                line2 = line2.trim();\n            }\n            if (!(line1.equals(line2))) {\n                return false;\n            }\n            line1 = reader1.readLine();\n            line2 = reader2.readLine();\n        }\n        if (line1 == null && line2 == null) {\n            return true;\n        }\n        return false;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}"
            ],
            [
                "canCreateAndWrite",
                "plume",
                "UtilMDE",
                "/**\n * Returns true\n *  if the file exists and is writable, or\n *  if the file can be created.\n * @param file the file to create and write\n * @return true iff the file can be created and written\n */\npublic static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n        return file.canWrite();\n    } else {\n        File directory = file.getParentFile();\n        if (directory == null) {\n            directory = new File(\".\");\n        }\n        // Does this test need \"directory.canRead()\" also?\n        return directory.canWrite();\n    }\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n}"
            ],
            [
                "createTempDir",
                "plume",
                "UtilMDE",
                "///\n/// Directories\n///\n/**\n * Creates an empty directory in the default temporary-file directory,\n * using the given prefix and suffix to generate its name. For example,\n * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n * someString is internally generated to ensure no temporary files of the\n * same name are generated.\n * @param prefix the prefix string to be used in generating the file's\n *  name; must be at least three characters long\n * @param suffix the suffix string to be used in generating the file's\n *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n *  An abstract pathname denoting a newly-created empty file\n * @return a File representing the newly-created temporary directory\n * @throws IllegalArgumentException If the prefix argument contains fewer\n *  than three characters\n * @throws IOException If a file could not be created\n * @throws SecurityException If a security manager exists and its\n *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n *  file to be created\n * @see java.io.File#createTempFile(String, String, File)\n */\npublic static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dirName and all its files.\n * @param dirName the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dir and all its files.\n * @param dir the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n        return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    return dir.delete();\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name file whose name to expand\n * @return file with expanded file\n */\npublic static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n        return new File(newname);\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name filename to expand\n * @return expanded filename\n */\npublic static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n        return (name.replace(\"~\", userHome));\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "java_source",
                "plume",
                "UtilMDE",
                "/**\n * Return a string version of the name that can be used in Java source.\n * On Windows, the file will return a backslash separated string.  Since\n * backslash is an escape character, it must be quoted itself inside\n * the string.\n * <p>\n * The current implementation presumes that backslashes don't appear\n * in filenames except as windows path separators.  That seems like a\n * reasonable assumption.\n *\n * @param name file to quote\n * @return a string version of the name that can be used in Java source\n */\npublic static String java_source(File name) {\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n}"
            ],
            [
                "readObject",
                "plume",
                "UtilMDE",
                "/**\n * Reads an Object from a File.\n * @param file the file from which to read\n * @return the object read from the file\n * @throws IOException if there is trouble reading the file\n * @throws ClassNotFoundException if the object's class cannot be found\n */\npublic static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            istream = new GZIPInputStream(istream);\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n}"
            ],
            [
                "readerContents",
                "plume",
                "UtilMDE",
                "/**\n * Reads the entire contents of the reader and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param r the Reader to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readerContents(Reader r) {\n    try {\n        StringBuilder contents = new StringBuilder();\n        int ch;\n        while ((ch = r.read()) != -1) {\n            contents.append((char) ch);\n        }\n        r.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n}"
            ],
            [
                "readFile",
                "plume",
                "UtilMDE",
                "// an alternate name would be \"fileContents\".\n/**\n * Reads the entire contents of the file and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param file the file to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readFile(File file) {\n    try {\n        BufferedReader reader = UtilMDE.bufferedFileReader(file);\n        StringBuilder contents = new StringBuilder();\n        String line = reader.readLine();\n        while (line != null) {\n            contents.append(line);\n            // Note that this converts line terminators!\n            contents.append(lineSep);\n            line = reader.readLine();\n        }\n        reader.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Hashing\n///\n// In hashing, there are two separate issues.  First, one must convert\n// the input datum into an integer.  Then, one must transform the\n// resulting integer in a pseudorandom way so as to result in a number\n// that is far separated from other values that may have been near it to\n// begin with.  Often these two steps are combined, particularly if\n// one wishes to avoid creating too large an integer (losing information\n// off the top bits).\n// http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n//  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n//    h += (h<<3); h ^= (h>>11); h += (h<<15);\n//    is good.\n//  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n//  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n// In this part of the file, perhaps I will eventually write good hash\n// functions.  For now, write cheesy ones that primarily deal with the\n// first issue, transforming a data structure into a single number.  This\n// is also known as fingerprinting.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Double#hashCode()}.\n * @param x value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a) {\n    double result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a, double[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/// Don't define hash with int args; use the long versions instead.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Long#hashCode()}.\n * But it doesn't map -1 and 0 to the same value.\n * @param l value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n        return (int) l;\n    }\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a, long[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a) {\n    return (a == null) ? 0 : a.hashCode();\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b, /*@Nullable*/\nString c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + hash(a[i]);\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @param random the Random instance to use to make selections\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n    while (itor.hasNext()) {\n        rs.accept(itor.next());\n    }\n    return rs.getValues();\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n}"
            ],
            [
                "incrementMap",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Map\n///\n// In Python, inlining this gave a 10x speed improvement.\n// Will the same be true for Java?\n/**\n * Increment the Integer which is indexed by key in the Map.\n * If the key isn't in the Map, it is added.\n * @param <T> type of keys in the map\n * @param m map to have one of its values incremented\n * @param key the key for the element whose value will be incremented\n * @param count how much to increment the value by\n * @return the old value, before it was incremented\n * @throws Error if the key is in the Map but maps to a non-Integer.\n */\npublic static <T> /*@Nullable*/\nInteger incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n        new_total = count;\n    } else {\n        new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n}"
            ],
            [
                "mapToString",
                "plume",
                "UtilMDE",
                "/**\n * Returns a multi-line string representation of a map.\n * @param <K> type of map keys\n * @param <V> type of map values\n * @param m map to be converted to a string\n * @return a multi-line string representation of m\n */\npublic static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @return a sorted version of m.keySet()\n */\npublic static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @param comparator the Comparator to use for sorting\n * @return a sorted version of m.keySet()\n */\npublic static <K, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m, Comparator<K> comparator) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a method signature, return the method.\n * Example calls are:\n * <pre>\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n * </pre>\n * @param method a method signature\n * @return the method corresponding to the given signature\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n        throw new Error(\"malformed method name should contain a period, open paren, and close paren: \" + method + \" <<\" + dotpos + \",\" + oparenpos + \",\" + cparenpos + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n        if (!Character.isWhitespace(method.charAt(i))) {\n            throw new Error(\"malformed method name should contain only whitespace following close paren\");\n        }\n    }\n    // throws exception if class does not exist\n    @SuppressWarnings(\"signature\")\n    String /*@BinaryNameForNonArray*/\n    classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n        String[] argnames;\n        if (all_argnames.equals(\"\")) {\n            argnames = new String[0];\n        } else {\n            argnames = split(all_argnames, ',');\n        }\n        /*@MonotonicNonNull*/\n        Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n        for (int i = 0; i < argnames.length; i++) {\n            String bnArgname = argnames[i].trim();\n            /*@ClassGetName*/\n            String cgnArgname = binaryNameToClassGetName(bnArgname);\n            argclasses_tmp[i] = classForName(cgnArgname);\n        }\n        @SuppressWarnings(\"cast\")\n        Class<?>[] argclasses_res = (Class<?>[]) argclasses_tmp;\n        argclasses = argclasses_res;\n        args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a class name and a method name in that class, return the method.\n * @param classname class in which to find the method\n * @param methodname the method name\n * @param params the parameters of the method\n * @return the method named classname.methodname with parameters params\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(/*@BinaryNameForNonArray*/\nString classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// ProcessBuilder\n///\n/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line\n * @return all the output of the command\n */\npublic static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line, as a list of\n * strings (the command, then its arguments)\n * @return all the output of the command\n */\npublic static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n        Process p = pb.start();\n        @SuppressWarnings(// input stream is non-null because we didn't redirect the input stream\n        \"nullness\")\n        String output = UtilMDE.streamString(p.getInputStream());\n        return output;\n    } catch (IOException e) {\n        return \"IOException: \" + e.getMessage();\n    }\n}"
            ],
            [
                "propertyIsTrue",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Properties\n///\n/**\n * Determines whether a property has value \"true\", \"yes\", or \"1\".\n * @see Properties#getProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @return true iff the property has value \"true\", \"yes\", or \"1\"\n */\n// does not depend on object identity\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n        return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n}"
            ],
            [
                "appendProperty",
                "plume",
                "UtilMDE",
                "/**\n * Set the property to its previous value concatenated to the given value.\n * Return the previous value.\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to concatenate to the previous value of the property\n * @return the previous value of the property\n * @see Properties#getProperty\n * @see Properties#setProperty\n */\npublic static /*@Nullable*/\nString appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n}"
            ],
            [
                "setDefaultMaybe",
                "plume",
                "UtilMDE",
                "/**\n * Set the property only if it was not previously set.\n * @see Properties#getProperty\n * @see Properties#setProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to set the property to, if it is not already set\n * @return the previous value of the property\n */\npublic static /*@Nullable*/\nString setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n        p.setProperty(key, value);\n    }\n    return currentValue;\n}"
            ],
            [
                "getPrivateField",
                "plume",
                "UtilMDE",
                "// TODO: set the field back to private after is is accessed.\n/**\n * Reads the given field, which may be private.\n * Leaves the field accessible.\n * Use with care!\n * @param o object in which to set the field\n * @param fieldName name of field to set\n * @return new value of field\n * @throws NoSuchFieldException if the field does not exist in the object\n */\npublic static /*@Nullable*/\nObject getPrivateField(Object o, String fieldName) throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) {\n        // Class is interned\n        // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n        try {\n            Field f = c.getDeclaredField(fieldName);\n            f.setAccessible(true);\n            return f.get(o);\n        } catch (IllegalAccessException e) {\n            System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n            throw new Error(\"This can't happen: \" + e);\n        } catch (NoSuchFieldException e) {\n            if (c.getSuperclass() == Object.class) {\n                // Class is interned\n                throw e;\n            }\n            // nothing to do; will now examine superclass\n        }\n        c = c.getSuperclass();\n        assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n}"
            ],
            [
                "getFromSet",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set\n///\n/**\n * Return the object in this set that is equal to key.\n * The Set abstraction doesn't provide this; it only provides \"contains\".\n * Returns null if the argument is null, or if it isn't in the set.\n * @param set a set in which to look up the value\n * @param key the value to look up in the set\n * @return the object in this set that is equal to key, or null\n */\npublic static /*@Nullable*/\nObject getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n        return null;\n    }\n    for (Object elt : set) {\n        if (key.equals(elt)) {\n            return elt;\n        }\n    }\n    return null;\n}"
            ],
            [
                "streamString",
                "plume",
                "UtilMDE",
                "/**\n * Return a String containing all the characters from the input stream.\n * @param is input stream to read\n * @return a String containing all the characters from the input stream\n */\npublic static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n}"
            ],
            [
                "replaceString",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// String\n///\n/**\n * Return a new string which is the text of target with all instances of\n * oldStr replaced by newStr.\n * @param target the string to do replacement in\n * @param oldStr the substring to replace\n * @param newStr the replacement\n * @return target with all instances of oldStr replaced by newStr\n */\npublic static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n        throw new IllegalArgumentException();\n    }\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n        result.append(target.substring(lastend, pos));\n        result.append(newStr);\n        lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter character.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, String delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter String.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, char delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n        throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "splitLines",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings, one for each line in the argument.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n * are supported.  Note that a string that ends with a line separator\n * will return an empty string as the last element of the array.\n * @see #split(String s, char delim)\n * @param s the string to split\n * @return an array of Strings, one for each line in the argument\n */\npublic static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the array elements, placing the\n * delimiter between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n        return \"\";\n    }\n    if (a.length == 1) {\n        return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n        sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(Object... a) {\n    return join(a, lineSep);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * delimiter between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n        return \"\";\n    }\n    if (v.size() == 1) {\n        return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n        sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(List<String> v) {\n    return join(v, lineSep);\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Escape \\, \", newline, and carriage-return characters in the\n * target as \\\\, \\\", \\n, and \\r; return a new string if any\n * modifications were necessary.  The intent is that by surrounding\n * the return value with double quote marks, the result will be a\n * Java string literal denoting the original string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        switch(c) {\n            case '\\\"':\n            case '\\\\':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append('\\\\');\n                post_esc = i;\n                break;\n            case // not lineSep\n            '\\n':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                // not lineSep\n                sb.append(\"\\\\n\");\n                post_esc = i + 1;\n                break;\n            case '\\r':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append(\"\\\\r\");\n                post_esc = i + 1;\n                break;\n            default:\n        }\n    }\n    if (sb.length() == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "// The overhead of this is too high to call in escapeNonJava(String), so\n// it is inlined there.\n/**\n * Like {@link #escapeNonJava(String)}, but for a single character.\n * @param ch character to quote\n * @return quoted version och ch\n */\npublic static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch(c) {\n        case '\\\"':\n            return \"\\\\\\\"\";\n        case '\\\\':\n            return \"\\\\\\\\\";\n        case // not lineSep\n        '\\n':\n            // not lineSep\n            return \"\\\\n\";\n        case '\\r':\n            return \"\\\\r\";\n        default:\n            return new String(new char[] { c });\n    }\n}"
            ],
            [
                "escapeNonASCII",
                "plume",
                "UtilMDE",
                "/**\n * Escape unprintable characters in the target, following the usual\n * Java backslash conventions, so that the result is sure to be\n * printable ASCII.  Returns a new string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n}"
            ],
            [
                "unescapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n * one-character equivalents.  All other backslashes are removed\n * (for instance, octal/hex escape sequences are not turned into\n * their respective characters). This is the inverse operation of\n * escapeNonJava(). Previously known as unquote().\n * @param orig string to quoto\n * @return quoted version of orig\n */\npublic static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n        if (this_esc == orig.length() - 1) {\n            sb.append(orig.substring(post_esc, this_esc + 1));\n            post_esc = this_esc + 1;\n            break;\n        }\n        switch(orig.charAt(this_esc + 1)) {\n            case 'n':\n                sb.append(orig.substring(post_esc, this_esc));\n                // not lineSep\n                sb.append('\\n');\n                post_esc = this_esc + 2;\n                break;\n            case 'r':\n                sb.append(orig.substring(post_esc, this_esc));\n                sb.append('\\r');\n                post_esc = this_esc + 2;\n                break;\n            case '\\\\':\n                // This is not in the default case because the search would find\n                // the quoted backslash.  Here we incluce the first backslash in\n                // the output, but not the first.\n                sb.append(orig.substring(post_esc, this_esc + 1));\n                post_esc = this_esc + 2;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                sb.append(orig.substring(post_esc, this_esc));\n                char octal_char = 0;\n                int ii = this_esc + 1;\n                while (ii < orig.length()) {\n                    char ch = orig.charAt(ii++);\n                    if ((ch < '0') || (ch > '8')) {\n                        break;\n                    }\n                    octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n                }\n                sb.append(octal_char);\n                post_esc = ii - 1;\n                break;\n            default:\n                // In the default case, retain the character following the backslash,\n                // but discard the backslash itself.  \"\\*\" is just a one-character string.\n                sb.append(orig.substring(post_esc, this_esc));\n                post_esc = this_esc + 1;\n                break;\n        }\n        this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "removeWhitespaceAround",
                "plume",
                "UtilMDE",
                "// Use the built-in String.trim()!\n// /** Return the string with all leading and trailing whitespace stripped. */\n// public static String trimWhitespace(String s) {\n//   int len = s.length();\n//   if (len == 0)\n//     return s;\n//   int first_non_ws = 0;\n//   int last_non_ws = len-1;\n//   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n//     first_non_ws++;\n//   if (first_non_ws == len)\n//     return \"\";\n//   while (Character.isWhitespace(s.charAt(last_non_ws)))\n//     last_non_ws--;\n//   if ((first_non_ws == 0) && (last_non_ws == len)) {\n//     return s;\n//   } else {\n//     return s.substring(first_non_ws, last_non_ws+1);\n//   }\n// }\n// // // Testing:\n// // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n// // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n// // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n/**\n * Remove all whitespace before or after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace abutting\n * @return version of arg, with whitespace abutting delimiter removed\n */\npublic static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n}"
            ],
            [
                "removeWhitespaceAfter",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace after\n * @return version of arg, with whitespace after delimiter removed\n */\npublic static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index + delim_len;\n        while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index++;\n        }\n        // if (non_ws_index == arg.length()) {\n        //   System.out.println(\"No nonspace character at end of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index + delim_len) {\n            arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n        }\n        delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n}"
            ],
            [
                "removeWhitespaceBefore",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace before instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace before\n * @return version of arg, with whitespace before delimiter removed\n */\npublic static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index - 1;\n        while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index--;\n        }\n        // if (non_ws_index == -1) {\n        //   System.out.println(\"No nonspace character at front of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index - 1) {\n            arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n        }\n        delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n}"
            ],
            [
                "nplural",
                "plume",
                "UtilMDE",
                "/**\n * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n * @param n count of nouns\n * @param noun word being counted\n * @return noun, if n==1; otherwise, pluralization of noun\n */\npublic static String nplural(int n, String noun) {\n    if (n == 1) {\n        return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\") || noun.endsWith(\"s\") || noun.endsWith(\"sh\") || noun.endsWith(\"x\")) {\n        return n + \" \" + noun + \"es\";\n    } else {\n        return n + \" \" + noun + \"s\";\n    }\n}"
            ],
            [
                "lpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the left if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String lpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString() + s;\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the right if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String rpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n * @param num int whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n * @param num double whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the character appears in the string.\n * @param s string to search in\n * @param ch character to search for\n * @return number of times the character appears in the string\n */\npublic static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the second string appears in the first.\n * @param s string to search in\n * @param sub string to search for\n * @return number of times the substring appears in the string\n */\npublic static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// StringTokenizer\n///\n/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n * <p>\n * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n * (probably due to backward-compatibility).\n * @param str a string to be parsed\n * @param delim the delimiters\n * @param returnDelims flag indicating whether to return the delimiters as tokens\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n * @param str a string to be parsed\n * @param delim the delimiters\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n * @param str a string to be parsed\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n}"
            ],
            [
                "backTrace",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Throwable\n///\n/**\n * Return a String representation of the backtrace of the given Throwable.\n * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n * @param t the Throwable to obtain a backtrace of\n * @return a String representation of the backtrace of the given Throwable\n */\npublic static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n}"
            ],
            [
                "sortList",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Collections\n///\n/**\n * Return the sorted version of the list.  Does not alter the list.\n * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n * @return a sorted version of the list\n * @param <T> type of elements of the list\n * @param l a list to sort\n * @param c a sorted version of the list\n */\npublic static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n}"
            ],
            [
                "removeDuplicates",
                "plume",
                "UtilMDE",
                "// This should perhaps be named withoutDuplicates to emphasize that\n// it does not side-effect its argument.\n/**\n * Return a copy of the list with duplicates removed.\n * Retains the original order.\n * @param <T> type of elements of the list\n * @param l a list to remove duplicates from\n * @return a copy of the list with duplicates removed\n */\npublic static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n}"
            ],
            [
                "deepEquals",
                "plume",
                "UtilMDE",
                "/**\n * Determines deep equality for the elements.\n * <ul>\n * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n * <li>If both are lists, uses deepEquals recursively on each element.\n * <li>For other types, just uses equals() and does not recursively call this method.\n * </ul>\n * @param o1 first value to compare\n * @param o2 second value to comare\n * @return true iff o1 and o2 are deeply equal\n */\n// side effect to static field deepEqualsUnderway\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean deepEquals(/*@Nullable*/\nObject o1, /*@Nullable*/\nObject o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    // creates local state\n    @SuppressWarnings(\"purity\")\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n        return true;\n    }\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n        List<?> l1 = (List<?>) o1;\n        List<?> l2 = (List<?>) o2;\n        if (l1.size() != l2.size()) {\n            return false;\n        }\n        try {\n            deepEqualsUnderway.add(mypair);\n            for (int i = 0; i < l1.size(); i++) {\n                Object e1 = l1.get(i);\n                Object e2 = l2.get(i);\n                if (!deepEquals(e1, e2)) {\n                    return false;\n                }\n            }\n        } finally {\n            deepEqualsUnderway.remove(mypair);\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}"
            ],
            [
                "makeVector",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Vector\n///\n/**\n * Returns a vector containing the elements of the enumeration.\n * @param <T> type of the enumeration and vector elements\n * @param e an enumeration to convert to a Vector\n * @return a vector containing the elements of the enumeration\n */\npublic static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n        result.addElement(e.nextElement());\n    }\n    return result;\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "// Rather than writing something like VectorToStringArray, use\n//   v.toArray(new String[0])\n/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of the specified objects starting at index\n * start over dims dimensions, for dims &gt; 0.\n * <p>\n * For example, create_combinations (1, 0, {a, b, c}) returns:\n * <pre>\n *    {a}, {b}, {c}\n * </pre>\n * And create_combinations (2, 0, {a, b, c}) returns:\n * <pre>\n *    {a, a}, {a, b}, {a, c}\n *    {b, b}, {b, c},\n *    {c, c}\n * </pre>\n * @param <T> type of the input list elements, and type of the innermost output list elements\n * @param dims number of dimensions:  that is, size of each innermost list\n * @param start initial index\n * @param objs list of elements to\n * @return list of lists of length dims, each of which combines elements from objs\n */\npublic static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n    if (dims < 1) {\n        throw new IllegalArgumentException();\n    }\n    List<List<T>> results = new ArrayList<List<T>>();\n    for (int i = start; i < objs.size(); i++) {\n        if (dims == 1) {\n            List<T> simple = new ArrayList<T>();\n            simple.add(objs.get(i));\n            results.add(simple);\n        } else {\n            List<List<T>> combos = create_combinations(dims - 1, i, objs);\n            for (List<T> lt : combos) {\n                List<T> simple = new ArrayList<T>();\n                simple.add(objs.get(i));\n                simple.addAll(lt);\n                results.add(simple);\n            }\n        }\n    }\n    return (results);\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of integers from start to cnt (inclusive) over\n * arity dimensions.\n * <p>\n * For example, create_combinations (1, 0, 2) returns:\n * <pre>\n *    {0}, {1}, {2}\n * </pre>\n * And create_combinations (2, 0, 2) returns:\n * <pre>\n *    {0, 0}, {0, 1}, {0, 2}\n *    {1, 1}  {1, 2},\n *    {2, 2}\n * </pre>\n * @param arity size of each innermost list\n * @param start initial value\n * @param cnt maximum element value\n * @return list of lists of length arity, each of which combines integers from start to cnt\n */\npublic static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n        results.add(new ArrayList<Integer>());\n        return (results);\n    }\n    for (int i = start; i <= cnt; i++) {\n        ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n        for (ArrayList<Integer> li : combos) {\n            ArrayList<Integer> simple = new ArrayList<Integer>();\n            simple.add(new Integer(i));\n            simple.addAll(li);\n            results.add(simple);\n        }\n    }\n    return (results);\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(/*@FullyQualifiedName*/\nString qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n}"
            ],
            [
                "fullyQualifiedNameToSimpleName",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n// TODO: does not follow the specification for inner classes (where the\n// type name should be empty), but I think this is more informative anyway.\n// string conversion\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetSimpleName*/\nString fullyQualifiedNameToSimpleName(/*@FullyQualifiedName*/\nString qualified_name) {\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n        return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified class.  For example if qualified name of the class\n * is java.lang.String, String will be returned.\n *\n * @deprecated use {@link Class#getSimpleName()} instead.\n *\n * @param cls a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n}"
            ],
            [
                "abbreviateNumber",
                "plume",
                "UtilMDE",
                "/**\n * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n * of precision in the result (counting both sides of the decimal point).\n * @param val a numeric value\n * @return an abbreviated string representation of the value\n */\npublic static String abbreviateNumber(long val) {\n    double dval = (double) val;\n    String mag = \"\";\n    if (val < 1000) {\n        // nothing to do\n    } else if (val < 1000000) {\n        dval = val / 1000.0;\n        mag = \"K\";\n    } else if (val < 1000000000) {\n        dval = val / 1000000.0;\n        mag = \"M\";\n    } else {\n        dval = val / 1000000000.0;\n        mag = \"G\";\n    }\n    String precision = \"0\";\n    if (dval < 10) {\n        precision = \"2\";\n    } else if (dval < 100) {\n        precision = \"1\";\n    }\n    // format string computed from precision and mag\n    @SuppressWarnings(\"formatter\")\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeIntSet",
                "/**\n * Merges a list of LimitedSizeIntSet objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param max_values the maximum size for the returned LimitedSizeIntSet\n * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n * @return a LimitedSizeIntSet that merges the elements of slist\n */\npublic static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist) {\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ],
            [
                "of",
                "plume",
                "Triple",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param <C> type of third argument\n * @param a first argument\n * @param b second argument\n * @param c third argument\n * @return a triple of the values (a, b, c)\n */\npublic static <A, B, C> Triple<A, B, C> of(A a, B b, C c) {\n    return new Triple<A, B, C>(a, b, c);\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// min, max\n///\n// Could also add linear-time orderStatistics if I liked.\n/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int min(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long min(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double min(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer min(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long min(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() < result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double min(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int max(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long max(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double max(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer max(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long max(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() > result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double max(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int[] min_max(int[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] { result_min, result_max };\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long[] min_max(long[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] { result_min, result_max };\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int element_range(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long element_range(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of integers.\n * @param a an array\n * @return the sum of an array of integers\n */\npublic static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of integers.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of integers\n */\npublic static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of doubles.\n * @param a an array\n * @return the sum of an array of doubles\n */\npublic static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of doubles.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of doubles\n */\npublic static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf\n///\n/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> type of the elements of the array\n * @param a an array\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt) {\n    if (elt == null) {\n        return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> the type of the elements\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n *    Identical to List.indexOf, but included for completeness.\n * @param a a list\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    return a.indexOf(elt);\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a.get(i))) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyNull*/\nObject[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.size(); i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf, for finding subarrays\n///\n// This is analogous to Common Lisp's \"search\" function.\n// This implementation is very inefficient; I could use tricky Boyer-Moore\n// search techniques if I liked, but it's not worth it to me yet.\n/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n// The signature on this method is unnecessarily strict because it\n// requires that the component types be identical.  The signature should\n// be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n// @PolyAll qualifier does not yet take an argument.\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// mismatch\n///\n// This is analogous to Common Lisp's \"mismatch\" function.\n// Put it off until later; for now, use the simpler subarray function,\n// which is a specialization of mismatch,\n///////////////////////////////////////////////////////////////////////////\n/// subarray extraction\n///\n// Note that the second argument is a length, not an end position.\n// That's to avoid confusion over whether it would be the last included\n// index or the first non-included index.\n/**\n * Return a subarray of the given array.\n * @return a subarray of the given array\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n */\n/*@SideEffectFree*/\npublic static Object[] subarray(/*@PolyAll*/\nObject[] a, int startindex, int length) {\n    /*@PolyAll*/\n    Object[] result = new /*@PolyAll*/\n    Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a sublist of the given list.\n * @param <T> type of the elements\n * @param a the original list\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a sublist of the given list\n */\n/*@SideEffectFree*/\npublic static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static String[] subarray(/*@PolyAll*/\nString[] a, int startindex, int length) {\n    /*@PolyAll*/\n    String[] result = new /*@PolyAll*/\n    String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// subarray testing\n///\n/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, /*@PolyNull*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.size()];\n            System.arraycopy(a, 0, result, 0, a.length);\n            // System.arraycopy(b, 0, result, a.length, b.size());\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.length] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.length];\n            // System.arraycopy(a, 0, result, 0, a.size());\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            System.arraycopy(b, 0, result, a.size(), b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.size()];\n            // System.arraycopy(a, 0, result, 0, a.length);\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            // System.arraycopy(b, 0, result, a.length, b.length);\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.size()] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "// Note: PolyAll is not quite right.  Need to review.\n/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first array to concatenate\n * @param b the second array to concatenate\n * @return an array that concatenates the arguments\n */\npublic static String[] concat(/*@PolyAll*/\nString[] a, /*@PolyAll*/\nString[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new String[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            /*@PolyAll*/\n            String[] result = new String[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static byte[] concat(byte[] a, byte[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new byte[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            byte[] result = new byte[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static boolean[] concat(boolean[] a, boolean[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new boolean[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            boolean[] result = new boolean[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static char[] concat(char[] a, char[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new char[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            char[] result = new char[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static double[] concat(double[] a, double[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new double[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            double[] result = new double[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static float[] concat(float[] a, float[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new float[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            float[] result = new float[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static int[] concat(int[] a, int[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new int[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            int[] result = new int[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static long[] concat(long[] a, long[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new long[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            long[] result = new long[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static short[] concat(short[] a, short[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new short[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            short[] result = new short[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Printing\n///\n// This should be extended to all types, when I get around to it.  The\n// methods are patterned after that of java.util.Vector (and use its\n// output format).\n/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@PolyAll*/\nObject[] a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, each element is quoted like a Java String.\n * @param a an array\n * @return a string representation of the array, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@PolyAll*/\nObject[] a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, if quoted is true, then each element is quoted like a Java String.\n * @param a an array\n * @param quoted whether to quote the array elements\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@PolyAll*/\nObject[] a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            if (quoted && a[i] instanceof String) {\n                String elt = (String) a[i];\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava(elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(a[i]);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @param quoted whether to quote the collection elements that are Java strings\n * @return a string representation of the list\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@Nullable*/\nCollection<?> a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n        Iterator<?> itor = a.iterator();\n        sb.append(itor.next());\n        while (itor.hasNext()) {\n            sb.append(\", \");\n            Object elt = itor.next();\n            if (quoted && elt instanceof String) {\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava((String) elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(elt);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(int[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(long[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(double[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(float[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(boolean[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls the appropriate\n * toString() method.  Only call this method if obj is a boolean, double,\n * int, long, or Object array.\n * @param obj an array\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n        return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n        return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n        return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n        return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n        return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n        return toString((List<?>) obj);\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "length",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls .length.\n * Only call this method if obj is a boolean, double, int, long, or Object array.\n * @param obj a list\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n        return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n        return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n        return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n        return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n        return ((List<?>) obj).size();\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Sortedness\n///\n/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Boolean n = Boolean.valueOf(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Byte n = new Byte(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Float n = new Float(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Short n = new Short(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Integer n = new Integer(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space. Equality checking\n * uses the .equals() method for java.lang.Double.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Double n = new Double(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Long n = new Long(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param <T> the type of the elements\n * @param a a list\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static </*@Pure*/\nT> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n        if (hs.contains(a.get(i))) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a.get(i));\n    }\n    return true;\n}"
            ],
            [
                "fn_is_permutation",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Arrays as partial functions of int->int\n///\n/**\n * Returns true if the array is a permutation of [0..a.length).\n * @param a an array, representing a function\n * @return true iff all elements of a are in [0..a.length) and a\n * contains no duplicates.\n */\n// side effect to local state (array)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int n = a[i];\n        if (n < 0 || n >= a.length || see[n]) {\n            return false;\n        }\n        see[n] = true;\n    }\n    return true;\n}"
            ],
            [
                "fn_is_total",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff the array does not contain -1.\n * @param a an array, representing a function\n * @return true iff no element of a maps to -1\n */\n/*@Pure*/\npublic static boolean fn_is_total(int[] a) {\n    // not found\n    return indexOf(a, -1) == -1;\n}"
            ],
            [
                "fn_identity",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array [0..lenth).\n * @param length the length of the result\n * @return fresh array that is the identity function of the given length\n */\npublic static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n        result[i] = i;\n    }\n    return result;\n}"
            ],
            [
                "fn_inverse_permutation",
                "plume",
                "ArraysMDE",
                "/**\n * Requires that fn_is_permutation(a) holds.\n * @param a the input permutation\n * @return fresh array which is the inverse of the given permutation\n * @see #fn_is_permutation(int[])\n */\npublic static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n}"
            ],
            [
                "fn_inverse",
                "plume",
                "ArraysMDE",
                "/**\n * Return the inverse of the given function, which is represented as an array.\n * @param a an array representing a function from [0..a.length) to [0..arange);\n *  each element of a is between 0 and arange inclusive\n * @param arange length of the argument's range and the result's domain\n * @return function from [0..arange) to [0..a.length) that is the inverse of a\n * @throws IllegalArgumentException if a value of a is outside of arange\n * @exception UnsupportedOperationException when the function is not invertible\n */\npublic static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n        int ai = a[i];\n        if (ai < -1 || ai >= arange) {\n            throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n        }\n        // ai is either -1 or a valid index\n        if (ai >= 0) {\n            if (result[ai] != -1) {\n                throw new UnsupportedOperationException(String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n            }\n            result[ai] = i;\n        }\n    }\n    return result;\n}"
            ],
            [
                "fn_compose",
                "plume",
                "ArraysMDE",
                "/**\n * Return the composition of the given two functions, all of which are\n * represented as arrays.\n * @param a function from [0..a.length) to [0..b.length)\n * @param b function from [0..b.length) to range R\n * @return function from [0..a.length) to range R that is the\n * composition of a and b\n */\npublic static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int inner = a[i];\n        if (inner == -1) {\n            result[i] = -1;\n        } else {\n            result[i] = b[inner];\n        }\n    }\n    return result;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set operations, such as subset, unions, and intersections\n///\n// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Long(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Long elt = new Long(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Double(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Double elt = new Double(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(bigger[i]);\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        if (!setBigger.contains(smaller[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// nullness\n///\n/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(/*@PolyAll*/\nObject[] a) {\n    if (a.length == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(/*@PolyAll*/\nObject[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (!(a[i] == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n        if (!(a.get(i) == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "int_array_iterator",
                "plume",
                "TestPlume",
                "///////////////////////////////////////////////////////////////////////////\n/// Utility functions\n///\npublic static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n        asList.add(nums[i]);\n    }\n    return asList.iterator();\n}"
            ],
            [
                "int_iterator_array",
                "plume",
                "TestPlume",
                "public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    return v;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n        v.add(e.nextElement());\n    }\n    return v;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeSet",
                "/**\n * Merges a list of LimitedSizeSet&lt;T&gt; objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param <T> (super)type of elements of the sets\n * @param max_values the maximum size for the returned LimitedSizeSet\n * @param slist a list of LimitedSizeSet, whose elements will be merged\n * @return a LimitedSizeSet that merges the elements of slist\n */\npublic static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist) {\n    LimitedSizeSet<T> result = new LimitedSizeSet<T>(max_values);\n    for (LimitedSizeSet<? extends T> s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "serialVersionUID",
                "plume",
                "FileIOException",
                "static final long serialVersionUID = 20050923L;"
            ],
            [
                "counter",
                "plume",
                "DeterministicObject",
                "/**\n * The number of objects created so far.\n */\nstatic int counter = 0;"
            ],
            [
                "home",
                "plume",
                "MultiVersionControl",
                "@Option(value = \"User home directory\", noDocDefault = true)\npublic static String home = System.getProperty(\"user.home\");"
            ],
            [
                "debug",
                "plume",
                "MultiVersionControl",
                "// It would be good to be able to set this per-checkout.\n// This variable is static because it is used in static methods.\n@Option(\"Print debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "idf",
                "plume",
                "MultiVersionControl",
                "static IsDirectoryFilter idf = new IsDirectoryFilter();"
            ],
            [
                "help",
                "plume",
                "Lookup",
                "/**\n * Show detailed help information and exit.\n */\n@OptionGroup(\"Getting help\")\n@Option(\"-h Show detailed help information\")\npublic static boolean help = false;"
            ],
            [
                "verbose",
                "plume",
                "Lookup",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "entry_file",
                "plume",
                "Lookup",
                "// This uses only the first file because the default search path might be\n// something like user:system and you might want only your version of the\n// system files.  It might be useful to also support (via another flag,\n// or by taking over this one, or by the syntax of the separator, or in\n// some other way) specifying multiple files on the command line.\n/**\n * Specify the colon-separated search list for the file that contains\n * information to be searched.  Only the first file found is used, though\n * it may itself contain include directives.\n */\n@OptionGroup(\"Where to search\")\n@Option(\"-f Specify the colon-separated search list of files of information; may only be supplied once\")\npublic static String entry_file = \"~/lookup/root\";"
            ],
            [
                "search_body",
                "plume",
                "Lookup",
                "/**\n * Search the body of long entries in addition to the entry's\n * description.  The bodies of short entries are always searched.\n */\n@Option(\"-b Search body of long entries for matches\")\npublic static boolean search_body = false;"
            ],
            [
                "regular_expressions",
                "plume",
                "Lookup",
                "/**\n * Specifies that keywords are regular expressions.  If false, keywords\n * are text matches.\n */\n@OptionGroup(\"What to search for\")\n@Option(\"-e Keywords are regular expressions\")\npublic static boolean regular_expressions = false;"
            ],
            [
                "case_sensitive",
                "plume",
                "Lookup",
                "/**\n * If true, keywords matching is case sensistive.  By default, both\n * regular expressions and text keywords are case-insensitive.\n */\n@Option(\"-c Keywords are case sensistive\")\npublic static boolean case_sensitive = false;"
            ],
            [
                "word_match",
                "plume",
                "Lookup",
                "/**\n * If true, match a text keyword only as a separate word, not as a\n * substring of a word.  This option is ignored if\n * regular_expressions is true.\n */\n@Option(\"-w Only match text keywords against complete words\")\npublic static boolean word_match = false;"
            ],
            [
                "print_all",
                "plume",
                "Lookup",
                "/**\n * By default, if multiple entries are matched, only a synopsis\n * of each entry is printed.  If 'print_all' is selected then\n * the body of each matching entry is printed.\n */\n@OptionGroup(\"How to print matches\")\n@Option(\"-a Print the entire entry for each match\")\npublic static boolean print_all = false;"
            ],
            [
                "item_num",
                "plume",
                "Lookup",
                "/**\n * Specifies which item to print when there are multiple matches.\n * The index is 1-based; that is, it starts counting at 1.\n */\n@Option(\"-i Choose a specific item when there are multiple matches; index is 1-based\")\npublic static Integer /*@Nullable*/\nitem_num;"
            ],
            [
                "show_location",
                "plume",
                "Lookup",
                "/**\n * If true, show the filename/line number of each matching entry\n * in the output.\n */\n@Option(\"-l Show the location of each matching entry\")\npublic static boolean show_location = false;"
            ],
            [
                "entry_start_re",
                "plume",
                "Lookup",
                "@OptionGroup(\"Customizing format of files to be searched\")\n@Option(\"Regex that denotes the start of a long entry\")\npublic static Pattern /*@Regex(1)*/\nentry_start_re = Pattern.compile(\"^>entry *()\");"
            ],
            [
                "entry_stop_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that denotes the end of a long entry\")\npublic static Pattern entry_stop_re = Pattern.compile(\"^<entry\");"
            ],
            [
                "description_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that finds an entry's description (for long entries)\")\npublic static Pattern /*@Nullable*/\ndescription_re = null;"
            ],
            [
                "comment_re",
                "plume",
                "Lookup",
                "// If \"\", gets set to null immediately after option processing.\n@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Nullable*/\n/*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "runtime",
                "plume",
                "FileCompiler",
                "/**\n * The Runtime of the JVM.\n */\npublic static Runtime runtime = java.lang.Runtime.getRuntime();"
            ],
            [
                "java_filename_pattern",
                "plume",
                "FileCompiler",
                "/**\n * Matches the names of Java source files.\n * Match group 1 is the complete filename.\n */\nstatic Pattern /*@Regex(1)*/\njava_filename_pattern;"
            ],
            [
                "responsible",
                "plume",
                "TaskManager",
                "// Command line options\n@Option(\"-r Include only those tasks assigned to the specified person\")\npublic static String /*@Nullable*/\nresponsible = null;"
            ],
            [
                "milestone",
                "plume",
                "TaskManager",
                "@Option(\"-m Include only those tasks required for the specified milestone\")\npublic static String /*@Nullable*/\nmilestone = null;"
            ],
            [
                "completed",
                "plume",
                "TaskManager",
                "@Option(\"-c Include only completed tasks\")\npublic static boolean completed = false;"
            ],
            [
                "open",
                "plume",
                "TaskManager",
                "@Option(\"-o Include only open tasks\")\npublic static boolean open = false;"
            ],
            [
                "verbose",
                "plume",
                "TaskManager",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "format",
                "plume",
                "TaskManager",
                "@Option(\"-f Specify output format\")\npublic static OutputFormat format = OutputFormat.short_ascii;"
            ],
            [
                "comment_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "lineSep",
                "plume",
                "TaskManager",
                "// line.separator property is a legal regex\n@SuppressWarnings(\"regex\")\npublic static final String /*@Regex*/\nlineSep = System.getProperty(\"line.separator\");"
            ],
            [
                "minversion",
                "plume",
                "ClassFileVersion",
                "/**\n * Only report versions that are at least this large.\n */\nstatic double minversion = 0;"
            ],
            [
                "debug",
                "plume",
                "DeclarationAnnotations",
                "static boolean debug = false;"
            ],
            [
                "date",
                "plume",
                "ICalAvailable",
                "/// User options\n@Option(\"first date to summarize\")\npublic static String date = \"today\";"
            ],
            [
                "start_date",
                "plume",
                "ICalAvailable",
                "public static DateTime start_date = new DateTime();"
            ],
            [
                "days",
                "plume",
                "ICalAvailable",
                "@Option(\"number of calendar days to summarize\")\npublic static int days = 8;"
            ],
            [
                "iCal_URL",
                "plume",
                "ICalAvailable",
                "/**\n * For a Google calendar:  go to settings, then click on the green \"ICAL\"\n * icon for the \"private address\".\n */\n@Option(\"<url> schedule in iCal format\")\npublic static List<String> iCal_URL = new ArrayList<String>();"
            ],
            [
                "business_hours",
                "plume",
                "ICalAvailable",
                "/**\n * A list of time ranges, expressed as a String.\n * Example: 9am-5pm,7:30pm-9:30pm\n */\n@Option(\"time ranges during which appointments are permitted\")\npublic static String business_hours = \"9am-5pm\";"
            ],
            [
                "businessHours",
                "plume",
                "ICalAvailable",
                "// initialize to 9am-5pm\nstatic List<Period> businessHours = new ArrayList<Period>();"
            ],
            [
                "businessDays",
                "plume",
                "ICalAvailable",
                "// initialize to Mon-Fri\nstatic List<Integer> businessDays = new ArrayList<Integer>();"
            ],
            [
                "tzRegistry",
                "plume",
                "ICalAvailable",
                "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();"
            ],
            [
                "timezone1",
                "plume",
                "ICalAvailable",
                "/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * Available times are printed in this time zone.  It defaults to the\n * system time zone.\n */\n// don't need \"e.g.: America/New_York\" in message:  the default is an example\n@Option(value = \"<timezone> time zone, e.g.: America/New_York\", noDocDefault = true)\npublic static String timezone1 = TimeZone.getDefault().getID();"
            ],
            [
                "tz1",
                "plume",
                "ICalAvailable",
                "// Either of these initializations causes a NullPointerException\n// at net.fortuna.ical4j.model.TimeZone.<init>(TimeZone.java:67)\n// static TimeZone tz1 = new TimeZone(new VTimeZone());\n// static TimeZone tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));\nstatic TimeZone /*@MonotonicNonNull*/\ntz1;"
            ],
            [
                "timezone2",
                "plume",
                "ICalAvailable",
                "// If I'm outputting in a different timezone, then my notion of a \"day\"\n// may be different than the other timezone's notion of a \"day\".  This\n// doesn't seem important enough to fix right now.\n/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * If set, then free times are printed in two time zones.\n */\n@Option(\"<timezone> optional second time zone, e.g.: America/New_York\")\npublic static String /*@Nullable*/\ntimezone2;"
            ],
            [
                "tz2",
                "plume",
                "ICalAvailable",
                "static TimeZone /*@Nullable*/\ntz2;"
            ],
            [
                "debug",
                "plume",
                "ICalAvailable",
                "/// Other variables\n@Option(\"enable debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "calendars",
                "plume",
                "ICalAvailable",
                "/**\n * The appointments (the times that are unavailable for a meeting).\n */\nstatic List<Calendar> calendars = new ArrayList<Calendar>();"
            ],
            [
                "tf",
                "plume",
                "ICalAvailable",
                "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);"
            ],
            [
                "df",
                "plume",
                "ICalAvailable",
                "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);"
            ],
            [
                "dffull",
                "plume",
                "ICalAvailable",
                "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);"
            ],
            [
                "canonicalTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> canonicalTimezones = new HashMap<String, String>();"
            ],
            [
                "printedTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> printedTimezones = new HashMap<String, String>();"
            ],
            [
                "timeRegexp",
                "plume",
                "ICalAvailable",
                "static Pattern /*@Regex(4)*/\ntimeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");"
            ],
            [
                "dateFormats",
                "plume",
                "ICalAvailable",
                "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};"
            ],
            [
                "skip_checks",
                "plume",
                "BCELUtil",
                "/**\n * Controls whether the checks in checkMgen are actually performed.\n */\npublic static boolean skip_checks = false;"
            ],
            [
                "userHome",
                "plume",
                "UtilMDE",
                "static final String userHome = System.getProperty(\"user.home\");"
            ],
            [
                "args_seen",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Method\n///\n/**\n * Maps from a comma-delimited string of arg types, such as appears in a\n * method signature, to an array of Class objects, one for each arg\n * type. Example keys include: \"java.lang.String, java.lang.String,\n * java.lang.Class[]\" and \"int,int\".\n */\nstatic HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();"
            ],
            [
                "serialVersionUID",
                "plume",
                "UtilMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "NullableStringComparator",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeIntSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "split_lists",
                "plume",
                "Options",
                "/**\n * When true, an argument to a option of list type is split, on\n * whitespace, into multiple arguments each of which is added to the\n * list.  When false, each argument to an option of list type is treated\n * as a single element, no matter what characters it contains.\n */\n@Option(\"Treat arguments to lists as space-separated.\")\npublic static boolean split_lists = false;"
            ],
            [
                "serialVersionUID",
                "plume",
                "Options",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArgException",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "StringArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "short_run",
                "plume",
                "TestPlume",
                "// If true, do 100 instead of 100000 iterations when testing randomElements.\n// This saves only a little time.  However, it is significant when running\n// under instrumentation such as that of Chicory.\nstatic boolean short_run = false;"
            ],
            [
                "mass",
                "plume",
                "TestPlume",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestPlume",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestPlume",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "mass",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestOptionGroups1",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups2",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups3",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "FuzzyFloat",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "base",
                "",
                "long"
            ],
            [
                "expt",
                "",
                "long"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 10083,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "plume-lib-1.1.0",
        "packageName": "plume",
        "className": "MathMDE",
        "javadocTag": "@param itor iterator of operands",
        "methodJavadoc": "    /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */",
        "methodSourceCode": "public static int[] modulus_int(Iterator<Integer> itor){\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}",
        "classJavadoc": "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
        "classSourceCode": "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "FileIOException",
                "plume"
            ],
            [
                "MathMDE",
                "plume"
            ],
            [
                "DeterministicObject",
                "plume"
            ],
            [
                "Digest",
                "plume"
            ],
            [
                "StringBuilderDelimited",
                "plume"
            ],
            [
                "OrderedPairIterator",
                "plume"
            ],
            [
                "CountingPrintWriter",
                "plume"
            ],
            [
                "MultiVersionControl",
                "plume"
            ],
            [
                "WeakIdentityHashMap",
                "plume"
            ],
            [
                "IterableIterator",
                "plume"
            ],
            [
                "Lookup",
                "plume"
            ],
            [
                "Pair",
                "plume"
            ],
            [
                "FileCompiler",
                "plume"
            ],
            [
                "MultiRandSelector",
                "plume"
            ],
            [
                "RandoopMappedCalls",
                "plume"
            ],
            [
                "Stopwatch",
                "plume"
            ],
            [
                "TaskManager",
                "plume"
            ],
            [
                "WeakHasherMap",
                "plume"
            ],
            [
                "ClassFileVersion",
                "plume"
            ],
            [
                "WeakIdentityPair",
                "plume"
            ],
            [
                "OptionsDoclet",
                "plume"
            ],
            [
                "DeclarationAnnotations",
                "plume"
            ],
            [
                "Option",
                "plume"
            ],
            [
                "RegexUtil",
                "plume"
            ],
            [
                "JWhich",
                "plume"
            ],
            [
                "TimeLimitProcess",
                "plume"
            ],
            [
                "Intern",
                "plume"
            ],
            [
                "GraphMDE",
                "plume"
            ],
            [
                "HtmlPrettyPrint",
                "plume"
            ],
            [
                "SimpleLog",
                "plume"
            ],
            [
                "OptionGroup",
                "plume"
            ],
            [
                "ICalAvailable",
                "plume"
            ],
            [
                "RandomSelector",
                "plume"
            ],
            [
                "BCELUtil",
                "plume"
            ],
            [
                "UtilMDE",
                "plume"
            ],
            [
                "Hasher",
                "plume"
            ],
            [
                "BibtexClean",
                "plume"
            ],
            [
                "LimitedSizeIntSet",
                "plume"
            ],
            [
                "Partitioner",
                "plume"
            ],
            [
                "Triple",
                "plume"
            ],
            [
                "Options",
                "plume"
            ],
            [
                "ArraysMDE",
                "plume"
            ],
            [
                "StrTok",
                "plume"
            ],
            [
                "Unpublicized",
                "plume"
            ],
            [
                "TestPlume",
                "plume"
            ],
            [
                "LimitedSizeSet",
                "plume"
            ],
            [
                "EntryReader",
                "plume"
            ],
            [
                "Filter",
                "plume"
            ],
            [
                "FuzzyFloat",
                "plume"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "negate",
                "plume",
                "MathMDE",
                "///\n/// Function versions of Java operators\n///\n/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static int negate(int a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static long negate(long a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static double negate(double a) {\n    return -a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static int bitwiseComplement(int a) {\n    return ~a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static long bitwiseComplement(long a) {\n    return ~a;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static int mul(int x, int y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static long mul(long x, long y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static double mul(double x, double y) {\n    return x * y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static int div(int x, int y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static long div(long x, long y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static double div(double x, double y) {\n    return x / y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static int mod(int x, int y) {\n    return x % y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static long mod(long x, long y) {\n    return x % y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static int lshift(int x, int y) {\n    return x << y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static long lshift(long x, long y) {\n    return x << y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static int rshiftSigned(int x, int y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static long rshiftSigned(long x, long y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static int bitwiseAnd(int x, int y) {\n    return x & y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static long bitwiseAnd(long x, long y) {\n    return x & y;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static int logicalAnd(int x, int y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static long logicalAnd(long x, long y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static int bitwiseXor(int x, int y) {\n    return x ^ y;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static long bitwiseXor(long x, long y) {\n    return x ^ y;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static int logicalXor(int x, int y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static long logicalXor(long x, long y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static int bitwiseOr(int x, int y) {\n    return x | y;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static long bitwiseOr(long x, long y) {\n    return x | y;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static int logicalOr(int x, int y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static long logicalOr(long x, long y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "sign",
                "plume",
                "MathMDE",
                "///\n/// sign\n///\n/**\n * Returns the sign of its argument.  The result is always -1, 0, or 1.\n * @param a value to have its sign taken\n * @return the sign of a: -1, 0, or 1\n */\npublic static int sign(int a) {\n    if (a == 0) {\n        return 0;\n    } else if (a > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "///\n/// exponentiation\n///\n/**\n * Returns of value of the first argument raised to the\n * power of the second argument.  The arguments are integers.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "/**\n * Returns of value of the first argument raised to the\n * power of the second argument.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "///\n/// gcd\n///\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static int gcd(int a, int b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        int tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/// gcd -- version for manipulating long (rather than int) values\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static long gcd(long a, long b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static double gcd(double a, double b) {\n    if (a == Double.POSITIVE_INFINITY || a == Double.NEGATIVE_INFINITY || Double.isNaN(a) || b == Double.POSITIVE_INFINITY || b == Double.NEGATIVE_INFINITY || Double.isNaN(b)) {\n        return Double.NaN;\n    }\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        double tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "///\n/// Modulus\n///\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nint mod_positive(int x, /*@PolyUpperBound*/\nint y) {\n    int result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static int[] modulus(int[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new int[] { remainder, modulus };\n}"
            ],
            [
                "modulus_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(int[])\n */\npublic static int[] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static int[] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    int modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(int[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().intValue();\n    }\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().intValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "/// modulus for long (as opposed to int) values\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nlong mod_positive(long x, /*@PolyUpperBound*/\nlong y) {\n    long result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static long[] modulus(long[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new long[] { remainder, modulus };\n}"
            ],
            [
                "modulus_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(long[])\n */\npublic static long[] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        long i = itor.next().longValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static long[] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    long modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(long[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().longValue();\n    }\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().longValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "///\n/// Non-Modulus\n///\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] missing_numbers(int[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length - 1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static int[] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   int range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2);\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = mod_positive(nums[i], m);\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new int[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "/// non-modulus for long (as opposed to int) values\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] missing_numbers(long[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length - 1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static long[] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   long range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2)));\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = ((int) (mod_positive(nums[i], m)));\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new long[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "getFileDigest",
                "plume",
                "Digest",
                "/**\n * This convenience method is used by both create() and verify().  It\n * reads the contents of a named file and computes a message digest\n * for it, using the specified MessageDigest object.\n * @param filename the file to read\n * @param md the MessageDigest\n * @return the message digest\n * @throws IOException if there is a problem reading the file\n */\npublic static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    // Read to the end of the file, discarding everything we read. {\n    // The DigestInputStream automatically passes all the bytes read to\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) {\n        /* do nothing */\n    }\n    // Finally, compute and return the digest value.\n    byte[] result = md.digest();\n    in.close();\n    return result;\n}"
            ],
            [
                "hexEncode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert an array of bytes to a String.  We do\n * this simply by converting each byte to two hexadecimal digits.  Something\n * like Base 64 encoding is more compact, but harder to encode.\n * @param bytes the bytes to convert to a String\n * @return a String representation of the input bytes\n */\npublic static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}"
            ],
            [
                "hexDecode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert from a string\n * of hexadecimal digits to an array of bytes.\n * This method is the reverse of {@link #hexEncode(byte[])}.\n * @param s the String to convert to an array of bytes\n * @return the bytes equivalent to the input String\n */\npublic static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9')) {\n                digit1 -= '0';\n            } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n                digit1 -= 'a' - 10;\n            }\n            if ((digit2 >= '0') && (digit2 <= '9')) {\n                digit2 -= '0';\n            } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n                digit2 -= 'a' - 10;\n            }\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}"
            ],
            [
                "dirToCheckoutHg",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".hg\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutHg(File hgDir, File dir) {\n    String repository = null;\n    File hgrcFile = new File(hgDir, \"hgrc\");\n    Ini ini;\n    // There also exist Hg commands that will do this same thing.\n    if (hgrcFile.exists()) {\n        try {\n            ini = new Ini(new FileReader(hgrcFile));\n        } catch (IOException e) {\n            throw new Error(\"Problem reading file \" + hgrcFile);\n        }\n        Ini.Section pathsSection = ini.get(\"paths\");\n        if (pathsSection != null) {\n            repository = pathsSection.get(\"default\");\n            if (repository != null && repository.endsWith(\"/\")) {\n                repository = repository.substring(0, repository.length() - 1);\n            }\n        }\n    }\n    return new Checkout(RepoType.HG, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutGit",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".git\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutGit(File gitDir, File dir) {\n    String repository = UtilMDE.backticks(\"git\", \"config\", \"remote.origin.url\");\n    return new Checkout(RepoType.GIT, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutSvn",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory that contains a .svn subdirectory, create a\n * corresponding Checkout object.\n * Returns null if this is not possible.\n */\nstatic /*@Nullable*/\nCheckout dirToCheckoutSvn(File dir) {\n    // For SVN, do\n    //   svn info\n    // and grep out these lines:\n    //   URL: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository/trunk/www\n    //   Repository Root: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository\n    // Use SVNKit?\n    // Con: introduces dependency on external library.\n    // Pro: no need to re-implement or to call external process (which\n    //   might be slow for large checkouts).\n    // unannotated library: SVNKit\n    @SuppressWarnings(\"nullness\")\n    SVNWCClient wcClient = new SVNWCClient((/*@Nullable*/\n    ISVNAuthenticationManager) null, null);\n    SVNInfo info;\n    try {\n        info = wcClient.doInfo(new File(dir.toString()), SVNRevision.WORKING);\n    } catch (SVNException e) {\n        // throw new Error(\"Problem in dirToCheckoutSvn(\" + dir + \"): \", e);\n        System.err.println(\"Problem in dirToCheckoutSvn(\" + dir + \"): \" + e.getMessage());\n        if (e.getMessage() != null && e.getMessage().contains(\"This client is too old\")) {\n            System.err.println(\"plume-lib needs a newer version of SVNKit.\");\n        }\n        return null;\n    }\n    // getFile is null when operating on a working copy, as I am\n    // String relativeFile = info.getPath(); // relative to repository root -- can use to determine root of checkout\n    // getFile is just the (absolute) local file name for local items -- same as \"dir\"\n    // File relativeFile = info.getFile();\n    SVNURL url = info.getURL();\n    // This can be null (example: dir /afs/csail.mit.edu/u/m/mernst/.snapshot/class/6170/2006-spring/3dphysics).  I don't know under what circumstances.\n    SVNURL repoRoot = info.getRepositoryRootURL();\n    if (repoRoot == null) {\n        System.err.println(\"Problem:  old svn working copy in \" + dir.toString());\n        System.err.println(\"Check it out again to get a 'Repository Root' entry in the svn info output.\");\n        System.err.println(\"  repoUrl = \" + url);\n        System.exit(2);\n    }\n    if (debug) {\n        System.out.println();\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"     dir = \" + dir.toString());\n    }\n    // Strip common suffix off of local dir and repo url.\n    Pair<File, File> /*@Nullable*/\n    /*@Nullable*/\n    stripped = removeCommonSuffixDirs(dir, new File(url.getPath()), new File(repoRoot.getPath()), \".svn\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n        System.out.printf(\"dir (%s) is parent of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    if (stripped.b == null) {\n        System.out.printf(\"dir (%s) is child of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    String pathInRepoAtCheckout = stripped.b.toString();\n    try {\n        url = url.setPath(pathInRepoAtCheckout, false);\n    } catch (SVNException e) {\n        throw new Error(e);\n    }\n    if (debug) {\n        System.out.println(\"stripped: \" + stripped);\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"    cDir = \" + cDir.toString());\n    }\n    assert url.toString().startsWith(repoRoot.toString()) : \"repoRoot=\" + repoRoot + \", url=\" + url;\n    return new Checkout(RepoType.SVN, cDir, url.toString(), null);\n    /// Old implementation\n    // String module = url.toString().substring(repoRoot.toString().length());\n    // if (module.startsWith(\"/\")) {\n    //   module = module.substring(1);\n    // }\n    // if (module.equals(\"\")) {\n    //   module = null;\n    // }\n    // return new Checkout(RepoType.SVN, cDir, repoRoot.toString(), module);\n}"
            ],
            [
                "removeCommonSuffixDirs",
                "plume",
                "MultiVersionControl",
                "/**\n * Strip identical elements off the end of both paths, and then return\n * what is left of each.  Returned elements can be null!  If p2_limit is\n * non-null, then it should be a parent of p2, and the stripping stops\n * when p2 becomes p2_limit.  If p1_contains is non-null, then p1 must\n * contain a subdirectory of that name.\n */\nstatic Pair</*@Nullable*/\nFile, /*@Nullable*/\nFile> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains) {\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\", p1, p2, p2_limit, p1_contains);\n    }\n    // new names for results, because we will be side-effecting them\n    File r1 = p1;\n    File r2 = p2;\n    while (r1 != null && r2 != null && (p2_limit == null || !r2.equals(p2_limit)) && r1.getName().equals(r2.getName())) {\n        if (p1_contains != null && !new File(r1.getParentFile(), p1_contains).isDirectory()) {\n            break;\n        }\n        r1 = r1.getParentFile();\n        r2 = r2.getParentFile();\n    }\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs => %s %s%n\", r1, r2);\n    }\n    return Pair.of(r1, r2);\n}"
            ],
            [
                "eq",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Check for equality of non-null reference x and possibly-null y.  Uses\n * identity equality.\n */\n/*@Pure*/\nstatic boolean eq(Object x, /*@Nullable*/\nObject y) {\n    return x == y;\n}"
            ],
            [
                "hasher",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return the hash code for x\n */\n/*@Pure*/\nstatic int hasher(Object x) {\n    return System.identityHashCode(x);\n}"
            ],
            [
                "indexFor",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return index for hash code h.\n */\n/*@Pure*/\nstatic int indexFor(int h, int length) {\n    return h & (length - 1);\n}"
            ],
            [
                "old_get_entry",
                "plume",
                "Lookup",
                "/**\n * Returns the next entry.  If no more entries are available, returns null.\n * @param reader where to read the entry from\n * @return the next entry, or null\n * @throws IOException if there is a problem reading a file\n */\npublic static /*@Nullable*/\nEntry old_get_entry(EntryReader reader) throws IOException {\n    try {\n        // Skip any preceeding blank lines\n        String line = reader.readLine();\n        while ((line != null) && (line.trim().length() == 0)) {\n            line = reader.readLine();\n        }\n        if (line == null) {\n            return (null);\n        }\n        Entry entry = null;\n        String filename = reader.getFileName();\n        long line_number = reader.getLineNumber();\n        // If this is a long entry\n        if (line.startsWith(\">entry\")) {\n            // Get the current filename\n            String current_filename = reader.getFileName();\n            // Remove '>entry' from the line\n            line = line.replaceFirst(\"^>entry *\", \"\");\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find the termination of the entry\n            while ((line != null) && !line.startsWith(\">entry\") && !line.equals(\"<entry\") && current_filename.equals(reader.getFileName())) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            // If this entry was terminated by the start of the next one,\n            // put that line back\n            if ((line != null) && (line.startsWith(\">entry\") || !current_filename.equals(reader.getFileName()))) {\n                reader.putback(line);\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, false);\n        } else {\n            // blank separated entry\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find another blank line\n            while ((line != null) && (line.trim().length() != 0)) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, true);\n        }\n        return (entry);\n    } catch (FileNotFoundException e) {\n        System.out.printf(\"Error: Can't read %s at line %d in file %s%n\", e.getMessage(), reader.getLineNumber(), reader.getFileName());\n        System.exit(254);\n        return (null);\n    }\n}"
            ],
            [
                "first_line",
                "plume",
                "Lookup",
                "/**\n * Returns the first line of entry.\n * @param entry the entry whose first line to return\n * @return the first line of entry\n */\npublic static String first_line(String entry) {\n    int ii = entry.indexOf(lineSep);\n    if (ii == -1) {\n        return entry;\n    }\n    return entry.substring(0, ii);\n}"
            ],
            [
                "of",
                "plume",
                "Pair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a pair of the values (a, b)\n */\npublic static <A extends /*@Nullable*/\nObject, B extends /*@Nullable*/\nObject> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "short_str",
                "plume",
                "TaskManager",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "short_str",
                "plume",
                "Task",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "versionNumbers",
                "plume",
                "ClassFileVersion",
                "/**\n * Return an array of the major vernios, minor version, and JDK version\n * of the class read from the input stream.\n * Return null if there is an error or the input isn't a class file.\n * @param is input stream from which to read a class\n * @return array of three version numbers\n */\npublic static double[] versionNumbers(InputStream is) {\n    try {\n        DataInputStream dis = new DataInputStream(is);\n        int magic = dis.readInt();\n        if (magic != 0xcafebabe) {\n            return null;\n        }\n        double minor = dis.readShort();\n        double major = dis.readShort();\n        double jdkVersion;\n        if (major < 48) {\n            // really 1.3.1\n            jdkVersion = 1.3;\n        } else if (major == 48) {\n            // really 1.4.2\n            jdkVersion = 1.4;\n        } else if (major == 49) {\n            jdkVersion = 1.5;\n        } else if (major == 50) {\n            jdkVersion = 6;\n        } else {\n            jdkVersion = 7;\n        }\n        return new double[] { major, minor, jdkVersion };\n    } catch (IOException e) {\n        return null;\n    }\n}"
            ],
            [
                "of",
                "plume",
                "WeakIdentityPair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a WeakIdentityPair of (a, b)\n */\npublic static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b) {\n    return new WeakIdentityPair<A, B>(a, b);\n}"
            ],
            [
                "start",
                "plume",
                "OptionsDoclet",
                "// Doclet-specific methods\n/**\n * Entry point for the doclet.\n * @param root the root document\n * @return true if processing completed without an error\n */\npublic static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n        // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n        // returns a fully qualified name.  I do not know a good way to convert\n        // between these two name formats.  For now, we simply ignore inner\n        // classes.  This limitation can be removed when we figure out a better\n        // way to go from ClassDoc to Class<?>.\n        if (doc.containingClass() != null) {\n            continue;\n        }\n        Class<?> clazz;\n        try {\n            // Javadoc source code is not yet annotated\n            @SuppressWarnings(\"signature\")\n            String /*@BinaryNameForNonArray*/\n            className = doc.qualifiedName();\n            clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        }\n        if (needsInstantiation(clazz)) {\n            try {\n                Constructor<?> c = clazz.getDeclaredConstructor();\n                c.setAccessible(true);\n                objs.add(c.newInstance(new Object[0]));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            objs.add(clazz);\n        }\n    }\n    if (objs.isEmpty()) {\n        System.out.println(\"Error: no classes found\");\n        return false;\n    }\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n        System.out.println(\"Error: no @Option-annotated fields found\");\n        return false;\n    }\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n        o.write();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "optionLength",
                "plume",
                "OptionsDoclet",
                "/**\n * Given a command-line option of this doclet, returns the number of\n * arguments you must specify on the command line for the given option.\n * Returns 0 if the argument is not recognized.  This method is\n * automatically invoked.\n *\n * @param option the command-line option\n * @return the number of command-line arguments needed when using the option\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n        System.out.printf(USAGE);\n        return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n        return 1;\n    }\n    if (option.equals(\"-docfile\") || option.equals(\"-outfile\") || option.equals(\"-format\") || option.equals(\"-d\")) {\n        return 2;\n    }\n    return 0;\n}"
            ],
            [
                "validOptions",
                "plume",
                "OptionsDoclet",
                "/**\n * Tests the validity of command-line arguments passed to this doclet.\n * Returns true if the option usage is valid, and false otherwise.  This\n * method is automatically invoked.\n *\n * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n * @param reporter where to report errors\n * @return true iff the command-line options are valid\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            if (hasDocFile) {\n                reporter.printError(\"-docfile option specified twice\");\n                return false;\n            }\n            File f = new File(os[1]);\n            if (!f.exists()) {\n                reporter.printError(\"-docfile file not found: \" + os[1]);\n                return false;\n            }\n            docFile = os[1];\n            hasDocFile = true;\n        }\n        if (opt.equals(\"-outfile\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-outfile option specified twice\");\n                return false;\n            }\n            if (inPlace) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            outFile = os[1];\n            hasOutFile = true;\n        }\n        if (opt.equals(\"-i\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            inPlace = true;\n        }\n        if (opt.equals(\"-format\")) {\n            if (hasFormat) {\n                reporter.printError(\"-format option specified twice\");\n                return false;\n            }\n            if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n                reporter.printError(\"unrecognized output format: \" + os[1]);\n                return false;\n            }\n            hasFormat = true;\n        }\n        if (opt.equals(\"-d\")) {\n            if (hasDestDir) {\n                reporter.printError(\"-d specified twice\");\n                return false;\n            }\n            hasDestDir = true;\n        }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n        reporter.printError(\"docfile must be different from outfile\");\n        return false;\n    }\n    if (inPlace && docFile == null) {\n        reporter.printError(\"-i supplied but -docfile was not\");\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "javadocToHtml",
                "plume",
                "OptionsDoclet",
                "/**\n * Replace the @link tags and block @see tags in a Javadoc comment with\n * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n * comment while still being presentable. <p>\n *\n * This is only a temporary solution.  Ideally, @link/@see tags would be\n * converted to HTML links that point to actual documentation.\n *\n * @param doc a Javadoc comment to convert to HTML\n * @return HTML version of doc\n */\npublic static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n        if (tag instanceof SeeTag) {\n            b.append(\"<code>\" + tag.text() + \"</code>\");\n        } else {\n            b.append(tag.text());\n        }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n        b.append(\" See: \");\n        {\n            StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n            for (SeeTag tag : seetags) {\n                bb.append(\"<code>\" + tag.text() + \"</code>\");\n            }\n            b.append(bb);\n        }\n        b.append(\".\");\n    }\n    return b.toString();\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param s string to check for being a regular expression\n * @return true iff s is a regular expression\n */\n/*@Pure*/\n/*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\npublic static boolean isRegex(String s) {\n    return isRegex(s, 0);\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression with at least the given number of groups.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return true iff s is a regular expression with groups groups\n */\n// RegexUtil; for purity, catches an exception\n@SuppressWarnings({ \"regex\", \"deterministic\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(String s, int groups) {\n    Pattern p;\n    try {\n        p = Pattern.compile(s);\n    } catch (PatternSyntaxException e) {\n        return false;\n    }\n    return getGroupCount(p) >= groups;\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param c char to check for being a regular expression\n * @return true iff c is a regular expression\n */\n@SuppressWarnings({ \"regex\", \"purity.not.deterministic.call\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(char c) {\n    return isRegex(Character.toString(c));\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a string describing why the argument is\n * not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nString regexError(String s) {\n    return regexError(s, 0);\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns\n * a string describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil;\n@SuppressWarnings({ \"regex\", \"not.sef\" })\npublic static /*@Nullable*/\nString regexError(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return regexErrorMessage(s, groups, actualGroups);\n        }\n    } catch (PatternSyntaxException e) {\n        return e.getMessage();\n    }\n    return null;\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a PatternSyntaxException describing\n * why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s) {\n    return regexException(s, 0);\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns a\n * PatternSyntaxException describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return new PatternSyntaxException(regexErrorMessage(s, groups, actualGroups), s, -1);\n        }\n    } catch (PatternSyntaxException pse) {\n        return pse;\n    }\n    return null;\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex String} if it is a regex,\n * otherwise throws an error. The purpose of this method is to suppress Regex\n * Checker warnings. It should be very rarely needed.\n * @param s string to check for being a regular expression\n * @return its argument\n * @throws Error if argument is not a regex\n */\n/*@SideEffectFree*/\n// The return type annotation is a conservative bound.\npublic static /*@Regex*/\nString asRegex(String s) {\n    return asRegex(s, 0);\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex(groups) String} if it is a regex\n * with at least the given number of groups, otherwise throws an error. The\n * purpose of this method is to suppress Regex Checker warnings. It should\n * be very rarely needed.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return its argument\n * @throws Error if argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Regex*/\nString asRegex(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            throw new Error(regexErrorMessage(s, groups, actualGroups));\n        }\n        return s;\n    } catch (PatternSyntaxException e) {\n        throw new Error(e);\n    }\n}"
            ],
            [
                "findClass",
                "plume",
                "JWhich",
                "/**\n * Returns the URL of the resource denoted by the specified\n * class name, as prescribed by the class path.\n *\n * @param className name of the class\n * @return class URL, or null of the class was not found\n */\npublic static /*@Nullable*/\nURL findClass(final String className) {\n    return JWhich.class.getResource(asResourceName(className));\n}"
            ],
            [
                "asResourceName",
                "plume",
                "JWhich",
                "protected static String asResourceName(String resource) {\n    if (!resource.startsWith(\"/\")) {\n        resource = \"/\" + resource;\n    }\n    resource = resource.replace('.', '/');\n    resource = resource + \".class\";\n    return resource;\n}"
            ],
            [
                "getClasspath",
                "plume",
                "JWhich",
                "/**\n * Return the classpath.\n * @return the classpath\n */\n/*@EnsuresNonNull(\"CLASSPATH\")*/\nprotected static String getClasspath() {\n    if (CLASSPATH == null) {\n        String classpath = System.getProperty(\"java.class.path\");\n        setClasspath(classpath);\n    }\n    return CLASSPATH;\n}"
            ],
            [
                "internStrings",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Strings\n///\n/**\n * Replace each element of the array by its interned version.\n * Side-effects the array, but also returns it.\n * @param a the array whose elements to intern in place\n * @return an interned version of a\n * @see String#intern\n */\n// side-effects the array in place (dangerous, but convenient)\n@SuppressWarnings(\"interning\")\npublic static String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] != null) {\n            a[i] = a[i].intern();\n        }\n    }\n    return a;\n}"
            ],
            [
                "isInterned",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Testing interning\n///\n/**\n * Return true if the argument is interned (is canonical among all\n * objects equal to itself).\n * @param value the value to test for interning\n * @return true iff value is interned\n */\n// interning implementation\n@SuppressWarnings(\"interning\")\npublic static /*@Pure*/\nboolean isInterned(/*@Nullable*/\nObject value) {\n    if (value == null) {\n        // nothing to do\n        return true;\n    } else if (value instanceof String) {\n        return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n        return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n        return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n        return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n        return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n        return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n        return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n        return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n        return (value == intern((Object[]) value));\n    } else {\n        // Nothing to do, because we don't intern other types.\n        // System.out.println(\"What type? \" + value.getClass().getName());\n        return true;\n    }\n}"
            ],
            [
                "numIntegers",
                "plume",
                "Intern",
                "// For testing only\npublic static int numIntegers() {\n    return internedIntegers.size();\n}"
            ],
            [
                "numLongs",
                "plume",
                "Intern",
                "public static int numLongs() {\n    return internedLongs.size();\n}"
            ],
            [
                "numIntArrays",
                "plume",
                "Intern",
                "public static int numIntArrays() {\n    return internedIntArrays.size();\n}"
            ],
            [
                "numLongArrays",
                "plume",
                "Intern",
                "public static int numLongArrays() {\n    return internedLongArrays.size();\n}"
            ],
            [
                "numDoubles",
                "plume",
                "Intern",
                "public static int numDoubles() {\n    return internedDoubles.size();\n}"
            ],
            [
                "numDoubleArrays",
                "plume",
                "Intern",
                "public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n}"
            ],
            [
                "numStringArrays",
                "plume",
                "Intern",
                "public static int numStringArrays() {\n    return internedStringArrays.size();\n}"
            ],
            [
                "numObjectArrays",
                "plume",
                "Intern",
                "public static int numObjectArrays() {\n    return internedObjectArrays.size();\n}"
            ],
            [
                "integers",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nInteger> integers() {\n    return internedIntegers.keySet().iterator();\n}"
            ],
            [
                "longs",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nLong> longs() {\n    return internedLongs.keySet().iterator();\n}"
            ],
            [
                "intArrays",
                "plume",
                "Intern",
                "public static Iterator<int[]> intArrays() {\n    return internedIntArrays.keySet().iterator();\n}"
            ],
            [
                "longArrays",
                "plume",
                "Intern",
                "public static Iterator<long[]> longArrays() {\n    return internedLongArrays.keySet().iterator();\n}"
            ],
            [
                "doubles",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nDouble> doubles() {\n    return internedDoubles.keySet().iterator();\n}"
            ],
            [
                "doubleArrays",
                "plume",
                "Intern",
                "public static Iterator<double[]> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n}"
            ],
            [
                "stringArrays",
                "plume",
                "Intern",
                "public static Iterator<String[]> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n}"
            ],
            [
                "objectArrays",
                "plume",
                "Intern",
                "public static Iterator<Object[]> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a String.\n * Delegates to the builtin String.intern() method.\n * Provided for completeness.\n * @param a the string to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static /*@Interned*/\n/*@PolyNull*/\nString intern(/*@PolyNull*/\nString a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n        return null;\n    }\n    return a.intern();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a long.\n * A no-op.  Provided for completeness.\n * @param l the long to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static long intern(long l) {\n    return l;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a double\n * A no-op.  Provided for completeness.\n * @param d the double to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static double intern(double d) {\n    return d;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Integer.\n * Return a canonical representation for the Integer.\n * @param a an Integer to canonicalize\n * @return a canonical representation for the Integer\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Intern.valueOf is intended to promise\n// the same).  This does not currently take advantage of that.\n// interning implementation\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nInteger intern(Integer a) {\n    WeakReference<Integer> /*@Interned*/\n    lookup = internedIntegers.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Integer /*@Interned*/\n        result = (/*@Interned*/\n        Integer) a;\n        internedIntegers.put(result, new WeakReference</*@Interned*/\n        Integer>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nInteger internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value parsed from the string.\n * @param s the string to parse\n * @return an interned Integer parsed from s\n */\npublic static /*@Interned*/\nInteger internedInteger(String s) {\n    return intern(Integer.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Long.\n * Return a canonical representation for the Long.\n * @param a the value to intern\n * @return a canonical representation for the Long\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Long.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nLong intern(Long a) {\n    WeakReference<Long> /*@Interned*/\n    lookup = internedLongs.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Long /*@Interned*/\n        result = (/*@Interned*/\n        Long) a;\n        internedLongs.put(result, new WeakReference</*@Interned*/\n        Long>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nLong internedLong(long i) {\n    return intern(Long.valueOf(i));\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value parsed from the string.\n * @param s the string to parse\n * @return an interned Long parsed from s\n */\npublic static /*@Interned*/\nLong internedLong(String s) {\n    return intern(Long.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) an int[].\n * Return a canonical representation for the int[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the int[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static int[] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        int[] /*@Interned*/\n        result = (int[]) a;\n        internedIntArrays.put(result, new WeakReference<int[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a long[].\n * Return a canonical representation for the long[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the long[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static long[] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        long[] /*@Interned*/\n        result = (long[]) a;\n        internedLongArrays.put(result, new WeakReference<long[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Double.\n * Return a canonical representation for the Double.\n * @param a the Double to canonicalize\n * @return a canonical representation for the Double\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Double.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nDouble intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n        return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) {\n        // catches both positive and negative zero\n        return internedDoubleZero;\n    }\n    WeakReference<Double> /*@Interned*/\n    lookup = internedDoubles.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Double /*@Interned*/\n        result = (/*@Interned*/\n        Double) a;\n        internedDoubles.put(result, new WeakReference</*@Interned*/\n        Double>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value i.\n * @param d the value to intern\n * @return an interned Double with value d\n */\npublic static /*@Interned*/\nDouble internedDouble(double d) {\n    return intern(Double.valueOf(d));\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value parsed from the string.\n * @param s the string to parse\n * @return an interned Double parsed from s\n */\npublic static /*@Interned*/\nDouble internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) a double[].\n * Return a canonical representation for the double[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the double[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static double[] intern(double[] a) {\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        double[] /*@Interned*/\n        result = (double[]) a;\n        internedDoubleArrays.put(result, new WeakReference<double[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an String[].\n * Return a canonical representation for the String[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the String[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static String[] intern(/*@PolyNull*/\n/*@Interned*/\nString[] a) {\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n        assert a[k] == Intern.intern(a[k]);\n    }\n    WeakReference<String[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    String[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (String[]) a;\n        internedStringArrays.put(result, new WeakReference<String[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    String[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Object[].\n * Return a canonical representation for the Object[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the Object[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static Object[] intern(/*@PolyNull*/\n/*@Interned*/\nObject[] a) {\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    WeakReference<Object[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    Object[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (Object[]) a;\n        internedObjectArrays.put(result, new WeakReference<Object[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    Object[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Convenince method to intern an Object when we don't know its\n * runtime type.  Its runtime type must be one of the types for\n * which we have an intern() method, else an exception is thrown.\n * If the argument is an array, its elements should themselves be\n * interned.\n * @param a an Object to canonicalize\n * @return a canonical version of a\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Interned*/\n/*@PolyNull*/\nObject intern(/*@PolyNull*/\nObject a) {\n    if (a == null) {\n        return null;\n    } else if (a instanceof String) {\n        return intern((String) a);\n    } else if (a instanceof String[]) {\n        @SuppressWarnings(\"interning\")\n        String[] /*@Interned*/\n        asArray = (String[]) a;\n        return intern(asArray);\n    } else if (a instanceof Integer) {\n        return intern((Integer) a);\n    } else if (a instanceof Long) {\n        return intern((Long) a);\n    } else if (a instanceof int[]) {\n        return intern((int[]) a);\n    } else if (a instanceof long[]) {\n        return intern((long[]) a);\n    } else if (a instanceof Double) {\n        return intern((Double) a);\n    } else if (a instanceof double[]) {\n        return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n        @SuppressWarnings(\"interning\")\n        Object[] /*@Interned*/\n        asArray = (Object[]) a;\n        return intern(asArray);\n    } else {\n        throw new IllegalArgumentException(\"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * Return the subsequence of seq from start (inclusive) to end\n * (exclusive) that is interned.  What's different about this method\n * from manually finding the subsequence and interning the\n * subsequence is that if the subsequence is already interned, we\n * can avoid having to compute the sequence.  Since derived\n * variables in Daikon compute the subsequence many times, this\n * shortcut saves quite a bit of computation.  It saves even more\n * when there may be many derived variables that are non-canonical,\n * since they are guaranteed to be ==.\n * <p>\n * Requires that seq is already interned.\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n */\npublic static int[] internSubsequence(int[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int[]> /*@Interned*/\n    sai = new SequenceAndIndices<int[]>(seq, start, end);\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n        int[] /*@Interned*/\n        subseq = Intern.intern(subseqUninterned);\n        internedIntSequenceAndIndices.put(sai, new WeakReference<int[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static long[] internSubsequence(long[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long[]> /*@Interned*/\n    sai = new SequenceAndIndices<long[]>(seq, start, end);\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        long[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedLongSequenceAndIndices.put(sai, new WeakReference<long[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static double[] internSubsequence(double[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double[]> /*@Interned*/\n    sai = new SequenceAndIndices<double[]>(seq, start, end);\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        double[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedDoubleSequenceAndIndices.put(sai, new WeakReference<double[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static Object[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nObject[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<Object[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedObjectSequenceAndIndices.put(sai, new WeakReference<Object[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static String[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nString[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<String[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedStringSequenceAndIndices.put(sai, new WeakReference<String[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "dominators",
                "plume",
                "GraphMDE",
                "// Algorithms for computing dominators:\n//\n// Wikipedia:\n//  // dominator of the start node is the start itself\n//  Dom(n_0) = {n_0}\n//  // for all other nodes, set all nodes as the dominators\n//  for each n in N - {n_0}\n//      Dom(n) = N;\n//  // iteratively eliminate nodes that are not dominators\n//  while changes in any Dom(n)\n//      for each n in N - {n_0}:\n//          Dom(n) = {n} union with intersection over all p in pred(n) of Dom(p)\n//\n// Cooper/Harvey/Kennedy:\n//  for all nodes, n\n//    DOM[n] := {1 . . .N}\n//  Changed := true\n//  while (Changed)\n//    Changed := false\n//    for all nodes, n, in reverse postorder\n//      new_set := (Intersect_{p:=preds(n)} DOM[p]) union {n}\n//      if (new_set != DOM[n])\n//        DOM[n] := new_set\n//        Changed := true\n// The two algorithms are essentially the same; this implementation\n// follows the Wikipedia one.\n/**\n * Computes, for each node in the graph, its set of (pre-)dominators.\n * Supply a successor graph if you want post-dominators.\n * @param <T> type of the graph nodes\n * @param predecessors a graph, represented as a predecessor map\n * @return a map from each node to a list of its pre-dominators\n */\npublic static <T> Map<T, List<T>> dominators(Map<T, List</*@KeyFor(\"#1\")*/\nT>> predecessors) {\n    // Map</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>> dom = new HashMap</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>>();\n    Map<T, List<T>> dom = new HashMap<T, List<T>>();\n    // every element of pred's value will be a key for dom\n    @SuppressWarnings(\"keyfor\")\n    Map<T, List<T>> /*@KeyFor({\"dom\"})*/\n    preds = predecessors;\n    List<T> nodes = new ArrayList<T>(preds.keySet());\n    // Compute roots & non-roots, for convenience\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    roots = new ArrayList<T>();\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    non_roots = new ArrayList<T>();\n    // Initialize result:  for roots just the root, otherwise everything\n    for (T node : preds.keySet()) {\n        if (preds.get(node).isEmpty()) {\n            // This is a root.  Its only dominator is itself.\n            Set<T> set = Collections.singleton(node);\n            dom.put(node, new ArrayList<T>(set));\n            roots.add(node);\n        } else {\n            // Initially, set all nodes as dominators;\n            // will later remove nodes that aren't dominators.\n            dom.put(node, new ArrayList<T>(nodes));\n            non_roots.add(node);\n        }\n    }\n    assert roots.size() + non_roots.size() == nodes.size();\n    // Invariants:\n    // preds and dom have the same keyset.\n    // All of the following are keys for both preds and dom:\n    //  * every key in pred\n    //  * elery element of every pred value\n    //  * every key in dom\n    //  * elery element of every dom value\n    // So, the type of pred is now\n    //\n    // rather than its original type\n    //   Map<T,List</*@KeyFor(\"preds\")*/ T>> preds\n    boolean changed = true;\n    while (changed) {\n        changed = false;\n        for (T node : non_roots) {\n            List<T> new_doms = null;\n            assert preds.containsKey(node);\n            for (T pred : preds.get(node)) {\n                assert dom.containsKey(pred);\n                /*@NonNull*/\n                List<T> dom_of_pred = dom.get(pred);\n                if (new_doms == null) {\n                    // make copy because we may side-effect new_doms\n                    new_doms = new ArrayList<T>(dom_of_pred);\n                } else {\n                    new_doms.retainAll(dom_of_pred);\n                }\n            }\n            assert new_doms != null : \"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\";\n            new_doms.add(node);\n            assert dom.containsKey(node);\n            if (!dom.get(node).equals(new_doms)) {\n                dom.put(node, new_doms);\n                changed = true;\n            }\n        }\n    }\n    for (T node : preds.keySet()) {\n        // TODO: The following two assert statements would be easier to read\n        // than the one combined one, but a bug (TODO:  Jonathan will add a\n        // bug number) prevents it from type-checking.\n        // assert dom.containsKey(node);\n        // assert dom.get(node).contains(node);\n        assert dom.containsKey(node) && dom.get(node).contains(node);\n    }\n    return dom;\n}"
            ],
            [
                "canonicalizeTimezone",
                "plume",
                "ICalAvailable",
                "static String canonicalizeTimezone(String timezone) {\n    String result = canonicalTimezones.get(timezone.toLowerCase());\n    return (result == null) ? timezone : result;\n}"
            ],
            [
                "printedTimezone",
                "plume",
                "ICalAvailable",
                "/*@Pure*/\nstatic String printedTimezone(TimeZone tz) {\n    String tzString = tz.getDisplayName();\n    String result = printedTimezones.get(tzString);\n    return (result == null) ? tzString : result;\n}"
            ],
            [
                "parseTime",
                "plume",
                "ICalAvailable",
                "// Parse a time like \"9:30pm\"\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nDateTime parseTime(String time) {\n    Matcher m = timeRegexp.matcher(time);\n    if (!m.matches()) {\n        System.err.println(\"Bad time: \" + time);\n        System.exit(1);\n    }\n    @SuppressWarnings(// Regex Checker imprecision:  matches() guarantees that group 1 exists in regexp\n    \"nullness\")\n    String /*@NonNull*/\n    hourString = m.group(1);\n    String minuteString = m.group(3);\n    String ampmString = m.group(4);\n    int hour = Integer.parseInt(hourString);\n    if ((ampmString != null) && ampmString.toLowerCase().equals(\"pm\")) {\n        hour += 12;\n    }\n    int minute = 0;\n    if (minuteString != null) {\n        minute = Integer.parseInt(minuteString);\n    }\n    DateTime result = new DateTime();\n    result.setTimeZone(tz1);\n    result.setHours(hour);\n    result.setMinutes(minute);\n    result.setSeconds(0);\n    return result;\n}"
            ],
            [
                "rangeString",
                "plume",
                "ICalAvailable",
                "static String rangeString(Period p, TimeZone tz) {\n    tf.setTimeZone(tz);\n    DateTime pstart = p.getStart();\n    DateTime pend = p.getEnd();\n    String rangeString = tf.format(pstart) + \" to \" + tf.format(pend);\n    rangeString = rangeString.replace(\" AM\", \"am\");\n    rangeString = rangeString.replace(\" PM\", \"pm\");\n    return rangeString;\n}"
            ],
            [
                "periodListString",
                "plume",
                "ICalAvailable",
                "static String periodListString(PeriodList pl, TimeZone tz) {\n    tf.setTimeZone(tz);\n    StringBuilder result = new StringBuilder();\n    // \"Object\" because PeriodList extends TreeSet, but it really ought to\n    // extend TreeSet</*@NonNull*/ Period>\n    for (Object p : pl) {\n        assert p != null : \"@AssumeAssertion(nullness): non-generic container class; elements are non-null\";\n        result.append(rangeString((Period) p, tz) + \"\\n\");\n    }\n    return result.toString();\n}"
            ],
            [
                "mergeDateAndTime",
                "plume",
                "ICalAvailable",
                "/**\n * Creates a new DateTime with date taken from the first argument and\n * time taken from the second argument.\n * @return the merged DateTime\n */\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic DateTime mergeDateAndTime(DateTime date, DateTime time) {\n    if (!date.getTimeZone().equals(time.getTimeZone())) {\n        throw new Error(String.format(\"non-matching timezones: %s %s\", date.getTimeZone(), time.getTimeZone()));\n    }\n    DateTime result = new DateTime(date);\n    result.setHours(time.getHours());\n    result.setMinutes(time.getMinutes());\n    result.setSeconds(time.getSeconds());\n    return result;\n}"
            ],
            [
                "oneDayAvailable",
                "plume",
                "ICalAvailable",
                "// TODO:  don't propose times that are before the current moment.\n// Process day-by-day because otherwise weekends and evenings are included.\n// for iCal4j\n@SuppressWarnings(\"unchecked\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nList<Period> oneDayAvailable(DateTime day, List<Calendar> calendars) {\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...)%n\", day);\n    }\n    List<Period> result = new ArrayList<Period>();\n    // for iCal4j\n    @SuppressWarnings(\"deprecation\")\n    int dayOfWeek = day.getDay();\n    if (!businessDays.contains(dayOfWeek)) {\n        return result;\n    }\n    for (Period bh : businessHours) {\n        DateTime start = mergeDateAndTime(day, bh.getStart());\n        DateTime end = mergeDateAndTime(day, bh.getEnd());\n        VFreeBusy request = new VFreeBusy(start, end, new Dur(0, 0, 0, 1));\n        if (debug) {\n            System.out.println(\"Request = \" + request);\n        }\n        ComponentList busyTimes = new ComponentList();\n        // Problem:  any all-day events will be treated as UTC.\n        // Instead, they should be converted to local time (tz1).\n        // But VFreeBusy does not support this, so I may need to convert\n        // daily events into a different format before inserting them.\n        for (Calendar calendar : calendars) {\n            // getComponents() returns a raw ArrayList.  Expose its element type.\n            ArrayList<Component> /*@NonNull*/\n            clist = calendar.getComponents();\n            for (Component c : clist) {\n                if (c instanceof VEvent) {\n                    VEvent v = (VEvent) c;\n                    DtStart dts = v.getStartDate();\n                    Parameter dtsValue = dts.getParameter(\"VALUE\");\n                    boolean allDay = (dtsValue != null) && dtsValue.getValue().equals(\"DATE\");\n                    // TODO: convert to the proper timezone.\n                    // Tricky: must deal with the possibility of RRULE:FREQ=\n                }\n                busyTimes.add(c);\n            }\n        }\n        VFreeBusy response = new VFreeBusy(request, busyTimes);\n        if (debug) {\n            System.out.println(\"Response = \" + response);\n        }\n        FreeBusy freefb = (FreeBusy) response.getProperty(\"FREEBUSY\");\n        if (freefb == null) {\n            if (debug) {\n                System.out.println(\"FREEBUSY property is null\");\n            }\n            continue;\n        }\n        // interned fields from a library, but not annotated so\n        @SuppressWarnings(\"interning\")\n        boolean isFree = (freefb.getParameter(Parameter.FBTYPE) == FbType.FREE);\n        assert isFree;\n        PeriodList freePeriods = freefb.getPeriods();\n        if (debug) {\n            System.out.printf(\"Free periods: %n%s%n\", periodListString(freePeriods, tz1));\n        }\n        result.addAll(freePeriods);\n    }\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...) => %s elements%n\", day, result.size());\n    }\n    return result;\n}"
            ],
            [
                "parseDate",
                "plume",
                "ICalAvailable",
                "/**\n * Parses a date when formatted in several common formats.\n * @return a Date read from the given string\n * @see dateFormats\n */\nstatic java.util.Date parseDate(String strDate) throws ParseException {\n    if (Pattern.matches(\"^[0-9][0-9]?/[0-9][0-9]?$\", date)) {\n        // for iCal4j\n        @SuppressWarnings(\"deprecation\")\n        int year = new Date().getYear() + 1900;\n        strDate = strDate + \"/\" + year;\n    }\n    for (DateFormat this_df : dateFormats) {\n        this_df.setLenient(false);\n        try {\n            java.util.Date result = this_df.parse(strDate);\n            return result;\n        } catch (ParseException e) {\n            // Try the next format in the list.\n        }\n    }\n    throw new ParseException(\"bad date \" + strDate, 0);\n}"
            ],
            [
                "formatDate",
                "plume",
                "ICalAvailable",
                "static String formatDate(DateTime d, TimeZone tz) {\n    df.setTimeZone(tz);\n    String result = df.format(d);\n    // Don't remove trailing year; it's a good double-check.\n    // Remove trailing year, such as \", 1952\".\n    // result = result.substring(0, result.length() - 6);\n    // Prepend day of week.\n    result = dffull.format(d).substring(0, 3) + \" \" + result;\n    return result;\n}"
            ],
            [
                "get_method_declaration",
                "plume",
                "BCELUtil",
                "/**\n * Returns a string describing a method declaration. It contains the access\n * flags (public, private, static, etc), the return type, the method name, and\n * the types of each of its arguments.\n * @param m the method\n * @return a string describing the method declaration\n */\npublic static String get_method_declaration(Method m) {\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n        f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n}"
            ],
            [
                "get_access_flags",
                "plume",
                "BCELUtil",
                "/**\n * Return a string representation of the access flags of method m.\n * @param m the method whose access flags to retrieve\n * @return a string representation of the access flags of method m\n */\nstatic String get_access_flags(Method m) {\n    int flags = m.getAccessFlags();\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n        if ((flags & pow) != 0) {\n            if (buf.length() > 0) {\n                buf.append(\" \");\n            }\n            if (i < Const.ACCESS_NAMES_LENGTH) {\n                buf.append(Const.getAccessName(i));\n            } else {\n                buf.append(String.format(\"ACC_BIT %x\", pow));\n            }\n        }\n        pow <<= 1;\n    }\n    return (buf.toString());\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a) {\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "get_constant_str",
                "plume",
                "BCELUtil",
                "/**\n * Returns the constant string at the specified offset.\n * @param pool the constant pool\n * @param index the index in the constant pool\n * @return the constant string at the specified offset in the constant pool\n */\npublic static String get_constant_str(ConstantPool pool, int index) {\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n        return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n        ConstantClass cc = (ConstantClass) c;\n        return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n        throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param mg the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param m the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param mg the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param m the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param gen the class to test\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in the format of Class.getName();\n *   the class should not be an array\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(/*@ClassGetName*/\nString classname) {\n    return classname.startsWith(\"java.\") || classname.startsWith(\"com.\") || classname.startsWith(\"javax.\") || classname.startsWith(\"org.\") || classname.startsWith(\"sun.\") || classname.startsWith(\"sunw.\");\n}"
            ],
            [
                "in_jdk_internalform",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in internal form\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk_internalform(/*@InternalForm*/\nString classname) {\n    return classname.startsWith(\"java/\") || classname.startsWith(\"com/\") || classname.startsWith(\"javax/\") || classname.startsWith(\"org/\") || classname.startsWith(\"sun/\") || classname.startsWith(\"sunw/\");\n}"
            ],
            [
                "instruction_descr",
                "plume",
                "BCELUtil",
                "// TODO: write Javadoc\n@SuppressWarnings(\"rawtypes\")\npublic static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n        @SuppressWarnings(// BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n        \"nullness\")\n        InstructionHandle /*@NonNull*/\n        handle = (InstructionHandle) i.next();\n        out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n}"
            ],
            [
                "local_var_descr",
                "plume",
                "BCELUtil",
                "/**\n * Return a description of the local variables (one per line).\n * @param mg the method whose local variables to describe\n * @return a description of the local variables (one per line)\n */\npublic static String local_var_descr(MethodGen mg) {\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n        for (LocalVariableGen lvg : lvgs) {\n            out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n        }\n    }\n    return (out.toString());\n}"
            ],
            [
                "is_local_variable_type_table",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the specified attribute is a local variable type\n * table.\n * @param a the attribute\n * @param pool the constant pool\n * @return true iff the attribute is a local variable type table\n */\npublic static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @param pool the constant pool\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "is_main",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not this is a standard main method (static,\n * name is 'main', and one argument of string array).\n * @param mg the method to check\n * @return true iff the method is a main method\n */\npublic static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic() && mg.getName().equals(\"main\") && (arg_types.length == 1) && arg_types[0].equals(string_array));\n}"
            ],
            [
                "type_to_classgetname",
                "plume",
                "BCELUtil",
                "/**\n * Returns the Java class name, in the format of {@link Class#getName()},\n * that corresponds to type.\n * @param type the type\n * @return the Java classname that corresponds to type\n */\npublic static /*@ClassGetName*/\nString type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n}"
            ],
            [
                "type_to_class",
                "plume",
                "BCELUtil",
                "/**\n * Returns the class that corresponds to type.\n * @param type the type\n * @return the Java class that corresponds to type\n */\npublic static Class<?> type_to_class(Type type) {\n    String classname = type_to_classgetname(type);\n    try {\n        Class<?> c = UtilMDE.classForName(classname);\n        return c;\n    } catch (Exception e) {\n        throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n}"
            ],
            [
                "add_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type added to the end of types.\n * @param types the array to extend\n * @param new_type the element to add to the end of the types array\n * @return the array (or a new one), with new_type at the end\n */\npublic static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "insert_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type inserted at the beginning.\n * @param types the array to extend\n * @param new_type the element to add to the beginning of the types array\n * @return the array (or a new one), with new_type at the beginning\n */\npublic static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "classname_to_type",
                "plume",
                "BCELUtil",
                "/**\n * Return the type corresponding to a given class name.\n * @param classname the class to convert to a type\n * @return the type corresponding to the given class name\n */\npublic static Type classname_to_type(String classname) {\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n        classname = classname.substring(0, classname.length() - 2);\n        array_depth++;\n    }\n    classname = classname.intern();\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") {\n        // interned\n        t = Type.INT;\n    } else if (classname == \"boolean\") {\n        // interned\n        t = Type.BOOLEAN;\n    } else if (classname == \"byte\") {\n        // interned\n        t = Type.BYTE;\n    } else if (classname == \"char\") {\n        // interned\n        t = Type.CHAR;\n    } else if (classname == \"double\") {\n        // interned\n        t = Type.DOUBLE;\n    } else if (classname == \"float\") {\n        // interned\n        t = Type.FLOAT;\n    } else if (classname == \"long\") {\n        // interned\n        t = Type.LONG;\n    } else if (classname == \"short\") {\n        // interned\n        t = Type.SHORT;\n    } else {\n        // must be a non-primitive\n        t = new ObjectType(classname);\n    }\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n        t = new ArrayType(t, array_depth);\n    }\n    return t;\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Array\n///\n// For arrays, see ArraysMDE.java.\n///////////////////////////////////////////////////////////////////////////\n/// BitSet\n///\n/**\n * Returns true if the cardinality of the intersection of the two\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b) >= i);\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "/**\n * Returns true if the cardinality of the intersection of the three\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b intersect c) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        intersection.and(c);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the two BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @return size(a intersect b)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the three BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @return size(a intersect b intersect c)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n}"
            ],
            [
                "fileInputStream",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// BufferedFileReader\n///\n// Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n/**\n * Returns an InputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStream for file\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            in = new GZIPInputStream(new FileInputStream(file));\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        in = new FileInputStream(file);\n    }\n    return in;\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return an InputStream for filename\n * @throws IOException if there is trouble reading the file\n * @throws FileNotFoundException if the file is not found\n */\npublic static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName null, or the name of a Charset to use when reading the file\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibility-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a LineNumberReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return a LineNumberReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedWriter appends to the end\n * of the file instead of the beginning\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\n// Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\npublic static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n        file_writer = new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n        file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n}"
            ],
            [
                "bufferedFileOutputStream",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedOutputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedOutputStream appends to the end\n * of the file instead of the beginning\n * @return a BufferedOutputStream for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}"
            ],
            [
                "isSubtype",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Class\n///\n/**\n * Return true iff sub is a subtype of sup.\n * If sub == sup, then sub is considered a subtype of sub and this method\n * returns true.\n * @param sub class to test for being a subtype\n * @param sup class to test for being a supertype\n * @return true iff sub is a subtype of sup\n */\n/*@Pure*/\npublic static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n        return true;\n    }\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n        return true;\n    }\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n        if (ifc == sup || isSubtype(ifc, sup)) {\n            return true;\n        }\n    }\n    return false;\n}"
            ],
            [
                "classForName",
                "plume",
                "UtilMDE",
                "/**\n * Like {@link Class#forName(String)}, but also works when the string\n * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n * <p>\n * If the given name can't be found, this method changes the last '.'  to\n * a dollar sign ($) and tries again.  This accounts for inner classes\n * that are incorrectly passed in in fully-qualified format instead of\n * binary format.\n * <p>\n * Recall the rather odd specification for {@link Class#forName(String)}:\n * the argument is a binary name for non-arrays, but a field descriptor\n * for arrays.  This method uses the same rules, but additionally handles\n * primitive types and, for non-arrays, fully-qualified names.\n * @param className name of the class\n * @return the Class corresponding to className\n * @throws ClassNotFoundException if the class is not found\n */\n// The annotation encourages proper use, even though this can take a\n// fully-qualified name (only for a non-array).\npublic static Class<?> classForName(/*@ClassGetName*/\nString className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n        return result;\n    } else {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            int pos = className.lastIndexOf('.');\n            if (pos < 0) {\n                throw e;\n            }\n            // checked below & exception is handled\n            @SuppressWarnings(\"signature\")\n            String /*@ClassGetName*/\n            inner_name = className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n            try {\n                return Class.forName(inner_name);\n            } catch (ClassNotFoundException ee) {\n                throw e;\n            }\n        }\n    }\n}"
            ],
            [
                "binaryNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a binary name to a field descriptor.\n * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n * or \"int\" to \"I\".\n * @param classname name of the class, in binary class name format\n * @return name of the class, in field descriptor format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@FieldDescriptor*/\nString binaryNameToFieldDescriptor(/*@BinaryName*/\nString classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n        dims++;\n        sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n        result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n        result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n}"
            ],
            [
                "primitiveTypeNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n * a field descriptor (e.g., \"I\", \"D\", etc.).\n * @param primitive_name name of the type, in Java format\n * @return name of the type, in field descriptor format\n * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n */\npublic static /*@FieldDescriptor*/\nString primitiveTypeNameToFieldDescriptor(String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n        throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n}"
            ],
            [
                "binaryNameToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a BinaryName to the format of {@link Class#getName()}.\n * @param bn the binary name to convert\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString binaryNameToClassGetName(/*BinaryName*/\nString bn) {\n    if (bn.endsWith(\"[]\")) {\n        return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n        return bn;\n    }\n}"
            ],
            [
                "fieldDescriptorToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n * @param fd the class, in field descriptor format\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString fieldDescriptorToClassGetName(/*FieldDescriptor*/\nString fd) {\n    if (fd.startsWith(\"[\")) {\n        return fd.replace('/', '.');\n    } else {\n        return fieldDescriptorToBinaryName(fd);\n    }\n}"
            ],
            [
                "arglistToJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert a fully-qualified argument list from Java format to JVML format.\n * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n * @param arglist an argument list, in Java format\n * @return argument list, in JVML format\n */\npublic static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n        // substring\n        @SuppressWarnings(\"signature\")\n        String /*@BinaryName*/\n        arg = args_tokenizer.nextToken().trim();\n        result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n}"
            ],
            [
                "fieldDescriptorToBinaryName",
                "plume",
                "UtilMDE",
                "// does not convert \"V\" to \"void\".  Should it?\n/**\n * Convert a field descriptor to a binary name.\n * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n * or \"I\" to \"int\".\n * @param classname name of the type, in JVML format\n * @return name of the type, in Java format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@BinaryName*/\nString fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n        throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n        dims++;\n        classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n        result = classname.substring(1, classname.length() - 1);\n    } else {\n        result = primitiveClassesFromJvm.get(classname);\n        if (result == null) {\n            throw new Error(\"Malformed base class: \" + classname);\n        }\n    }\n    for (int i = 0; i < dims; i++) {\n        result += \"[]\";\n    }\n    return result.replace('/', '.');\n}"
            ],
            [
                "arglistFromJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert an argument list from JVML format to Java format.\n * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n * @param arglist an argument list, in JVML format\n * @return argument list, in Java format\n */\npublic static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n        if (pos > 1) {\n            result += \", \";\n        }\n        int nonarray_pos = pos;\n        while (arglist.charAt(nonarray_pos) == '[') {\n            nonarray_pos++;\n        }\n        char c = arglist.charAt(nonarray_pos);\n        if (c == 'L') {\n            int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n            result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n            pos = semi_pos + 1;\n        } else {\n            String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n            if (maybe == null) {\n                // return null;\n                throw new Error(\"Malformed arglist: \" + arglist);\n            }\n            result += maybe;\n            pos = nonarray_pos + 1;\n        }\n    }\n    return result + \")\";\n}"
            ],
            [
                "defineClassFromFile",
                "plume",
                "UtilMDE",
                "/**\n * Converts the bytes in a file into an instance of class Class, and\n * resolves (links) the class.\n * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n * file name rather than an array of bytes as an argument, and also resolves\n * (links) the class.\n * @see ClassLoader#defineClass(String,byte[],int,int)\n * @param className the name of the class to define, or null if not known\n * @param pathname the pathname of a .class file\n * @return a Java Object corresponding to the Class defined in the .class file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\n// Also throws UnsupportedClassVersionError and some other exceptions.\npublic static Class<?> defineClassFromFile(/*@BinaryName*/\nString className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n}"
            ],
            [
                "count_lines",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// File\n///\n/**\n * Count the number of lines in the specified file.\n * @param filename file whose size to count\n * @return number of lines in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n        while (reader.readLine() != null) {\n            count++;\n        }\n    }\n    return count;\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param filename the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param file the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n        int unix = 0;\n        int dos = 0;\n        int mac = 0;\n        while (true) {\n            String s = r.readLine();\n            if (s == null) {\n                break;\n            }\n            if (s.endsWith(\"\\r\\n\")) {\n                dos++;\n            } else if (s.endsWith(\"\\r\")) {\n                mac++;\n            } else if (s.endsWith(\"\\n\")) {\n                unix++;\n            } else {\n                // This can happen only if the last line is not terminated.\n            }\n        }\n        if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n            return \"\\r\\n\";\n        }\n        if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n            return \"\\r\";\n        }\n        if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n            return \"\\n\";\n        }\n        // The two non-preferred line endings are tied and have more votes than\n        // the preferred line ending.  Give up and return the line separator\n        // for the system on which Java is currently running.\n        return lineSep;\n    }\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @return true iff the files have the same contents\n */\n/*@Pure*/\npublic static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff the files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @param trimLines if true, call String.trim on each line before comparing\n * @return true iff the files have the same contents\n */\n// reads files, side effects local state\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2)) {\n        String line1 = reader1.readLine();\n        String line2 = reader2.readLine();\n        while (line1 != null && line2 != null) {\n            if (trimLines) {\n                line1 = line1.trim();\n                line2 = line2.trim();\n            }\n            if (!(line1.equals(line2))) {\n                return false;\n            }\n            line1 = reader1.readLine();\n            line2 = reader2.readLine();\n        }\n        if (line1 == null && line2 == null) {\n            return true;\n        }\n        return false;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}"
            ],
            [
                "canCreateAndWrite",
                "plume",
                "UtilMDE",
                "/**\n * Returns true\n *  if the file exists and is writable, or\n *  if the file can be created.\n * @param file the file to create and write\n * @return true iff the file can be created and written\n */\npublic static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n        return file.canWrite();\n    } else {\n        File directory = file.getParentFile();\n        if (directory == null) {\n            directory = new File(\".\");\n        }\n        // Does this test need \"directory.canRead()\" also?\n        return directory.canWrite();\n    }\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n}"
            ],
            [
                "createTempDir",
                "plume",
                "UtilMDE",
                "///\n/// Directories\n///\n/**\n * Creates an empty directory in the default temporary-file directory,\n * using the given prefix and suffix to generate its name. For example,\n * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n * someString is internally generated to ensure no temporary files of the\n * same name are generated.\n * @param prefix the prefix string to be used in generating the file's\n *  name; must be at least three characters long\n * @param suffix the suffix string to be used in generating the file's\n *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n *  An abstract pathname denoting a newly-created empty file\n * @return a File representing the newly-created temporary directory\n * @throws IllegalArgumentException If the prefix argument contains fewer\n *  than three characters\n * @throws IOException If a file could not be created\n * @throws SecurityException If a security manager exists and its\n *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n *  file to be created\n * @see java.io.File#createTempFile(String, String, File)\n */\npublic static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dirName and all its files.\n * @param dirName the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dir and all its files.\n * @param dir the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n        return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    return dir.delete();\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name file whose name to expand\n * @return file with expanded file\n */\npublic static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n        return new File(newname);\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name filename to expand\n * @return expanded filename\n */\npublic static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n        return (name.replace(\"~\", userHome));\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "java_source",
                "plume",
                "UtilMDE",
                "/**\n * Return a string version of the name that can be used in Java source.\n * On Windows, the file will return a backslash separated string.  Since\n * backslash is an escape character, it must be quoted itself inside\n * the string.\n * <p>\n * The current implementation presumes that backslashes don't appear\n * in filenames except as windows path separators.  That seems like a\n * reasonable assumption.\n *\n * @param name file to quote\n * @return a string version of the name that can be used in Java source\n */\npublic static String java_source(File name) {\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n}"
            ],
            [
                "readObject",
                "plume",
                "UtilMDE",
                "/**\n * Reads an Object from a File.\n * @param file the file from which to read\n * @return the object read from the file\n * @throws IOException if there is trouble reading the file\n * @throws ClassNotFoundException if the object's class cannot be found\n */\npublic static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            istream = new GZIPInputStream(istream);\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n}"
            ],
            [
                "readerContents",
                "plume",
                "UtilMDE",
                "/**\n * Reads the entire contents of the reader and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param r the Reader to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readerContents(Reader r) {\n    try {\n        StringBuilder contents = new StringBuilder();\n        int ch;\n        while ((ch = r.read()) != -1) {\n            contents.append((char) ch);\n        }\n        r.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n}"
            ],
            [
                "readFile",
                "plume",
                "UtilMDE",
                "// an alternate name would be \"fileContents\".\n/**\n * Reads the entire contents of the file and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param file the file to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readFile(File file) {\n    try {\n        BufferedReader reader = UtilMDE.bufferedFileReader(file);\n        StringBuilder contents = new StringBuilder();\n        String line = reader.readLine();\n        while (line != null) {\n            contents.append(line);\n            // Note that this converts line terminators!\n            contents.append(lineSep);\n            line = reader.readLine();\n        }\n        reader.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Hashing\n///\n// In hashing, there are two separate issues.  First, one must convert\n// the input datum into an integer.  Then, one must transform the\n// resulting integer in a pseudorandom way so as to result in a number\n// that is far separated from other values that may have been near it to\n// begin with.  Often these two steps are combined, particularly if\n// one wishes to avoid creating too large an integer (losing information\n// off the top bits).\n// http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n//  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n//    h += (h<<3); h ^= (h>>11); h += (h<<15);\n//    is good.\n//  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n//  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n// In this part of the file, perhaps I will eventually write good hash\n// functions.  For now, write cheesy ones that primarily deal with the\n// first issue, transforming a data structure into a single number.  This\n// is also known as fingerprinting.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Double#hashCode()}.\n * @param x value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a) {\n    double result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a, double[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/// Don't define hash with int args; use the long versions instead.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Long#hashCode()}.\n * But it doesn't map -1 and 0 to the same value.\n * @param l value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n        return (int) l;\n    }\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a, long[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a) {\n    return (a == null) ? 0 : a.hashCode();\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b, /*@Nullable*/\nString c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + hash(a[i]);\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @param random the Random instance to use to make selections\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n    while (itor.hasNext()) {\n        rs.accept(itor.next());\n    }\n    return rs.getValues();\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n}"
            ],
            [
                "incrementMap",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Map\n///\n// In Python, inlining this gave a 10x speed improvement.\n// Will the same be true for Java?\n/**\n * Increment the Integer which is indexed by key in the Map.\n * If the key isn't in the Map, it is added.\n * @param <T> type of keys in the map\n * @param m map to have one of its values incremented\n * @param key the key for the element whose value will be incremented\n * @param count how much to increment the value by\n * @return the old value, before it was incremented\n * @throws Error if the key is in the Map but maps to a non-Integer.\n */\npublic static <T> /*@Nullable*/\nInteger incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n        new_total = count;\n    } else {\n        new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n}"
            ],
            [
                "mapToString",
                "plume",
                "UtilMDE",
                "/**\n * Returns a multi-line string representation of a map.\n * @param <K> type of map keys\n * @param <V> type of map values\n * @param m map to be converted to a string\n * @return a multi-line string representation of m\n */\npublic static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @return a sorted version of m.keySet()\n */\npublic static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @param comparator the Comparator to use for sorting\n * @return a sorted version of m.keySet()\n */\npublic static <K, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m, Comparator<K> comparator) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a method signature, return the method.\n * Example calls are:\n * <pre>\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n * </pre>\n * @param method a method signature\n * @return the method corresponding to the given signature\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n        throw new Error(\"malformed method name should contain a period, open paren, and close paren: \" + method + \" <<\" + dotpos + \",\" + oparenpos + \",\" + cparenpos + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n        if (!Character.isWhitespace(method.charAt(i))) {\n            throw new Error(\"malformed method name should contain only whitespace following close paren\");\n        }\n    }\n    // throws exception if class does not exist\n    @SuppressWarnings(\"signature\")\n    String /*@BinaryNameForNonArray*/\n    classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n        String[] argnames;\n        if (all_argnames.equals(\"\")) {\n            argnames = new String[0];\n        } else {\n            argnames = split(all_argnames, ',');\n        }\n        /*@MonotonicNonNull*/\n        Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n        for (int i = 0; i < argnames.length; i++) {\n            String bnArgname = argnames[i].trim();\n            /*@ClassGetName*/\n            String cgnArgname = binaryNameToClassGetName(bnArgname);\n            argclasses_tmp[i] = classForName(cgnArgname);\n        }\n        @SuppressWarnings(\"cast\")\n        Class<?>[] argclasses_res = (Class<?>[]) argclasses_tmp;\n        argclasses = argclasses_res;\n        args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a class name and a method name in that class, return the method.\n * @param classname class in which to find the method\n * @param methodname the method name\n * @param params the parameters of the method\n * @return the method named classname.methodname with parameters params\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(/*@BinaryNameForNonArray*/\nString classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// ProcessBuilder\n///\n/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line\n * @return all the output of the command\n */\npublic static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line, as a list of\n * strings (the command, then its arguments)\n * @return all the output of the command\n */\npublic static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n        Process p = pb.start();\n        @SuppressWarnings(// input stream is non-null because we didn't redirect the input stream\n        \"nullness\")\n        String output = UtilMDE.streamString(p.getInputStream());\n        return output;\n    } catch (IOException e) {\n        return \"IOException: \" + e.getMessage();\n    }\n}"
            ],
            [
                "propertyIsTrue",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Properties\n///\n/**\n * Determines whether a property has value \"true\", \"yes\", or \"1\".\n * @see Properties#getProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @return true iff the property has value \"true\", \"yes\", or \"1\"\n */\n// does not depend on object identity\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n        return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n}"
            ],
            [
                "appendProperty",
                "plume",
                "UtilMDE",
                "/**\n * Set the property to its previous value concatenated to the given value.\n * Return the previous value.\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to concatenate to the previous value of the property\n * @return the previous value of the property\n * @see Properties#getProperty\n * @see Properties#setProperty\n */\npublic static /*@Nullable*/\nString appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n}"
            ],
            [
                "setDefaultMaybe",
                "plume",
                "UtilMDE",
                "/**\n * Set the property only if it was not previously set.\n * @see Properties#getProperty\n * @see Properties#setProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to set the property to, if it is not already set\n * @return the previous value of the property\n */\npublic static /*@Nullable*/\nString setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n        p.setProperty(key, value);\n    }\n    return currentValue;\n}"
            ],
            [
                "getPrivateField",
                "plume",
                "UtilMDE",
                "// TODO: set the field back to private after is is accessed.\n/**\n * Reads the given field, which may be private.\n * Leaves the field accessible.\n * Use with care!\n * @param o object in which to set the field\n * @param fieldName name of field to set\n * @return new value of field\n * @throws NoSuchFieldException if the field does not exist in the object\n */\npublic static /*@Nullable*/\nObject getPrivateField(Object o, String fieldName) throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) {\n        // Class is interned\n        // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n        try {\n            Field f = c.getDeclaredField(fieldName);\n            f.setAccessible(true);\n            return f.get(o);\n        } catch (IllegalAccessException e) {\n            System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n            throw new Error(\"This can't happen: \" + e);\n        } catch (NoSuchFieldException e) {\n            if (c.getSuperclass() == Object.class) {\n                // Class is interned\n                throw e;\n            }\n            // nothing to do; will now examine superclass\n        }\n        c = c.getSuperclass();\n        assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n}"
            ],
            [
                "getFromSet",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set\n///\n/**\n * Return the object in this set that is equal to key.\n * The Set abstraction doesn't provide this; it only provides \"contains\".\n * Returns null if the argument is null, or if it isn't in the set.\n * @param set a set in which to look up the value\n * @param key the value to look up in the set\n * @return the object in this set that is equal to key, or null\n */\npublic static /*@Nullable*/\nObject getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n        return null;\n    }\n    for (Object elt : set) {\n        if (key.equals(elt)) {\n            return elt;\n        }\n    }\n    return null;\n}"
            ],
            [
                "streamString",
                "plume",
                "UtilMDE",
                "/**\n * Return a String containing all the characters from the input stream.\n * @param is input stream to read\n * @return a String containing all the characters from the input stream\n */\npublic static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n}"
            ],
            [
                "replaceString",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// String\n///\n/**\n * Return a new string which is the text of target with all instances of\n * oldStr replaced by newStr.\n * @param target the string to do replacement in\n * @param oldStr the substring to replace\n * @param newStr the replacement\n * @return target with all instances of oldStr replaced by newStr\n */\npublic static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n        throw new IllegalArgumentException();\n    }\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n        result.append(target.substring(lastend, pos));\n        result.append(newStr);\n        lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter character.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, String delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter String.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, char delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n        throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "splitLines",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings, one for each line in the argument.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n * are supported.  Note that a string that ends with a line separator\n * will return an empty string as the last element of the array.\n * @see #split(String s, char delim)\n * @param s the string to split\n * @return an array of Strings, one for each line in the argument\n */\npublic static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the array elements, placing the\n * delimiter between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n        return \"\";\n    }\n    if (a.length == 1) {\n        return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n        sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(Object... a) {\n    return join(a, lineSep);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * delimiter between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n        return \"\";\n    }\n    if (v.size() == 1) {\n        return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n        sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(List<String> v) {\n    return join(v, lineSep);\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Escape \\, \", newline, and carriage-return characters in the\n * target as \\\\, \\\", \\n, and \\r; return a new string if any\n * modifications were necessary.  The intent is that by surrounding\n * the return value with double quote marks, the result will be a\n * Java string literal denoting the original string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        switch(c) {\n            case '\\\"':\n            case '\\\\':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append('\\\\');\n                post_esc = i;\n                break;\n            case // not lineSep\n            '\\n':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                // not lineSep\n                sb.append(\"\\\\n\");\n                post_esc = i + 1;\n                break;\n            case '\\r':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append(\"\\\\r\");\n                post_esc = i + 1;\n                break;\n            default:\n        }\n    }\n    if (sb.length() == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "// The overhead of this is too high to call in escapeNonJava(String), so\n// it is inlined there.\n/**\n * Like {@link #escapeNonJava(String)}, but for a single character.\n * @param ch character to quote\n * @return quoted version och ch\n */\npublic static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch(c) {\n        case '\\\"':\n            return \"\\\\\\\"\";\n        case '\\\\':\n            return \"\\\\\\\\\";\n        case // not lineSep\n        '\\n':\n            // not lineSep\n            return \"\\\\n\";\n        case '\\r':\n            return \"\\\\r\";\n        default:\n            return new String(new char[] { c });\n    }\n}"
            ],
            [
                "escapeNonASCII",
                "plume",
                "UtilMDE",
                "/**\n * Escape unprintable characters in the target, following the usual\n * Java backslash conventions, so that the result is sure to be\n * printable ASCII.  Returns a new string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n}"
            ],
            [
                "unescapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n * one-character equivalents.  All other backslashes are removed\n * (for instance, octal/hex escape sequences are not turned into\n * their respective characters). This is the inverse operation of\n * escapeNonJava(). Previously known as unquote().\n * @param orig string to quoto\n * @return quoted version of orig\n */\npublic static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n        if (this_esc == orig.length() - 1) {\n            sb.append(orig.substring(post_esc, this_esc + 1));\n            post_esc = this_esc + 1;\n            break;\n        }\n        switch(orig.charAt(this_esc + 1)) {\n            case 'n':\n                sb.append(orig.substring(post_esc, this_esc));\n                // not lineSep\n                sb.append('\\n');\n                post_esc = this_esc + 2;\n                break;\n            case 'r':\n                sb.append(orig.substring(post_esc, this_esc));\n                sb.append('\\r');\n                post_esc = this_esc + 2;\n                break;\n            case '\\\\':\n                // This is not in the default case because the search would find\n                // the quoted backslash.  Here we incluce the first backslash in\n                // the output, but not the first.\n                sb.append(orig.substring(post_esc, this_esc + 1));\n                post_esc = this_esc + 2;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                sb.append(orig.substring(post_esc, this_esc));\n                char octal_char = 0;\n                int ii = this_esc + 1;\n                while (ii < orig.length()) {\n                    char ch = orig.charAt(ii++);\n                    if ((ch < '0') || (ch > '8')) {\n                        break;\n                    }\n                    octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n                }\n                sb.append(octal_char);\n                post_esc = ii - 1;\n                break;\n            default:\n                // In the default case, retain the character following the backslash,\n                // but discard the backslash itself.  \"\\*\" is just a one-character string.\n                sb.append(orig.substring(post_esc, this_esc));\n                post_esc = this_esc + 1;\n                break;\n        }\n        this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "removeWhitespaceAround",
                "plume",
                "UtilMDE",
                "// Use the built-in String.trim()!\n// /** Return the string with all leading and trailing whitespace stripped. */\n// public static String trimWhitespace(String s) {\n//   int len = s.length();\n//   if (len == 0)\n//     return s;\n//   int first_non_ws = 0;\n//   int last_non_ws = len-1;\n//   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n//     first_non_ws++;\n//   if (first_non_ws == len)\n//     return \"\";\n//   while (Character.isWhitespace(s.charAt(last_non_ws)))\n//     last_non_ws--;\n//   if ((first_non_ws == 0) && (last_non_ws == len)) {\n//     return s;\n//   } else {\n//     return s.substring(first_non_ws, last_non_ws+1);\n//   }\n// }\n// // // Testing:\n// // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n// // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n// // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n/**\n * Remove all whitespace before or after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace abutting\n * @return version of arg, with whitespace abutting delimiter removed\n */\npublic static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n}"
            ],
            [
                "removeWhitespaceAfter",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace after\n * @return version of arg, with whitespace after delimiter removed\n */\npublic static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index + delim_len;\n        while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index++;\n        }\n        // if (non_ws_index == arg.length()) {\n        //   System.out.println(\"No nonspace character at end of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index + delim_len) {\n            arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n        }\n        delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n}"
            ],
            [
                "removeWhitespaceBefore",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace before instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace before\n * @return version of arg, with whitespace before delimiter removed\n */\npublic static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index - 1;\n        while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index--;\n        }\n        // if (non_ws_index == -1) {\n        //   System.out.println(\"No nonspace character at front of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index - 1) {\n            arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n        }\n        delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n}"
            ],
            [
                "nplural",
                "plume",
                "UtilMDE",
                "/**\n * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n * @param n count of nouns\n * @param noun word being counted\n * @return noun, if n==1; otherwise, pluralization of noun\n */\npublic static String nplural(int n, String noun) {\n    if (n == 1) {\n        return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\") || noun.endsWith(\"s\") || noun.endsWith(\"sh\") || noun.endsWith(\"x\")) {\n        return n + \" \" + noun + \"es\";\n    } else {\n        return n + \" \" + noun + \"s\";\n    }\n}"
            ],
            [
                "lpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the left if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String lpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString() + s;\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the right if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String rpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n * @param num int whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n * @param num double whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the character appears in the string.\n * @param s string to search in\n * @param ch character to search for\n * @return number of times the character appears in the string\n */\npublic static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the second string appears in the first.\n * @param s string to search in\n * @param sub string to search for\n * @return number of times the substring appears in the string\n */\npublic static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// StringTokenizer\n///\n/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n * <p>\n * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n * (probably due to backward-compatibility).\n * @param str a string to be parsed\n * @param delim the delimiters\n * @param returnDelims flag indicating whether to return the delimiters as tokens\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n * @param str a string to be parsed\n * @param delim the delimiters\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n * @param str a string to be parsed\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n}"
            ],
            [
                "backTrace",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Throwable\n///\n/**\n * Return a String representation of the backtrace of the given Throwable.\n * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n * @param t the Throwable to obtain a backtrace of\n * @return a String representation of the backtrace of the given Throwable\n */\npublic static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n}"
            ],
            [
                "sortList",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Collections\n///\n/**\n * Return the sorted version of the list.  Does not alter the list.\n * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n * @return a sorted version of the list\n * @param <T> type of elements of the list\n * @param l a list to sort\n * @param c a sorted version of the list\n */\npublic static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n}"
            ],
            [
                "removeDuplicates",
                "plume",
                "UtilMDE",
                "// This should perhaps be named withoutDuplicates to emphasize that\n// it does not side-effect its argument.\n/**\n * Return a copy of the list with duplicates removed.\n * Retains the original order.\n * @param <T> type of elements of the list\n * @param l a list to remove duplicates from\n * @return a copy of the list with duplicates removed\n */\npublic static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n}"
            ],
            [
                "deepEquals",
                "plume",
                "UtilMDE",
                "/**\n * Determines deep equality for the elements.\n * <ul>\n * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n * <li>If both are lists, uses deepEquals recursively on each element.\n * <li>For other types, just uses equals() and does not recursively call this method.\n * </ul>\n * @param o1 first value to compare\n * @param o2 second value to comare\n * @return true iff o1 and o2 are deeply equal\n */\n// side effect to static field deepEqualsUnderway\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean deepEquals(/*@Nullable*/\nObject o1, /*@Nullable*/\nObject o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    // creates local state\n    @SuppressWarnings(\"purity\")\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n        return true;\n    }\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n        List<?> l1 = (List<?>) o1;\n        List<?> l2 = (List<?>) o2;\n        if (l1.size() != l2.size()) {\n            return false;\n        }\n        try {\n            deepEqualsUnderway.add(mypair);\n            for (int i = 0; i < l1.size(); i++) {\n                Object e1 = l1.get(i);\n                Object e2 = l2.get(i);\n                if (!deepEquals(e1, e2)) {\n                    return false;\n                }\n            }\n        } finally {\n            deepEqualsUnderway.remove(mypair);\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}"
            ],
            [
                "makeVector",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Vector\n///\n/**\n * Returns a vector containing the elements of the enumeration.\n * @param <T> type of the enumeration and vector elements\n * @param e an enumeration to convert to a Vector\n * @return a vector containing the elements of the enumeration\n */\npublic static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n        result.addElement(e.nextElement());\n    }\n    return result;\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "// Rather than writing something like VectorToStringArray, use\n//   v.toArray(new String[0])\n/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of the specified objects starting at index\n * start over dims dimensions, for dims &gt; 0.\n * <p>\n * For example, create_combinations (1, 0, {a, b, c}) returns:\n * <pre>\n *    {a}, {b}, {c}\n * </pre>\n * And create_combinations (2, 0, {a, b, c}) returns:\n * <pre>\n *    {a, a}, {a, b}, {a, c}\n *    {b, b}, {b, c},\n *    {c, c}\n * </pre>\n * @param <T> type of the input list elements, and type of the innermost output list elements\n * @param dims number of dimensions:  that is, size of each innermost list\n * @param start initial index\n * @param objs list of elements to\n * @return list of lists of length dims, each of which combines elements from objs\n */\npublic static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n    if (dims < 1) {\n        throw new IllegalArgumentException();\n    }\n    List<List<T>> results = new ArrayList<List<T>>();\n    for (int i = start; i < objs.size(); i++) {\n        if (dims == 1) {\n            List<T> simple = new ArrayList<T>();\n            simple.add(objs.get(i));\n            results.add(simple);\n        } else {\n            List<List<T>> combos = create_combinations(dims - 1, i, objs);\n            for (List<T> lt : combos) {\n                List<T> simple = new ArrayList<T>();\n                simple.add(objs.get(i));\n                simple.addAll(lt);\n                results.add(simple);\n            }\n        }\n    }\n    return (results);\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of integers from start to cnt (inclusive) over\n * arity dimensions.\n * <p>\n * For example, create_combinations (1, 0, 2) returns:\n * <pre>\n *    {0}, {1}, {2}\n * </pre>\n * And create_combinations (2, 0, 2) returns:\n * <pre>\n *    {0, 0}, {0, 1}, {0, 2}\n *    {1, 1}  {1, 2},\n *    {2, 2}\n * </pre>\n * @param arity size of each innermost list\n * @param start initial value\n * @param cnt maximum element value\n * @return list of lists of length arity, each of which combines integers from start to cnt\n */\npublic static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n        results.add(new ArrayList<Integer>());\n        return (results);\n    }\n    for (int i = start; i <= cnt; i++) {\n        ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n        for (ArrayList<Integer> li : combos) {\n            ArrayList<Integer> simple = new ArrayList<Integer>();\n            simple.add(new Integer(i));\n            simple.addAll(li);\n            results.add(simple);\n        }\n    }\n    return (results);\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(/*@FullyQualifiedName*/\nString qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n}"
            ],
            [
                "fullyQualifiedNameToSimpleName",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n// TODO: does not follow the specification for inner classes (where the\n// type name should be empty), but I think this is more informative anyway.\n// string conversion\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetSimpleName*/\nString fullyQualifiedNameToSimpleName(/*@FullyQualifiedName*/\nString qualified_name) {\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n        return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified class.  For example if qualified name of the class\n * is java.lang.String, String will be returned.\n *\n * @deprecated use {@link Class#getSimpleName()} instead.\n *\n * @param cls a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n}"
            ],
            [
                "abbreviateNumber",
                "plume",
                "UtilMDE",
                "/**\n * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n * of precision in the result (counting both sides of the decimal point).\n * @param val a numeric value\n * @return an abbreviated string representation of the value\n */\npublic static String abbreviateNumber(long val) {\n    double dval = (double) val;\n    String mag = \"\";\n    if (val < 1000) {\n        // nothing to do\n    } else if (val < 1000000) {\n        dval = val / 1000.0;\n        mag = \"K\";\n    } else if (val < 1000000000) {\n        dval = val / 1000000.0;\n        mag = \"M\";\n    } else {\n        dval = val / 1000000000.0;\n        mag = \"G\";\n    }\n    String precision = \"0\";\n    if (dval < 10) {\n        precision = \"2\";\n    } else if (dval < 100) {\n        precision = \"1\";\n    }\n    // format string computed from precision and mag\n    @SuppressWarnings(\"formatter\")\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeIntSet",
                "/**\n * Merges a list of LimitedSizeIntSet objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param max_values the maximum size for the returned LimitedSizeIntSet\n * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n * @return a LimitedSizeIntSet that merges the elements of slist\n */\npublic static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist) {\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ],
            [
                "of",
                "plume",
                "Triple",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param <C> type of third argument\n * @param a first argument\n * @param b second argument\n * @param c third argument\n * @return a triple of the values (a, b, c)\n */\npublic static <A, B, C> Triple<A, B, C> of(A a, B b, C c) {\n    return new Triple<A, B, C>(a, b, c);\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// min, max\n///\n// Could also add linear-time orderStatistics if I liked.\n/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int min(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long min(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double min(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer min(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long min(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() < result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double min(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int max(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long max(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double max(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer max(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long max(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() > result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double max(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int[] min_max(int[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] { result_min, result_max };\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long[] min_max(long[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] { result_min, result_max };\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int element_range(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long element_range(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of integers.\n * @param a an array\n * @return the sum of an array of integers\n */\npublic static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of integers.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of integers\n */\npublic static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of doubles.\n * @param a an array\n * @return the sum of an array of doubles\n */\npublic static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of doubles.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of doubles\n */\npublic static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf\n///\n/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> type of the elements of the array\n * @param a an array\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt) {\n    if (elt == null) {\n        return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> the type of the elements\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n *    Identical to List.indexOf, but included for completeness.\n * @param a a list\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    return a.indexOf(elt);\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a.get(i))) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyNull*/\nObject[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.size(); i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf, for finding subarrays\n///\n// This is analogous to Common Lisp's \"search\" function.\n// This implementation is very inefficient; I could use tricky Boyer-Moore\n// search techniques if I liked, but it's not worth it to me yet.\n/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n// The signature on this method is unnecessarily strict because it\n// requires that the component types be identical.  The signature should\n// be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n// @PolyAll qualifier does not yet take an argument.\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// mismatch\n///\n// This is analogous to Common Lisp's \"mismatch\" function.\n// Put it off until later; for now, use the simpler subarray function,\n// which is a specialization of mismatch,\n///////////////////////////////////////////////////////////////////////////\n/// subarray extraction\n///\n// Note that the second argument is a length, not an end position.\n// That's to avoid confusion over whether it would be the last included\n// index or the first non-included index.\n/**\n * Return a subarray of the given array.\n * @return a subarray of the given array\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n */\n/*@SideEffectFree*/\npublic static Object[] subarray(/*@PolyAll*/\nObject[] a, int startindex, int length) {\n    /*@PolyAll*/\n    Object[] result = new /*@PolyAll*/\n    Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a sublist of the given list.\n * @param <T> type of the elements\n * @param a the original list\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a sublist of the given list\n */\n/*@SideEffectFree*/\npublic static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static String[] subarray(/*@PolyAll*/\nString[] a, int startindex, int length) {\n    /*@PolyAll*/\n    String[] result = new /*@PolyAll*/\n    String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// subarray testing\n///\n/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, /*@PolyNull*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.size()];\n            System.arraycopy(a, 0, result, 0, a.length);\n            // System.arraycopy(b, 0, result, a.length, b.size());\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.length] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.length];\n            // System.arraycopy(a, 0, result, 0, a.size());\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            System.arraycopy(b, 0, result, a.size(), b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.size()];\n            // System.arraycopy(a, 0, result, 0, a.length);\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            // System.arraycopy(b, 0, result, a.length, b.length);\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.size()] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "// Note: PolyAll is not quite right.  Need to review.\n/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first array to concatenate\n * @param b the second array to concatenate\n * @return an array that concatenates the arguments\n */\npublic static String[] concat(/*@PolyAll*/\nString[] a, /*@PolyAll*/\nString[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new String[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            /*@PolyAll*/\n            String[] result = new String[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static byte[] concat(byte[] a, byte[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new byte[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            byte[] result = new byte[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static boolean[] concat(boolean[] a, boolean[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new boolean[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            boolean[] result = new boolean[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static char[] concat(char[] a, char[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new char[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            char[] result = new char[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static double[] concat(double[] a, double[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new double[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            double[] result = new double[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static float[] concat(float[] a, float[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new float[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            float[] result = new float[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static int[] concat(int[] a, int[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new int[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            int[] result = new int[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static long[] concat(long[] a, long[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new long[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            long[] result = new long[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static short[] concat(short[] a, short[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new short[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            short[] result = new short[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Printing\n///\n// This should be extended to all types, when I get around to it.  The\n// methods are patterned after that of java.util.Vector (and use its\n// output format).\n/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@PolyAll*/\nObject[] a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, each element is quoted like a Java String.\n * @param a an array\n * @return a string representation of the array, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@PolyAll*/\nObject[] a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, if quoted is true, then each element is quoted like a Java String.\n * @param a an array\n * @param quoted whether to quote the array elements\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@PolyAll*/\nObject[] a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            if (quoted && a[i] instanceof String) {\n                String elt = (String) a[i];\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava(elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(a[i]);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @param quoted whether to quote the collection elements that are Java strings\n * @return a string representation of the list\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@Nullable*/\nCollection<?> a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n        Iterator<?> itor = a.iterator();\n        sb.append(itor.next());\n        while (itor.hasNext()) {\n            sb.append(\", \");\n            Object elt = itor.next();\n            if (quoted && elt instanceof String) {\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava((String) elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(elt);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(int[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(long[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(double[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(float[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(boolean[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls the appropriate\n * toString() method.  Only call this method if obj is a boolean, double,\n * int, long, or Object array.\n * @param obj an array\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n        return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n        return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n        return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n        return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n        return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n        return toString((List<?>) obj);\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "length",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls .length.\n * Only call this method if obj is a boolean, double, int, long, or Object array.\n * @param obj a list\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n        return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n        return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n        return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n        return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n        return ((List<?>) obj).size();\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Sortedness\n///\n/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Boolean n = Boolean.valueOf(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Byte n = new Byte(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Float n = new Float(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Short n = new Short(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Integer n = new Integer(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space. Equality checking\n * uses the .equals() method for java.lang.Double.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Double n = new Double(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Long n = new Long(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param <T> the type of the elements\n * @param a a list\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static </*@Pure*/\nT> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n        if (hs.contains(a.get(i))) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a.get(i));\n    }\n    return true;\n}"
            ],
            [
                "fn_is_permutation",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Arrays as partial functions of int->int\n///\n/**\n * Returns true if the array is a permutation of [0..a.length).\n * @param a an array, representing a function\n * @return true iff all elements of a are in [0..a.length) and a\n * contains no duplicates.\n */\n// side effect to local state (array)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int n = a[i];\n        if (n < 0 || n >= a.length || see[n]) {\n            return false;\n        }\n        see[n] = true;\n    }\n    return true;\n}"
            ],
            [
                "fn_is_total",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff the array does not contain -1.\n * @param a an array, representing a function\n * @return true iff no element of a maps to -1\n */\n/*@Pure*/\npublic static boolean fn_is_total(int[] a) {\n    // not found\n    return indexOf(a, -1) == -1;\n}"
            ],
            [
                "fn_identity",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array [0..lenth).\n * @param length the length of the result\n * @return fresh array that is the identity function of the given length\n */\npublic static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n        result[i] = i;\n    }\n    return result;\n}"
            ],
            [
                "fn_inverse_permutation",
                "plume",
                "ArraysMDE",
                "/**\n * Requires that fn_is_permutation(a) holds.\n * @param a the input permutation\n * @return fresh array which is the inverse of the given permutation\n * @see #fn_is_permutation(int[])\n */\npublic static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n}"
            ],
            [
                "fn_inverse",
                "plume",
                "ArraysMDE",
                "/**\n * Return the inverse of the given function, which is represented as an array.\n * @param a an array representing a function from [0..a.length) to [0..arange);\n *  each element of a is between 0 and arange inclusive\n * @param arange length of the argument's range and the result's domain\n * @return function from [0..arange) to [0..a.length) that is the inverse of a\n * @throws IllegalArgumentException if a value of a is outside of arange\n * @exception UnsupportedOperationException when the function is not invertible\n */\npublic static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n        int ai = a[i];\n        if (ai < -1 || ai >= arange) {\n            throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n        }\n        // ai is either -1 or a valid index\n        if (ai >= 0) {\n            if (result[ai] != -1) {\n                throw new UnsupportedOperationException(String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n            }\n            result[ai] = i;\n        }\n    }\n    return result;\n}"
            ],
            [
                "fn_compose",
                "plume",
                "ArraysMDE",
                "/**\n * Return the composition of the given two functions, all of which are\n * represented as arrays.\n * @param a function from [0..a.length) to [0..b.length)\n * @param b function from [0..b.length) to range R\n * @return function from [0..a.length) to range R that is the\n * composition of a and b\n */\npublic static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int inner = a[i];\n        if (inner == -1) {\n            result[i] = -1;\n        } else {\n            result[i] = b[inner];\n        }\n    }\n    return result;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set operations, such as subset, unions, and intersections\n///\n// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Long(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Long elt = new Long(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Double(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Double elt = new Double(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(bigger[i]);\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        if (!setBigger.contains(smaller[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// nullness\n///\n/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(/*@PolyAll*/\nObject[] a) {\n    if (a.length == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(/*@PolyAll*/\nObject[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (!(a[i] == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n        if (!(a.get(i) == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "int_array_iterator",
                "plume",
                "TestPlume",
                "///////////////////////////////////////////////////////////////////////////\n/// Utility functions\n///\npublic static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n        asList.add(nums[i]);\n    }\n    return asList.iterator();\n}"
            ],
            [
                "int_iterator_array",
                "plume",
                "TestPlume",
                "public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    return v;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n        v.add(e.nextElement());\n    }\n    return v;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeSet",
                "/**\n * Merges a list of LimitedSizeSet&lt;T&gt; objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param <T> (super)type of elements of the sets\n * @param max_values the maximum size for the returned LimitedSizeSet\n * @param slist a list of LimitedSizeSet, whose elements will be merged\n * @return a LimitedSizeSet that merges the elements of slist\n */\npublic static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist) {\n    LimitedSizeSet<T> result = new LimitedSizeSet<T>(max_values);\n    for (LimitedSizeSet<? extends T> s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "serialVersionUID",
                "plume",
                "FileIOException",
                "static final long serialVersionUID = 20050923L;"
            ],
            [
                "counter",
                "plume",
                "DeterministicObject",
                "/**\n * The number of objects created so far.\n */\nstatic int counter = 0;"
            ],
            [
                "home",
                "plume",
                "MultiVersionControl",
                "@Option(value = \"User home directory\", noDocDefault = true)\npublic static String home = System.getProperty(\"user.home\");"
            ],
            [
                "debug",
                "plume",
                "MultiVersionControl",
                "// It would be good to be able to set this per-checkout.\n// This variable is static because it is used in static methods.\n@Option(\"Print debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "idf",
                "plume",
                "MultiVersionControl",
                "static IsDirectoryFilter idf = new IsDirectoryFilter();"
            ],
            [
                "help",
                "plume",
                "Lookup",
                "/**\n * Show detailed help information and exit.\n */\n@OptionGroup(\"Getting help\")\n@Option(\"-h Show detailed help information\")\npublic static boolean help = false;"
            ],
            [
                "verbose",
                "plume",
                "Lookup",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "entry_file",
                "plume",
                "Lookup",
                "// This uses only the first file because the default search path might be\n// something like user:system and you might want only your version of the\n// system files.  It might be useful to also support (via another flag,\n// or by taking over this one, or by the syntax of the separator, or in\n// some other way) specifying multiple files on the command line.\n/**\n * Specify the colon-separated search list for the file that contains\n * information to be searched.  Only the first file found is used, though\n * it may itself contain include directives.\n */\n@OptionGroup(\"Where to search\")\n@Option(\"-f Specify the colon-separated search list of files of information; may only be supplied once\")\npublic static String entry_file = \"~/lookup/root\";"
            ],
            [
                "search_body",
                "plume",
                "Lookup",
                "/**\n * Search the body of long entries in addition to the entry's\n * description.  The bodies of short entries are always searched.\n */\n@Option(\"-b Search body of long entries for matches\")\npublic static boolean search_body = false;"
            ],
            [
                "regular_expressions",
                "plume",
                "Lookup",
                "/**\n * Specifies that keywords are regular expressions.  If false, keywords\n * are text matches.\n */\n@OptionGroup(\"What to search for\")\n@Option(\"-e Keywords are regular expressions\")\npublic static boolean regular_expressions = false;"
            ],
            [
                "case_sensitive",
                "plume",
                "Lookup",
                "/**\n * If true, keywords matching is case sensistive.  By default, both\n * regular expressions and text keywords are case-insensitive.\n */\n@Option(\"-c Keywords are case sensistive\")\npublic static boolean case_sensitive = false;"
            ],
            [
                "word_match",
                "plume",
                "Lookup",
                "/**\n * If true, match a text keyword only as a separate word, not as a\n * substring of a word.  This option is ignored if\n * regular_expressions is true.\n */\n@Option(\"-w Only match text keywords against complete words\")\npublic static boolean word_match = false;"
            ],
            [
                "print_all",
                "plume",
                "Lookup",
                "/**\n * By default, if multiple entries are matched, only a synopsis\n * of each entry is printed.  If 'print_all' is selected then\n * the body of each matching entry is printed.\n */\n@OptionGroup(\"How to print matches\")\n@Option(\"-a Print the entire entry for each match\")\npublic static boolean print_all = false;"
            ],
            [
                "item_num",
                "plume",
                "Lookup",
                "/**\n * Specifies which item to print when there are multiple matches.\n * The index is 1-based; that is, it starts counting at 1.\n */\n@Option(\"-i Choose a specific item when there are multiple matches; index is 1-based\")\npublic static Integer /*@Nullable*/\nitem_num;"
            ],
            [
                "show_location",
                "plume",
                "Lookup",
                "/**\n * If true, show the filename/line number of each matching entry\n * in the output.\n */\n@Option(\"-l Show the location of each matching entry\")\npublic static boolean show_location = false;"
            ],
            [
                "entry_start_re",
                "plume",
                "Lookup",
                "@OptionGroup(\"Customizing format of files to be searched\")\n@Option(\"Regex that denotes the start of a long entry\")\npublic static Pattern /*@Regex(1)*/\nentry_start_re = Pattern.compile(\"^>entry *()\");"
            ],
            [
                "entry_stop_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that denotes the end of a long entry\")\npublic static Pattern entry_stop_re = Pattern.compile(\"^<entry\");"
            ],
            [
                "description_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that finds an entry's description (for long entries)\")\npublic static Pattern /*@Nullable*/\ndescription_re = null;"
            ],
            [
                "comment_re",
                "plume",
                "Lookup",
                "// If \"\", gets set to null immediately after option processing.\n@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Nullable*/\n/*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "runtime",
                "plume",
                "FileCompiler",
                "/**\n * The Runtime of the JVM.\n */\npublic static Runtime runtime = java.lang.Runtime.getRuntime();"
            ],
            [
                "java_filename_pattern",
                "plume",
                "FileCompiler",
                "/**\n * Matches the names of Java source files.\n * Match group 1 is the complete filename.\n */\nstatic Pattern /*@Regex(1)*/\njava_filename_pattern;"
            ],
            [
                "responsible",
                "plume",
                "TaskManager",
                "// Command line options\n@Option(\"-r Include only those tasks assigned to the specified person\")\npublic static String /*@Nullable*/\nresponsible = null;"
            ],
            [
                "milestone",
                "plume",
                "TaskManager",
                "@Option(\"-m Include only those tasks required for the specified milestone\")\npublic static String /*@Nullable*/\nmilestone = null;"
            ],
            [
                "completed",
                "plume",
                "TaskManager",
                "@Option(\"-c Include only completed tasks\")\npublic static boolean completed = false;"
            ],
            [
                "open",
                "plume",
                "TaskManager",
                "@Option(\"-o Include only open tasks\")\npublic static boolean open = false;"
            ],
            [
                "verbose",
                "plume",
                "TaskManager",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "format",
                "plume",
                "TaskManager",
                "@Option(\"-f Specify output format\")\npublic static OutputFormat format = OutputFormat.short_ascii;"
            ],
            [
                "comment_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "lineSep",
                "plume",
                "TaskManager",
                "// line.separator property is a legal regex\n@SuppressWarnings(\"regex\")\npublic static final String /*@Regex*/\nlineSep = System.getProperty(\"line.separator\");"
            ],
            [
                "minversion",
                "plume",
                "ClassFileVersion",
                "/**\n * Only report versions that are at least this large.\n */\nstatic double minversion = 0;"
            ],
            [
                "debug",
                "plume",
                "DeclarationAnnotations",
                "static boolean debug = false;"
            ],
            [
                "date",
                "plume",
                "ICalAvailable",
                "/// User options\n@Option(\"first date to summarize\")\npublic static String date = \"today\";"
            ],
            [
                "start_date",
                "plume",
                "ICalAvailable",
                "public static DateTime start_date = new DateTime();"
            ],
            [
                "days",
                "plume",
                "ICalAvailable",
                "@Option(\"number of calendar days to summarize\")\npublic static int days = 8;"
            ],
            [
                "iCal_URL",
                "plume",
                "ICalAvailable",
                "/**\n * For a Google calendar:  go to settings, then click on the green \"ICAL\"\n * icon for the \"private address\".\n */\n@Option(\"<url> schedule in iCal format\")\npublic static List<String> iCal_URL = new ArrayList<String>();"
            ],
            [
                "business_hours",
                "plume",
                "ICalAvailable",
                "/**\n * A list of time ranges, expressed as a String.\n * Example: 9am-5pm,7:30pm-9:30pm\n */\n@Option(\"time ranges during which appointments are permitted\")\npublic static String business_hours = \"9am-5pm\";"
            ],
            [
                "businessHours",
                "plume",
                "ICalAvailable",
                "// initialize to 9am-5pm\nstatic List<Period> businessHours = new ArrayList<Period>();"
            ],
            [
                "businessDays",
                "plume",
                "ICalAvailable",
                "// initialize to Mon-Fri\nstatic List<Integer> businessDays = new ArrayList<Integer>();"
            ],
            [
                "tzRegistry",
                "plume",
                "ICalAvailable",
                "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();"
            ],
            [
                "timezone1",
                "plume",
                "ICalAvailable",
                "/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * Available times are printed in this time zone.  It defaults to the\n * system time zone.\n */\n// don't need \"e.g.: America/New_York\" in message:  the default is an example\n@Option(value = \"<timezone> time zone, e.g.: America/New_York\", noDocDefault = true)\npublic static String timezone1 = TimeZone.getDefault().getID();"
            ],
            [
                "tz1",
                "plume",
                "ICalAvailable",
                "// Either of these initializations causes a NullPointerException\n// at net.fortuna.ical4j.model.TimeZone.<init>(TimeZone.java:67)\n// static TimeZone tz1 = new TimeZone(new VTimeZone());\n// static TimeZone tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));\nstatic TimeZone /*@MonotonicNonNull*/\ntz1;"
            ],
            [
                "timezone2",
                "plume",
                "ICalAvailable",
                "// If I'm outputting in a different timezone, then my notion of a \"day\"\n// may be different than the other timezone's notion of a \"day\".  This\n// doesn't seem important enough to fix right now.\n/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * If set, then free times are printed in two time zones.\n */\n@Option(\"<timezone> optional second time zone, e.g.: America/New_York\")\npublic static String /*@Nullable*/\ntimezone2;"
            ],
            [
                "tz2",
                "plume",
                "ICalAvailable",
                "static TimeZone /*@Nullable*/\ntz2;"
            ],
            [
                "debug",
                "plume",
                "ICalAvailable",
                "/// Other variables\n@Option(\"enable debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "calendars",
                "plume",
                "ICalAvailable",
                "/**\n * The appointments (the times that are unavailable for a meeting).\n */\nstatic List<Calendar> calendars = new ArrayList<Calendar>();"
            ],
            [
                "tf",
                "plume",
                "ICalAvailable",
                "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);"
            ],
            [
                "df",
                "plume",
                "ICalAvailable",
                "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);"
            ],
            [
                "dffull",
                "plume",
                "ICalAvailable",
                "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);"
            ],
            [
                "canonicalTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> canonicalTimezones = new HashMap<String, String>();"
            ],
            [
                "printedTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> printedTimezones = new HashMap<String, String>();"
            ],
            [
                "timeRegexp",
                "plume",
                "ICalAvailable",
                "static Pattern /*@Regex(4)*/\ntimeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");"
            ],
            [
                "dateFormats",
                "plume",
                "ICalAvailable",
                "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};"
            ],
            [
                "skip_checks",
                "plume",
                "BCELUtil",
                "/**\n * Controls whether the checks in checkMgen are actually performed.\n */\npublic static boolean skip_checks = false;"
            ],
            [
                "userHome",
                "plume",
                "UtilMDE",
                "static final String userHome = System.getProperty(\"user.home\");"
            ],
            [
                "args_seen",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Method\n///\n/**\n * Maps from a comma-delimited string of arg types, such as appears in a\n * method signature, to an array of Class objects, one for each arg\n * type. Example keys include: \"java.lang.String, java.lang.String,\n * java.lang.Class[]\" and \"int,int\".\n */\nstatic HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();"
            ],
            [
                "serialVersionUID",
                "plume",
                "UtilMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "NullableStringComparator",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeIntSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "split_lists",
                "plume",
                "Options",
                "/**\n * When true, an argument to a option of list type is split, on\n * whitespace, into multiple arguments each of which is added to the\n * list.  When false, each argument to an option of list type is treated\n * as a single element, no matter what characters it contains.\n */\n@Option(\"Treat arguments to lists as space-separated.\")\npublic static boolean split_lists = false;"
            ],
            [
                "serialVersionUID",
                "plume",
                "Options",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArgException",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "StringArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "short_run",
                "plume",
                "TestPlume",
                "// If true, do 100 instead of 100000 iterations when testing randomElements.\n// This saves only a little time.  However, it is significant when running\n// under instrumentation such as that of Chicory.\nstatic boolean short_run = false;"
            ],
            [
                "mass",
                "plume",
                "TestPlume",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestPlume",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestPlume",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "mass",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestOptionGroups1",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups2",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups3",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "FuzzyFloat",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "3",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "itor",
                "java.util.Iterator",
                "Iterator<Integer>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "hasNext",
                "java.util",
                "Iterator",
                "public abstract boolean hasNext()"
            ],
            [
                "equals",
                "",
                "int[]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "int[]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "int[]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "int[]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "int[]",
                "public T[] clone();"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "length",
                "",
                "int[]",
                "public final int length;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 10113,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "plume-lib-1.1.0",
        "packageName": "plume",
        "className": "MathMDE",
        "javadocTag": "@param nums the list of operands",
        "methodJavadoc": "    /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */",
        "methodSourceCode": "public static long[] nonmodulus_strict_long(Iterator<Long> nums){\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}",
        "classJavadoc": "/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */",
        "classSourceCode": "// ***** This file is automatically generated from MathMDE.java.jpp\n\npackage plume;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\n/*>>>\nimport org.checkerframework.checker.index.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.common.value.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Mathematical utilities.\n * @deprecated use <a href=\"http://plumelib.org/plume-util/api/org/plumelib/util/MathPlume.html\">org.plumelib.util.MathPlume</a>\n */\n@Deprecated // use org.plumelib.util.MathPlume\npublic final class MathMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///\n  /// Function versions of Java operators\n  ///\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static int negate(int a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static long negate(long a) {\n    return -a;\n  }\n\n  /** Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   */\n  public static double negate(double a) {\n    return -a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static int bitwiseComplement(int a) {\n    return ~a;\n  }\n\n  /** Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   */\n  public static long bitwiseComplement(long a) {\n    return ~a;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static int mul(int x, int y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static long mul(long x, long y) {\n    return x * y;\n  }\n\n  /** Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   */\n  public static double mul(double x, double y) {\n    return x * y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static int div(int x, int y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static long div(long x, long y) {\n    return x / y;\n  }\n\n  /** Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x / y\n   */\n  public static double div(double x, double y) {\n    return x / y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static int mod(int x, int y) {\n    return x % y;\n  }\n\n  /** Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   */\n  public static long mod(long x, long y) {\n    return x % y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static int lshift(int x, int y) {\n    return x << y;\n  }\n\n  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   */\n  public static long lshift(long x, long y) {\n    return x << y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   */\n  public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }\n\n  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   */\n  public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }\n\n  /** Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   */\n  public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   */\n  public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }\n\n  /** Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   */\n  public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   */\n  public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }\n\n  /** Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   */\n  public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  /** Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   */\n  public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }\n\n  ///\n  /// sign\n  ///\n\n  /** Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   */\n  public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  ///\n  /// exponentiation\n  ///\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The arguments are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  /**\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   */\n  public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }\n\n  private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }\n\n  private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }\n\n  ///\n  /// gcd\n  ///\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static int gcd(int a, int b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /// gcd -- version for manipulating long (rather than int) values\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static long gcd(long a, long b) {\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /** Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   */\n  public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    // Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }\n\n  /** Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   */\n  public static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   */\n  public static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  ///\n  /// Modulus\n  ///\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ int mod_positive(int x, /*@PolyUpperBound*/ int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; // arbitrary initial value\n    int last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    // arbitrary initial value\n    int last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }\n\n  /// modulus for long (as opposed to int) values\n\n  /**\n   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n   * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n   *\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be non-negative\n   */\n  @SuppressWarnings(\"index\") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n  public static /*@NonNegative*/ /*@LessThan(\"#2\")*/ /*@PolyUpperBound*/ long mod_positive(long x, /*@PolyUpperBound*/ long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }\n\n  /**\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; // arbitrary initial value\n    long last_nonstrict = 0; // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  /**\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    // arbitrary initial value\n    long last_nonstrict = 0;     // arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }\n\n  ///\n  /// Non-Modulus\n  ///\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int[] missing_numbers(int /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    // Exactly one of nums and nums_itor is non-null.\n    int /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorInt(int /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  private static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(int /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   int range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length/2, ArraysMDE.element_range(nums)/2);\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n  /// non-modulus for long (as opposed to int) values\n\n  /**\n   * Return an array containing all the numbers <b>not</b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n   * @return the set: [min(nums)..max(nums)] - nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long[] missing_numbers(long /*@MinLen(1)*/ [] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        resultList.add(val);\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n      resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n  }\n\n  /**\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   */\n  static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    // Exactly one of nums and nums_itor is non-null.\n    long /*@MonotonicNonNull*/ /*@MinLen(1)*/ [] nums;\n    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    // Used only if nums != null, in which case it is an index into nums.\n    /*@IndexFor(\"nums\")*/ int current_index;\n    boolean add_ends;\n\n    /**\n     * An iterator over all the numbers <b>not</b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     */\n    MissingNumbersIteratorLong(long /*@MinLen(1)*/ [] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { // avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      this.nums = nums;\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n    }\n\n    // The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      @SuppressWarnings(\"index\") // unused variable, so value doesn't matter\n      /*@IndexFor(\"nums\")*/ int unused = Integer.MIN_VALUE;\n      current_index = unused;\n    }\n\n    @Override\n    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      // This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          @SuppressWarnings(\"index\") // This breaks the invariant, but it's checked right below and the function exits.\n          /*@IndexFor(\"nums\")*/ int current_index_temp = current_index + 1;\n          current_index = current_index_temp;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          // prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    @Override\n    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = current_missing;\n      current_missing++;\n      return result;\n    }\n\n    @Override\n    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  private static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    // Must not use regular modulus:  that can produce errors, eg\n    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    // modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }\n\n  /** The first argument is an array containing two elements. */\n  private static boolean check_first_and_last_nonmodulus(long /*@ArrayLen(2)*/ [] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }\n\n  // Old, slightly less efficient implementation that uses the version of\n  // missing_numbers that returns an array instead of an Iterator.\n  // /**\n  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n  //  * m) but all missing numbers in their range are.\n  //  */\n  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n  //   // This implementation is particularly inefficient; find a better way to\n  //   // compute this.  Perhaps obtain the new modulus numbers incrementally\n  //   // instead of all at once.\n  //   if (nums.length == 0) {\n  //     return null;\n  //   }\n  //   long range = ArraysMDE.element_range(nums);\n  //   if (range > 65536) {\n  //     return null;\n  //   }\n  //   return modulus(missing_numbers(nums));\n  // }\n\n  /**\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n   * but for every number in NUMS, at least one is equal to every non-r remainder.\n   * The modulus is chosen as small as possible, but no greater than half the\n   * range of the input numbers (else null is returned).\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   */\n  // This seems to give too many false positives (or maybe my probability\n  // model was wrong); use nonmodulus_strict instead.\n  @SuppressWarnings(\"purity\")\n  public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length/2, ArraysMDE.element_range(nums)/2)));\n\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      // System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; // initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        /*@IndexFor(\"has_modulus\")*/ int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            // Quit as soon as we see every remainder instead of processing\n            // each element of the input list.\n            break;\n          }\n        }\n      }\n      // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }\n\n}\n\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "FileIOException",
                "plume"
            ],
            [
                "MathMDE",
                "plume"
            ],
            [
                "DeterministicObject",
                "plume"
            ],
            [
                "Digest",
                "plume"
            ],
            [
                "StringBuilderDelimited",
                "plume"
            ],
            [
                "OrderedPairIterator",
                "plume"
            ],
            [
                "CountingPrintWriter",
                "plume"
            ],
            [
                "MultiVersionControl",
                "plume"
            ],
            [
                "WeakIdentityHashMap",
                "plume"
            ],
            [
                "IterableIterator",
                "plume"
            ],
            [
                "Lookup",
                "plume"
            ],
            [
                "Pair",
                "plume"
            ],
            [
                "FileCompiler",
                "plume"
            ],
            [
                "MultiRandSelector",
                "plume"
            ],
            [
                "RandoopMappedCalls",
                "plume"
            ],
            [
                "Stopwatch",
                "plume"
            ],
            [
                "TaskManager",
                "plume"
            ],
            [
                "WeakHasherMap",
                "plume"
            ],
            [
                "ClassFileVersion",
                "plume"
            ],
            [
                "WeakIdentityPair",
                "plume"
            ],
            [
                "OptionsDoclet",
                "plume"
            ],
            [
                "DeclarationAnnotations",
                "plume"
            ],
            [
                "Option",
                "plume"
            ],
            [
                "RegexUtil",
                "plume"
            ],
            [
                "JWhich",
                "plume"
            ],
            [
                "TimeLimitProcess",
                "plume"
            ],
            [
                "Intern",
                "plume"
            ],
            [
                "GraphMDE",
                "plume"
            ],
            [
                "HtmlPrettyPrint",
                "plume"
            ],
            [
                "SimpleLog",
                "plume"
            ],
            [
                "OptionGroup",
                "plume"
            ],
            [
                "ICalAvailable",
                "plume"
            ],
            [
                "RandomSelector",
                "plume"
            ],
            [
                "BCELUtil",
                "plume"
            ],
            [
                "UtilMDE",
                "plume"
            ],
            [
                "Hasher",
                "plume"
            ],
            [
                "BibtexClean",
                "plume"
            ],
            [
                "LimitedSizeIntSet",
                "plume"
            ],
            [
                "Partitioner",
                "plume"
            ],
            [
                "Triple",
                "plume"
            ],
            [
                "Options",
                "plume"
            ],
            [
                "ArraysMDE",
                "plume"
            ],
            [
                "StrTok",
                "plume"
            ],
            [
                "Unpublicized",
                "plume"
            ],
            [
                "TestPlume",
                "plume"
            ],
            [
                "LimitedSizeSet",
                "plume"
            ],
            [
                "EntryReader",
                "plume"
            ],
            [
                "Filter",
                "plume"
            ],
            [
                "FuzzyFloat",
                "plume"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "negate",
                "plume",
                "MathMDE",
                "///\n/// Function versions of Java operators\n///\n/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static int negate(int a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static long negate(long a) {\n    return -a;\n}"
            ],
            [
                "negate",
                "plume",
                "MathMDE",
                "/**\n * Negates its argument.\n * @param a value to negate\n * @return negative of a\n */\npublic static double negate(double a) {\n    return -a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static int bitwiseComplement(int a) {\n    return ~a;\n}"
            ],
            [
                "bitwiseComplement",
                "plume",
                "MathMDE",
                "/**\n * Returns ~a, the bitwise complement of its argument.\n * @param a value to bitwise-complement\n * @return ~a, the bitwise complement of a\n */\npublic static long bitwiseComplement(long a) {\n    return ~a;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static int mul(int x, int y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static long mul(long x, long y) {\n    return x * y;\n}"
            ],
            [
                "mul",
                "plume",
                "MathMDE",
                "/**\n * Multiplies its arguments.\n * @param x first multiplicand\n * @param y second multiplicand\n * @return x * y\n */\npublic static double mul(double x, double y) {\n    return x * y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static int div(int x, int y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static long div(long x, long y) {\n    return x / y;\n}"
            ],
            [
                "div",
                "plume",
                "MathMDE",
                "/**\n * Divides its arguments.\n * @param x dividend\n * @param y divisor\n * @return x / y\n */\npublic static double div(double x, double y) {\n    return x / y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static int mod(int x, int y) {\n    return x % y;\n}"
            ],
            [
                "mod",
                "plume",
                "MathMDE",
                "/**\n * Returns x % y, the modulus operation applied to its arguments.\n * @param x valued to be modded\n * @param y modulus\n * @return x % y\n */\npublic static long mod(long x, long y) {\n    return x % y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static int lshift(int x, int y) {\n    return x << y;\n}"
            ],
            [
                "lshift",
                "plume",
                "MathMDE",
                "/**\n * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n * @param x valued to be left-shifted\n * @param y magnitude of the left-shift\n * @return x &lt;&lt; y\n */\npublic static long lshift(long x, long y) {\n    return x << y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static int rshiftSigned(int x, int y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftSigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt; y\n */\npublic static long rshiftSigned(long x, long y) {\n    return x >> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n}"
            ],
            [
                "rshiftUnsigned",
                "plume",
                "MathMDE",
                "/**\n * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n * @param x valued to be right-shifted\n * @param y magnitude of the right-shift\n * @return x &gt;&gt;&gt; y\n */\npublic static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static int bitwiseAnd(int x, int y) {\n    return x & y;\n}"
            ],
            [
                "bitwiseAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns x &amp; y, the bitwise and of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x &amp; y\n */\npublic static long bitwiseAnd(long x, long y) {\n    return x & y;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static int logicalAnd(int x, int y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalAnd",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical and of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical and of x and y; the result is always 0 or 1\n */\npublic static long logicalAnd(long x, long y) {\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static int bitwiseXor(int x, int y) {\n    return x ^ y;\n}"
            ],
            [
                "bitwiseXor",
                "plume",
                "MathMDE",
                "/**\n * Returns x ^ y, the bitwise xor of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x ^ y\n */\npublic static long bitwiseXor(long x, long y) {\n    return x ^ y;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static int logicalXor(int x, int y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalXor",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical xor of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical xor of x and y; the result is always 0 or 1\n */\npublic static long logicalXor(long x, long y) {\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static int bitwiseOr(int x, int y) {\n    return x | y;\n}"
            ],
            [
                "bitwiseOr",
                "plume",
                "MathMDE",
                "/**\n * Returns x | y, the bitwise or of its arguments.\n * @param x first operand\n * @param y second operand\n * @return x | y\n */\npublic static long bitwiseOr(long x, long y) {\n    return x | y;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static int logicalOr(int x, int y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "logicalOr",
                "plume",
                "MathMDE",
                "/**\n * Returns the logical or of its arguments.  The result is always 0 or 1.\n * @param x first operand\n * @param y second operand\n * @return the logical or of x and y; the result is always 0 or 1\n */\npublic static long logicalOr(long x, long y) {\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}"
            ],
            [
                "sign",
                "plume",
                "MathMDE",
                "///\n/// sign\n///\n/**\n * Returns the sign of its argument.  The result is always -1, 0, or 1.\n * @param a value to have its sign taken\n * @return the sign of a: -1, 0, or 1\n */\npublic static int sign(int a) {\n    if (a == 0) {\n        return 0;\n    } else if (a > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "///\n/// exponentiation\n///\n/**\n * Returns of value of the first argument raised to the\n * power of the second argument.  The arguments are integers.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "pow",
                "plume",
                "MathMDE",
                "/**\n * Returns of value of the first argument raised to the\n * power of the second argument.\n * @param base the base\n * @param expt the exponent\n * @return base to the expt power\n * @see Math#pow(double, double)\n */\npublic static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "///\n/// gcd\n///\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static int gcd(int a, int b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        int tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static int gcd(int[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of int array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static int gcd_differences(int[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/// gcd -- version for manipulating long (rather than int) values\n/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static long gcd(long a, long b) {\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static long gcd(long[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of long array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static long gcd_differences(long[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the two arguments.\n * @param a first operand\n * @param b second operand\n * @return greatest common divisor of a and b\n */\npublic static double gcd(double a, double b) {\n    if (a == Double.POSITIVE_INFINITY || a == Double.NEGATIVE_INFINITY || Double.isNaN(a) || b == Double.POSITIVE_INFINITY || b == Double.NEGATIVE_INFINITY || Double.isNaN(b)) {\n        return Double.NaN;\n    }\n    // Euclid's method\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        double tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}"
            ],
            [
                "gcd",
                "plume",
                "MathMDE",
                "/**\n * Return the greatest common divisor of the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the elements of a\n */\npublic static double gcd(double[] a) {\n    // Euclid's method\n    if (a.length == 0) {\n        return 0;\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "gcd_differences",
                "plume",
                "MathMDE",
                "/**\n * Return the gcd (greatest common divisor) of the differences\n * between the elements of double array a.\n * @param a array of operands\n * @return greatest common divisor of the differences between the elements of a\n */\npublic static double gcd_differences(double[] a) {\n    // Euclid's method\n    if (a.length < 2) {\n        return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "///\n/// Modulus\n///\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nint mod_positive(int x, /*@PolyUpperBound*/\nint y) {\n    int result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static int[] modulus(int[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new int[] { remainder, modulus };\n}"
            ],
            [
                "modulus_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(int[])\n */\npublic static int[] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static int[] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    int modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Integer values.\n * This can be more efficient than modulus(int[]) if the int[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(int[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    int first_nonstrict = 0;\n    // arbitrary initial value\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().intValue();\n    }\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().intValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}"
            ],
            [
                "mod_positive",
                "plume",
                "MathMDE",
                "/// modulus for long (as opposed to int) values\n/**\n * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}.\n * This should really be named {@code mod_nonnegative} rather than {@code mod_positive}.\n *\n * @param x value to be modded\n * @param y modulus\n * @return x % y, where the result is constrained to be non-negative\n */\n// result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative\n@SuppressWarnings(\"index\")\npublic static /*@NonNegative*/\n/*@LessThan(\"#2\")*/\n/*@PolyUpperBound*/\nlong mod_positive(long x, /*@PolyUpperBound*/\nlong y) {\n    long result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}"
            ],
            [
                "modulus",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * Also, return null if the array is less than 3 elements long.\n * @param nums array of operands\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n */\npublic static long[] modulus(long[] nums) {\n    if (nums.length < 3) {\n        return null;\n    }\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new long[] { remainder, modulus };\n}"
            ],
            [
                "modulus_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't already\n * exist, because this does not necessarily examine every value produced by\n * its iterator.\n * @param itor iterator of operands\n * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus(long[])\n */\npublic static long[] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        long i = itor.next().longValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}"
            ],
            [
                "modulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n * The largest possible modulus is used, and the trivial constraint that all\n * integers are equal to 0 mod 1 is not returned (null is returned instead).\n * <p>\n *\n * This \"_strict\" version requires its input to be sorted, and no element\n * may be missing.\n * <p>\n *\n * This \"_strict\" version differs from the regular modulus by requiring\n * that the argument be dense:  that is, every pair of numbers in the\n * argument array is separated by exactly the modulus.\n * <p>\n *\n * The endpoints can be treated in two different ways:  Either exactly\n * like other numbers in the input, or they can merely be checked for the\n * condition without the strict density requirement.\n *\n * @param nums array of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the array contains fewer than 3 elements\n */\npublic static long[] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    long modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "modulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * The iterator produces Long values.\n * This can be more efficient than modulus(long[]) if the long[] doesn't\n * already exist, because this does not necessarily examine every value\n * produced by its iterator.\n * <p>\n * For documentation, see {@link #modulus_strict(long[], boolean)}.\n * @param itor iterator of operands\n * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n *   or null if no such exists or the iterator contains fewer than 3 elements\n * @see #modulus_strict(int[], boolean)\n */\npublic static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n        return null;\n    }\n    // arbitrary initial value\n    long first_nonstrict = 0;\n    // arbitrary initial value\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().longValue();\n    }\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().longValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "///\n/// Non-Modulus\n///\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] missing_numbers(int[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length - 1];\n    int sizeEstimate = max - min + 1 - nums.length;\n    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    int val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    int[] resultArray = new int[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).intValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_strict(int[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_int",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static int[] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   int range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static int[] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2);\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = mod_positive(nums[i], m);\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new int[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "missing_numbers",
                "plume",
                "MathMDE",
                "/// non-modulus for long (as opposed to int) values\n/**\n * Return an array containing all the numbers <b>not</b> in its argument\n * array (which must be non-empty)\n * but in the argument's range; that is, bigger than its argument's\n * minimum value and smaller than its argument's maximum value.\n * The result contains no duplicates and is in order.\n * @param nums numbers to be excluded; length &gt; 0; may contain duplicates\n * @return the set: [min(nums)..max(nums)] - nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] missing_numbers(long[] nums) {\n    // avoid modifying parameter\n    nums = nums.clone();\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length - 1];\n    int sizeEstimate = ((int) (max - min + 1 - nums.length));\n    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);\n    long val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            resultList.add(val);\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    long[] resultArray = new long[resultList.size()];\n    for (int i = 0; i < resultArray.length; i++) {\n        resultArray[i] = resultList.get(i).longValue();\n    }\n    return resultArray;\n}"
            ],
            [
                "nonmodulus_strict",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.  Returns null if the\n * input array has 0 length.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_strict(long[] nums) {\n    // This implementation is particularly inefficient; find a better way to\n    // compute this.  Perhaps obtain the new modulus numbers incrementally\n    // instead of all at once.\n    if (nums.length == 0) {\n        return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_strict_long",
                "plume",
                "MathMDE",
                "/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n * m) but all missing numbers in their range are.\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\npublic static long[] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}"
            ],
            [
                "nonmodulus_nonstrict",
                "plume",
                "MathMDE",
                "// Old, slightly less efficient implementation that uses the version of\n// missing_numbers that returns an array instead of an Iterator.\n// /**\n//  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n//  * m) but all missing numbers in their range are.\n//  */\n// public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {\n//   // This implementation is particularly inefficient; find a better way to\n//   // compute this.  Perhaps obtain the new modulus numbers incrementally\n//   // instead of all at once.\n//   if (nums.length == 0) {\n//     return null;\n//   }\n//   long range = ArraysMDE.element_range(nums);\n//   if (range > 65536) {\n//     return null;\n//   }\n//   return modulus(missing_numbers(nums));\n// }\n/**\n * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m)\n * but for every number in NUMS, at least one is equal to every non-r remainder.\n * The modulus is chosen as small as possible, but no greater than half the\n * range of the input numbers (else null is returned).\n * @param nums the list of operands\n * @return a (remainder, modulus) pair that fails to match elements of nums\n */\n// This seems to give too many false positives (or maybe my probability\n// model was wrong); use nonmodulus_strict instead.\n@SuppressWarnings(\"purity\")\npublic static long[] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length / 2, ArraysMDE.element_range(nums) / 2)));\n    // System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n    // no real sense checking 2, as common_modulus would have found it, but\n    // include it to make this function stand on its own\n    for (int m = 2; m <= max_modulus; m++) {\n        // System.out.println(\"Trying m=\" + m);\n        // initialized to false?\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            /*@IndexFor(\"has_modulus\")*/\n            int rem = ((int) (mod_positive(nums[i], m)));\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                // System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n                if (num_nonmodulus == 0) {\n                    // Quit as soon as we see every remainder instead of processing\n                    // each element of the input list.\n                    break;\n                }\n            }\n        }\n        // System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n        if (num_nonmodulus == 1) {\n            return new long[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}"
            ],
            [
                "getFileDigest",
                "plume",
                "Digest",
                "/**\n * This convenience method is used by both create() and verify().  It\n * reads the contents of a named file and computes a message digest\n * for it, using the specified MessageDigest object.\n * @param filename the file to read\n * @param md the MessageDigest\n * @return the message digest\n * @throws IOException if there is a problem reading the file\n */\npublic static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    // Read to the end of the file, discarding everything we read. {\n    // The DigestInputStream automatically passes all the bytes read to\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) {\n        /* do nothing */\n    }\n    // Finally, compute and return the digest value.\n    byte[] result = md.digest();\n    in.close();\n    return result;\n}"
            ],
            [
                "hexEncode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert an array of bytes to a String.  We do\n * this simply by converting each byte to two hexadecimal digits.  Something\n * like Base 64 encoding is more compact, but harder to encode.\n * @param bytes the bytes to convert to a String\n * @return a String representation of the input bytes\n */\npublic static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}"
            ],
            [
                "hexDecode",
                "plume",
                "Digest",
                "/**\n * A convenience method to convert from a string\n * of hexadecimal digits to an array of bytes.\n * This method is the reverse of {@link #hexEncode(byte[])}.\n * @param s the String to convert to an array of bytes\n * @return the bytes equivalent to the input String\n */\npublic static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9')) {\n                digit1 -= '0';\n            } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n                digit1 -= 'a' - 10;\n            }\n            if ((digit2 >= '0') && (digit2 <= '9')) {\n                digit2 -= '0';\n            } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n                digit2 -= 'a' - 10;\n            }\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}"
            ],
            [
                "dirToCheckoutHg",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".hg\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutHg(File hgDir, File dir) {\n    String repository = null;\n    File hgrcFile = new File(hgDir, \"hgrc\");\n    Ini ini;\n    // There also exist Hg commands that will do this same thing.\n    if (hgrcFile.exists()) {\n        try {\n            ini = new Ini(new FileReader(hgrcFile));\n        } catch (IOException e) {\n            throw new Error(\"Problem reading file \" + hgrcFile);\n        }\n        Ini.Section pathsSection = ini.get(\"paths\");\n        if (pathsSection != null) {\n            repository = pathsSection.get(\"default\");\n            if (repository != null && repository.endsWith(\"/\")) {\n                repository = repository.substring(0, repository.length() - 1);\n            }\n        }\n    }\n    return new Checkout(RepoType.HG, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutGit",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory named \".git\" , create a corresponding Checkout object\n * for its parent.\n */\nstatic Checkout dirToCheckoutGit(File gitDir, File dir) {\n    String repository = UtilMDE.backticks(\"git\", \"config\", \"remote.origin.url\");\n    return new Checkout(RepoType.GIT, dir, repository, null);\n}"
            ],
            [
                "dirToCheckoutSvn",
                "plume",
                "MultiVersionControl",
                "/**\n * Given a directory that contains a .svn subdirectory, create a\n * corresponding Checkout object.\n * Returns null if this is not possible.\n */\nstatic /*@Nullable*/\nCheckout dirToCheckoutSvn(File dir) {\n    // For SVN, do\n    //   svn info\n    // and grep out these lines:\n    //   URL: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository/trunk/www\n    //   Repository Root: svn+ssh://login.csail.mit.edu/afs/csail/group/pag/projects/reCrash/repository\n    // Use SVNKit?\n    // Con: introduces dependency on external library.\n    // Pro: no need to re-implement or to call external process (which\n    //   might be slow for large checkouts).\n    // unannotated library: SVNKit\n    @SuppressWarnings(\"nullness\")\n    SVNWCClient wcClient = new SVNWCClient((/*@Nullable*/\n    ISVNAuthenticationManager) null, null);\n    SVNInfo info;\n    try {\n        info = wcClient.doInfo(new File(dir.toString()), SVNRevision.WORKING);\n    } catch (SVNException e) {\n        // throw new Error(\"Problem in dirToCheckoutSvn(\" + dir + \"): \", e);\n        System.err.println(\"Problem in dirToCheckoutSvn(\" + dir + \"): \" + e.getMessage());\n        if (e.getMessage() != null && e.getMessage().contains(\"This client is too old\")) {\n            System.err.println(\"plume-lib needs a newer version of SVNKit.\");\n        }\n        return null;\n    }\n    // getFile is null when operating on a working copy, as I am\n    // String relativeFile = info.getPath(); // relative to repository root -- can use to determine root of checkout\n    // getFile is just the (absolute) local file name for local items -- same as \"dir\"\n    // File relativeFile = info.getFile();\n    SVNURL url = info.getURL();\n    // This can be null (example: dir /afs/csail.mit.edu/u/m/mernst/.snapshot/class/6170/2006-spring/3dphysics).  I don't know under what circumstances.\n    SVNURL repoRoot = info.getRepositoryRootURL();\n    if (repoRoot == null) {\n        System.err.println(\"Problem:  old svn working copy in \" + dir.toString());\n        System.err.println(\"Check it out again to get a 'Repository Root' entry in the svn info output.\");\n        System.err.println(\"  repoUrl = \" + url);\n        System.exit(2);\n    }\n    if (debug) {\n        System.out.println();\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"     dir = \" + dir.toString());\n    }\n    // Strip common suffix off of local dir and repo url.\n    Pair<File, File> /*@Nullable*/\n    /*@Nullable*/\n    stripped = removeCommonSuffixDirs(dir, new File(url.getPath()), new File(repoRoot.getPath()), \".svn\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n        System.out.printf(\"dir (%s) is parent of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    if (stripped.b == null) {\n        System.out.printf(\"dir (%s) is child of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    String pathInRepoAtCheckout = stripped.b.toString();\n    try {\n        url = url.setPath(pathInRepoAtCheckout, false);\n    } catch (SVNException e) {\n        throw new Error(e);\n    }\n    if (debug) {\n        System.out.println(\"stripped: \" + stripped);\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"    cDir = \" + cDir.toString());\n    }\n    assert url.toString().startsWith(repoRoot.toString()) : \"repoRoot=\" + repoRoot + \", url=\" + url;\n    return new Checkout(RepoType.SVN, cDir, url.toString(), null);\n    /// Old implementation\n    // String module = url.toString().substring(repoRoot.toString().length());\n    // if (module.startsWith(\"/\")) {\n    //   module = module.substring(1);\n    // }\n    // if (module.equals(\"\")) {\n    //   module = null;\n    // }\n    // return new Checkout(RepoType.SVN, cDir, repoRoot.toString(), module);\n}"
            ],
            [
                "removeCommonSuffixDirs",
                "plume",
                "MultiVersionControl",
                "/**\n * Strip identical elements off the end of both paths, and then return\n * what is left of each.  Returned elements can be null!  If p2_limit is\n * non-null, then it should be a parent of p2, and the stripping stops\n * when p2 becomes p2_limit.  If p1_contains is non-null, then p1 must\n * contain a subdirectory of that name.\n */\nstatic Pair</*@Nullable*/\nFile, /*@Nullable*/\nFile> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains) {\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\", p1, p2, p2_limit, p1_contains);\n    }\n    // new names for results, because we will be side-effecting them\n    File r1 = p1;\n    File r2 = p2;\n    while (r1 != null && r2 != null && (p2_limit == null || !r2.equals(p2_limit)) && r1.getName().equals(r2.getName())) {\n        if (p1_contains != null && !new File(r1.getParentFile(), p1_contains).isDirectory()) {\n            break;\n        }\n        r1 = r1.getParentFile();\n        r2 = r2.getParentFile();\n    }\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs => %s %s%n\", r1, r2);\n    }\n    return Pair.of(r1, r2);\n}"
            ],
            [
                "eq",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Check for equality of non-null reference x and possibly-null y.  Uses\n * identity equality.\n */\n/*@Pure*/\nstatic boolean eq(Object x, /*@Nullable*/\nObject y) {\n    return x == y;\n}"
            ],
            [
                "hasher",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return the hash code for x\n */\n/*@Pure*/\nstatic int hasher(Object x) {\n    return System.identityHashCode(x);\n}"
            ],
            [
                "indexFor",
                "plume",
                "WeakIdentityHashMap",
                "/**\n * Return index for hash code h.\n */\n/*@Pure*/\nstatic int indexFor(int h, int length) {\n    return h & (length - 1);\n}"
            ],
            [
                "old_get_entry",
                "plume",
                "Lookup",
                "/**\n * Returns the next entry.  If no more entries are available, returns null.\n * @param reader where to read the entry from\n * @return the next entry, or null\n * @throws IOException if there is a problem reading a file\n */\npublic static /*@Nullable*/\nEntry old_get_entry(EntryReader reader) throws IOException {\n    try {\n        // Skip any preceeding blank lines\n        String line = reader.readLine();\n        while ((line != null) && (line.trim().length() == 0)) {\n            line = reader.readLine();\n        }\n        if (line == null) {\n            return (null);\n        }\n        Entry entry = null;\n        String filename = reader.getFileName();\n        long line_number = reader.getLineNumber();\n        // If this is a long entry\n        if (line.startsWith(\">entry\")) {\n            // Get the current filename\n            String current_filename = reader.getFileName();\n            // Remove '>entry' from the line\n            line = line.replaceFirst(\"^>entry *\", \"\");\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find the termination of the entry\n            while ((line != null) && !line.startsWith(\">entry\") && !line.equals(\"<entry\") && current_filename.equals(reader.getFileName())) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            // If this entry was terminated by the start of the next one,\n            // put that line back\n            if ((line != null) && (line.startsWith(\">entry\") || !current_filename.equals(reader.getFileName()))) {\n                reader.putback(line);\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, false);\n        } else {\n            // blank separated entry\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            // Read until we find another blank line\n            while ((line != null) && (line.trim().length() != 0)) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, true);\n        }\n        return (entry);\n    } catch (FileNotFoundException e) {\n        System.out.printf(\"Error: Can't read %s at line %d in file %s%n\", e.getMessage(), reader.getLineNumber(), reader.getFileName());\n        System.exit(254);\n        return (null);\n    }\n}"
            ],
            [
                "first_line",
                "plume",
                "Lookup",
                "/**\n * Returns the first line of entry.\n * @param entry the entry whose first line to return\n * @return the first line of entry\n */\npublic static String first_line(String entry) {\n    int ii = entry.indexOf(lineSep);\n    if (ii == -1) {\n        return entry;\n    }\n    return entry.substring(0, ii);\n}"
            ],
            [
                "of",
                "plume",
                "Pair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a pair of the values (a, b)\n */\npublic static <A extends /*@Nullable*/\nObject, B extends /*@Nullable*/\nObject> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "short_str",
                "plume",
                "TaskManager",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "short_str",
                "plume",
                "Task",
                "/*@SideEffectFree*/\npublic static String short_str(float f) {\n    if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n    } else {\n        return String.format(\"%d\", Math.round(f));\n    }\n}"
            ],
            [
                "versionNumbers",
                "plume",
                "ClassFileVersion",
                "/**\n * Return an array of the major vernios, minor version, and JDK version\n * of the class read from the input stream.\n * Return null if there is an error or the input isn't a class file.\n * @param is input stream from which to read a class\n * @return array of three version numbers\n */\npublic static double[] versionNumbers(InputStream is) {\n    try {\n        DataInputStream dis = new DataInputStream(is);\n        int magic = dis.readInt();\n        if (magic != 0xcafebabe) {\n            return null;\n        }\n        double minor = dis.readShort();\n        double major = dis.readShort();\n        double jdkVersion;\n        if (major < 48) {\n            // really 1.3.1\n            jdkVersion = 1.3;\n        } else if (major == 48) {\n            // really 1.4.2\n            jdkVersion = 1.4;\n        } else if (major == 49) {\n            jdkVersion = 1.5;\n        } else if (major == 50) {\n            jdkVersion = 6;\n        } else {\n            jdkVersion = 7;\n        }\n        return new double[] { major, minor, jdkVersion };\n    } catch (IOException e) {\n        return null;\n    }\n}"
            ],
            [
                "of",
                "plume",
                "WeakIdentityPair",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param a first argument\n * @param b second argument\n * @return a WeakIdentityPair of (a, b)\n */\npublic static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b) {\n    return new WeakIdentityPair<A, B>(a, b);\n}"
            ],
            [
                "start",
                "plume",
                "OptionsDoclet",
                "// Doclet-specific methods\n/**\n * Entry point for the doclet.\n * @param root the root document\n * @return true if processing completed without an error\n */\npublic static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n        // TODO: Class.forName() expects a binary name but doc.qualifiedName()\n        // returns a fully qualified name.  I do not know a good way to convert\n        // between these two name formats.  For now, we simply ignore inner\n        // classes.  This limitation can be removed when we figure out a better\n        // way to go from ClassDoc to Class<?>.\n        if (doc.containingClass() != null) {\n            continue;\n        }\n        Class<?> clazz;\n        try {\n            // Javadoc source code is not yet annotated\n            @SuppressWarnings(\"signature\")\n            String /*@BinaryNameForNonArray*/\n            className = doc.qualifiedName();\n            clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        }\n        if (needsInstantiation(clazz)) {\n            try {\n                Constructor<?> c = clazz.getDeclaredConstructor();\n                c.setAccessible(true);\n                objs.add(c.newInstance(new Object[0]));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            objs.add(clazz);\n        }\n    }\n    if (objs.isEmpty()) {\n        System.out.println(\"Error: no classes found\");\n        return false;\n    }\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n        System.out.println(\"Error: no @Option-annotated fields found\");\n        return false;\n    }\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n        o.write();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "optionLength",
                "plume",
                "OptionsDoclet",
                "/**\n * Given a command-line option of this doclet, returns the number of\n * arguments you must specify on the command line for the given option.\n * Returns 0 if the argument is not recognized.  This method is\n * automatically invoked.\n *\n * @param option the command-line option\n * @return the number of command-line arguments needed when using the option\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n        System.out.printf(USAGE);\n        return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n        return 1;\n    }\n    if (option.equals(\"-docfile\") || option.equals(\"-outfile\") || option.equals(\"-format\") || option.equals(\"-d\")) {\n        return 2;\n    }\n    return 0;\n}"
            ],
            [
                "validOptions",
                "plume",
                "OptionsDoclet",
                "/**\n * Tests the validity of command-line arguments passed to this doclet.\n * Returns true if the option usage is valid, and false otherwise.  This\n * method is automatically invoked.\n *\n * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n * @param reporter where to report errors\n * @return true iff the command-line options are valid\n * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/doclet/overview.html\">Doclet overview</a>\n */\npublic static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            if (hasDocFile) {\n                reporter.printError(\"-docfile option specified twice\");\n                return false;\n            }\n            File f = new File(os[1]);\n            if (!f.exists()) {\n                reporter.printError(\"-docfile file not found: \" + os[1]);\n                return false;\n            }\n            docFile = os[1];\n            hasDocFile = true;\n        }\n        if (opt.equals(\"-outfile\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-outfile option specified twice\");\n                return false;\n            }\n            if (inPlace) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            outFile = os[1];\n            hasOutFile = true;\n        }\n        if (opt.equals(\"-i\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            inPlace = true;\n        }\n        if (opt.equals(\"-format\")) {\n            if (hasFormat) {\n                reporter.printError(\"-format option specified twice\");\n                return false;\n            }\n            if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n                reporter.printError(\"unrecognized output format: \" + os[1]);\n                return false;\n            }\n            hasFormat = true;\n        }\n        if (opt.equals(\"-d\")) {\n            if (hasDestDir) {\n                reporter.printError(\"-d specified twice\");\n                return false;\n            }\n            hasDestDir = true;\n        }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n        reporter.printError(\"docfile must be different from outfile\");\n        return false;\n    }\n    if (inPlace && docFile == null) {\n        reporter.printError(\"-i supplied but -docfile was not\");\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "javadocToHtml",
                "plume",
                "OptionsDoclet",
                "/**\n * Replace the @link tags and block @see tags in a Javadoc comment with\n * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n * comment while still being presentable. <p>\n *\n * This is only a temporary solution.  Ideally, @link/@see tags would be\n * converted to HTML links that point to actual documentation.\n *\n * @param doc a Javadoc comment to convert to HTML\n * @return HTML version of doc\n */\npublic static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n        if (tag instanceof SeeTag) {\n            b.append(\"<code>\" + tag.text() + \"</code>\");\n        } else {\n            b.append(tag.text());\n        }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n        b.append(\" See: \");\n        {\n            StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n            for (SeeTag tag : seetags) {\n                bb.append(\"<code>\" + tag.text() + \"</code>\");\n            }\n            b.append(bb);\n        }\n        b.append(\".\");\n    }\n    return b.toString();\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param s string to check for being a regular expression\n * @return true iff s is a regular expression\n */\n/*@Pure*/\n/*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\npublic static boolean isRegex(String s) {\n    return isRegex(s, 0);\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression with at least the given number of groups.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return true iff s is a regular expression with groups groups\n */\n// RegexUtil; for purity, catches an exception\n@SuppressWarnings({ \"regex\", \"deterministic\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(String s, int groups) {\n    Pattern p;\n    try {\n        p = Pattern.compile(s);\n    } catch (PatternSyntaxException e) {\n        return false;\n    }\n    return getGroupCount(p) >= groups;\n}"
            ],
            [
                "isRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns true if the argument is a syntactically valid regular\n * expression.\n * @param c char to check for being a regular expression\n * @return true iff c is a regular expression\n */\n@SuppressWarnings({ \"regex\", \"purity.not.deterministic.call\" })\npublic static /*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*/\nboolean isRegex(char c) {\n    return isRegex(Character.toString(c));\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a string describing why the argument is\n * not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nString regexError(String s) {\n    return regexError(s, 0);\n}"
            ],
            [
                "regexError",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns\n * a string describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a string describing why the argument is not a regex\n */\n// RegexUtil;\n@SuppressWarnings({ \"regex\", \"not.sef\" })\npublic static /*@Nullable*/\nString regexError(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return regexErrorMessage(s, groups, actualGroups);\n        }\n    } catch (PatternSyntaxException e) {\n        return e.getMessage();\n    }\n    return null;\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression. Otherwise returns a PatternSyntaxException describing\n * why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s) {\n    return regexException(s, 0);\n}"
            ],
            [
                "regexException",
                "plume",
                "RegexUtil",
                "/**\n * Returns null if the argument is a syntactically valid regular\n * expression with at least the given number of groups. Otherwise returns a\n * PatternSyntaxException describing why the argument is not a regex.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return null, or a PatternSyntaxException describing why the argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Nullable*/\nPatternSyntaxException regexException(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return new PatternSyntaxException(regexErrorMessage(s, groups, actualGroups), s, -1);\n        }\n    } catch (PatternSyntaxException pse) {\n        return pse;\n    }\n    return null;\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex String} if it is a regex,\n * otherwise throws an error. The purpose of this method is to suppress Regex\n * Checker warnings. It should be very rarely needed.\n * @param s string to check for being a regular expression\n * @return its argument\n * @throws Error if argument is not a regex\n */\n/*@SideEffectFree*/\n// The return type annotation is a conservative bound.\npublic static /*@Regex*/\nString asRegex(String s) {\n    return asRegex(s, 0);\n}"
            ],
            [
                "asRegex",
                "plume",
                "RegexUtil",
                "/**\n * Returns the argument as a {@code @Regex(groups) String} if it is a regex\n * with at least the given number of groups, otherwise throws an error. The\n * purpose of this method is to suppress Regex Checker warnings. It should\n * be very rarely needed.\n * @param s string to check for being a regular expression\n * @param groups number of groups expected\n * @return its argument\n * @throws Error if argument is not a regex\n */\n// RegexUtil\n@SuppressWarnings(\"regex\")\npublic static /*@Regex*/\nString asRegex(String s, int groups) {\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            throw new Error(regexErrorMessage(s, groups, actualGroups));\n        }\n        return s;\n    } catch (PatternSyntaxException e) {\n        throw new Error(e);\n    }\n}"
            ],
            [
                "findClass",
                "plume",
                "JWhich",
                "/**\n * Returns the URL of the resource denoted by the specified\n * class name, as prescribed by the class path.\n *\n * @param className name of the class\n * @return class URL, or null of the class was not found\n */\npublic static /*@Nullable*/\nURL findClass(final String className) {\n    return JWhich.class.getResource(asResourceName(className));\n}"
            ],
            [
                "asResourceName",
                "plume",
                "JWhich",
                "protected static String asResourceName(String resource) {\n    if (!resource.startsWith(\"/\")) {\n        resource = \"/\" + resource;\n    }\n    resource = resource.replace('.', '/');\n    resource = resource + \".class\";\n    return resource;\n}"
            ],
            [
                "getClasspath",
                "plume",
                "JWhich",
                "/**\n * Return the classpath.\n * @return the classpath\n */\n/*@EnsuresNonNull(\"CLASSPATH\")*/\nprotected static String getClasspath() {\n    if (CLASSPATH == null) {\n        String classpath = System.getProperty(\"java.class.path\");\n        setClasspath(classpath);\n    }\n    return CLASSPATH;\n}"
            ],
            [
                "internStrings",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Strings\n///\n/**\n * Replace each element of the array by its interned version.\n * Side-effects the array, but also returns it.\n * @param a the array whose elements to intern in place\n * @return an interned version of a\n * @see String#intern\n */\n// side-effects the array in place (dangerous, but convenient)\n@SuppressWarnings(\"interning\")\npublic static String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] != null) {\n            a[i] = a[i].intern();\n        }\n    }\n    return a;\n}"
            ],
            [
                "isInterned",
                "plume",
                "Intern",
                "///////////////////////////////////////////////////////////////////////////\n/// Testing interning\n///\n/**\n * Return true if the argument is interned (is canonical among all\n * objects equal to itself).\n * @param value the value to test for interning\n * @return true iff value is interned\n */\n// interning implementation\n@SuppressWarnings(\"interning\")\npublic static /*@Pure*/\nboolean isInterned(/*@Nullable*/\nObject value) {\n    if (value == null) {\n        // nothing to do\n        return true;\n    } else if (value instanceof String) {\n        return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n        return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n        return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n        return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n        return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n        return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n        return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n        return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n        return (value == intern((Object[]) value));\n    } else {\n        // Nothing to do, because we don't intern other types.\n        // System.out.println(\"What type? \" + value.getClass().getName());\n        return true;\n    }\n}"
            ],
            [
                "numIntegers",
                "plume",
                "Intern",
                "// For testing only\npublic static int numIntegers() {\n    return internedIntegers.size();\n}"
            ],
            [
                "numLongs",
                "plume",
                "Intern",
                "public static int numLongs() {\n    return internedLongs.size();\n}"
            ],
            [
                "numIntArrays",
                "plume",
                "Intern",
                "public static int numIntArrays() {\n    return internedIntArrays.size();\n}"
            ],
            [
                "numLongArrays",
                "plume",
                "Intern",
                "public static int numLongArrays() {\n    return internedLongArrays.size();\n}"
            ],
            [
                "numDoubles",
                "plume",
                "Intern",
                "public static int numDoubles() {\n    return internedDoubles.size();\n}"
            ],
            [
                "numDoubleArrays",
                "plume",
                "Intern",
                "public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n}"
            ],
            [
                "numStringArrays",
                "plume",
                "Intern",
                "public static int numStringArrays() {\n    return internedStringArrays.size();\n}"
            ],
            [
                "numObjectArrays",
                "plume",
                "Intern",
                "public static int numObjectArrays() {\n    return internedObjectArrays.size();\n}"
            ],
            [
                "integers",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nInteger> integers() {\n    return internedIntegers.keySet().iterator();\n}"
            ],
            [
                "longs",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nLong> longs() {\n    return internedLongs.keySet().iterator();\n}"
            ],
            [
                "intArrays",
                "plume",
                "Intern",
                "public static Iterator<int[]> intArrays() {\n    return internedIntArrays.keySet().iterator();\n}"
            ],
            [
                "longArrays",
                "plume",
                "Intern",
                "public static Iterator<long[]> longArrays() {\n    return internedLongArrays.keySet().iterator();\n}"
            ],
            [
                "doubles",
                "plume",
                "Intern",
                "public static Iterator</*@Interned*/\nDouble> doubles() {\n    return internedDoubles.keySet().iterator();\n}"
            ],
            [
                "doubleArrays",
                "plume",
                "Intern",
                "public static Iterator<double[]> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n}"
            ],
            [
                "stringArrays",
                "plume",
                "Intern",
                "public static Iterator<String[]> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n}"
            ],
            [
                "objectArrays",
                "plume",
                "Intern",
                "public static Iterator<Object[]> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a String.\n * Delegates to the builtin String.intern() method.\n * Provided for completeness.\n * @param a the string to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static /*@Interned*/\n/*@PolyNull*/\nString intern(/*@PolyNull*/\nString a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n        return null;\n    }\n    return a.intern();\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a long.\n * A no-op.  Provided for completeness.\n * @param l the long to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static long intern(long l) {\n    return l;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Interns a double\n * A no-op.  Provided for completeness.\n * @param d the double to intern\n * @return an interned version of the argument\n */\n/*@Pure*/\npublic static double intern(double d) {\n    return d;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Integer.\n * Return a canonical representation for the Integer.\n * @param a an Integer to canonicalize\n * @return a canonical representation for the Integer\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Intern.valueOf is intended to promise\n// the same).  This does not currently take advantage of that.\n// interning implementation\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nInteger intern(Integer a) {\n    WeakReference<Integer> /*@Interned*/\n    lookup = internedIntegers.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Integer /*@Interned*/\n        result = (/*@Interned*/\n        Integer) a;\n        internedIntegers.put(result, new WeakReference</*@Interned*/\n        Integer>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nInteger internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n}"
            ],
            [
                "internedInteger",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Integer with value parsed from the string.\n * @param s the string to parse\n * @return an interned Integer parsed from s\n */\npublic static /*@Interned*/\nInteger internedInteger(String s) {\n    return intern(Integer.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Long.\n * Return a canonical representation for the Long.\n * @param a the value to intern\n * @return a canonical representation for the Long\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Long.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nLong intern(Long a) {\n    WeakReference<Long> /*@Interned*/\n    lookup = internedLongs.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Long /*@Interned*/\n        result = (/*@Interned*/\n        Long) a;\n        internedLongs.put(result, new WeakReference</*@Interned*/\n        Long>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value i.\n * @param i the value to intern\n * @return an interned Integer with value i\n */\npublic static /*@Interned*/\nLong internedLong(long i) {\n    return intern(Long.valueOf(i));\n}"
            ],
            [
                "internedLong",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Long with value parsed from the string.\n * @param s the string to parse\n * @return an interned Long parsed from s\n */\npublic static /*@Interned*/\nLong internedLong(String s) {\n    return intern(Long.decode(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) an int[].\n * Return a canonical representation for the int[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the int[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static int[] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        int[] /*@Interned*/\n        result = (int[]) a;\n        internedIntArrays.put(result, new WeakReference<int[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a long[].\n * Return a canonical representation for the long[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the long[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static long[] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        long[] /*@Interned*/\n        result = (long[]) a;\n        internedLongArrays.put(result, new WeakReference<long[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) a Double.\n * Return a canonical representation for the Double.\n * @param a the Double to canonicalize\n * @return a canonical representation for the Double\n */\n// TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n// values between -128 and 127 (and Double.valueOf is intended to promise\n// the same).  This could take advantage of that.\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static /*@Interned*/\nDouble intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n        return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) {\n        // catches both positive and negative zero\n        return internedDoubleZero;\n    }\n    WeakReference<Double> /*@Interned*/\n    lookup = internedDoubles.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        Double /*@Interned*/\n        result = (/*@Interned*/\n        Double) a;\n        internedDoubles.put(result, new WeakReference</*@Interned*/\n        Double>(result));\n        return result;\n    }\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value i.\n * @param d the value to intern\n * @return an interned Double with value d\n */\npublic static /*@Interned*/\nDouble internedDouble(double d) {\n    return intern(Double.valueOf(d));\n}"
            ],
            [
                "internedDouble",
                "plume",
                "Intern",
                "// Not sure whether this convenience method is really worth it.\n/**\n * Returns an interned Double with value parsed from the string.\n * @param s the string to parse\n * @return an interned Double parsed from s\n */\npublic static /*@Interned*/\nDouble internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "// I might prefer to have the intern methods first check using a straight\n// eq hashing, which would be more efficient if the array is already\n// interned.  (How frequent do I expect that to be, and how much would\n// that really improve performance even in that case?)\n/**\n * Intern (canonicalize) a double[].\n * Return a canonical representation for the double[] array.\n * Arrays are compared according to their elements.\n * @param a the array to canonicalize\n * @return a canonical representation for the double[] array\n */\n@SuppressWarnings({ \"interning\", \"purity\" })\npublic static double[] intern(double[] a) {\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        // cast is redundant (except in JSR 308)\n        @SuppressWarnings(\"cast\")\n        double[] /*@Interned*/\n        result = (double[]) a;\n        internedDoubleArrays.put(result, new WeakReference<double[]>(result));\n        return result;\n    }\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an String[].\n * Return a canonical representation for the String[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the String[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static String[] intern(/*@PolyNull*/\n/*@Interned*/\nString[] a) {\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n        assert a[k] == Intern.intern(a[k]);\n    }\n    WeakReference<String[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    String[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (String[]) a;\n        internedStringArrays.put(result, new WeakReference<String[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    String[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Intern (canonicalize) an Object[].\n * Return a canonical representation for the Object[] array.\n * Arrays are compared according to their elements.\n * The elements should themselves already be interned;\n * they are compared using their equals() methods.\n * @param a the array to canonicalize\n * @return a canonical representation for the Object[] array\n */\n@SuppressWarnings({ // interns its argument\n\"interning\", \"purity\", \"cast\" })\npublic static Object[] intern(/*@PolyNull*/\n/*@Interned*/\nObject[] a) {\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    WeakReference<Object[]> /*@Nullable*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectArrays.get(a);\n    /*@Nullable*/\n    /*@Interned*/\n    Object[] /*@Interned*/\n    result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (Object[]) a;\n        internedObjectArrays.put(result, new WeakReference<Object[]>(result));\n    }\n    @SuppressWarnings(// Polynull because value = parameter a, so same type & nullness as for parameter a\n    \"nullness\")\n    Object[] /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    polyresult = result;\n    return polyresult;\n}"
            ],
            [
                "intern",
                "plume",
                "Intern",
                "/**\n * Convenince method to intern an Object when we don't know its\n * runtime type.  Its runtime type must be one of the types for\n * which we have an intern() method, else an exception is thrown.\n * If the argument is an array, its elements should themselves be\n * interned.\n * @param a an Object to canonicalize\n * @return a canonical version of a\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Interned*/\n/*@PolyNull*/\nObject intern(/*@PolyNull*/\nObject a) {\n    if (a == null) {\n        return null;\n    } else if (a instanceof String) {\n        return intern((String) a);\n    } else if (a instanceof String[]) {\n        @SuppressWarnings(\"interning\")\n        String[] /*@Interned*/\n        asArray = (String[]) a;\n        return intern(asArray);\n    } else if (a instanceof Integer) {\n        return intern((Integer) a);\n    } else if (a instanceof Long) {\n        return intern((Long) a);\n    } else if (a instanceof int[]) {\n        return intern((int[]) a);\n    } else if (a instanceof long[]) {\n        return intern((long[]) a);\n    } else if (a instanceof Double) {\n        return intern((Double) a);\n    } else if (a instanceof double[]) {\n        return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n        @SuppressWarnings(\"interning\")\n        Object[] /*@Interned*/\n        asArray = (Object[]) a;\n        return intern(asArray);\n    } else {\n        throw new IllegalArgumentException(\"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * Return the subsequence of seq from start (inclusive) to end\n * (exclusive) that is interned.  What's different about this method\n * from manually finding the subsequence and interning the\n * subsequence is that if the subsequence is already interned, we\n * can avoid having to compute the sequence.  Since derived\n * variables in Daikon compute the subsequence many times, this\n * shortcut saves quite a bit of computation.  It saves even more\n * when there may be many derived variables that are non-canonical,\n * since they are guaranteed to be ==.\n * <p>\n * Requires that seq is already interned.\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n */\npublic static int[] internSubsequence(int[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int[]> /*@Interned*/\n    sai = new SequenceAndIndices<int[]>(seq, start, end);\n    WeakReference<int[]> /*@Interned*/\n    lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n        int[] /*@Interned*/\n        subseq = Intern.intern(subseqUninterned);\n        internedIntSequenceAndIndices.put(sai, new WeakReference<int[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static long[] internSubsequence(long[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long[]> /*@Interned*/\n    sai = new SequenceAndIndices<long[]>(seq, start, end);\n    WeakReference<long[]> /*@Interned*/\n    lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        long[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedLongSequenceAndIndices.put(sai, new WeakReference<long[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static double[] internSubsequence(double[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double[]> /*@Interned*/\n    sai = new SequenceAndIndices<double[]>(seq, start, end);\n    WeakReference<double[]> /*@Interned*/\n    lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        double[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        internedDoubleSequenceAndIndices.put(sai, new WeakReference<double[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static Object[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nObject[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<Object[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<Object[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        Object[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedObjectSequenceAndIndices.put(sai, new WeakReference<Object[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "internSubsequence",
                "plume",
                "Intern",
                "/**\n * @param seq the sequence whose subsequence should be interned\n * @param start the index of the start of the subsequence to be interned\n * @param end the index of the end of the subsequence to be interned\n * @return a subsequence of seq from start to end that is interned\n * @see #internSubsequence(int[], int, int)\n */\npublic static String[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nString[] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<String[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedStringSequenceAndIndices.put(sai, new WeakReference<String[]>(subseq));\n        return subseq;\n    }\n}"
            ],
            [
                "dominators",
                "plume",
                "GraphMDE",
                "// Algorithms for computing dominators:\n//\n// Wikipedia:\n//  // dominator of the start node is the start itself\n//  Dom(n_0) = {n_0}\n//  // for all other nodes, set all nodes as the dominators\n//  for each n in N - {n_0}\n//      Dom(n) = N;\n//  // iteratively eliminate nodes that are not dominators\n//  while changes in any Dom(n)\n//      for each n in N - {n_0}:\n//          Dom(n) = {n} union with intersection over all p in pred(n) of Dom(p)\n//\n// Cooper/Harvey/Kennedy:\n//  for all nodes, n\n//    DOM[n] := {1 . . .N}\n//  Changed := true\n//  while (Changed)\n//    Changed := false\n//    for all nodes, n, in reverse postorder\n//      new_set := (Intersect_{p:=preds(n)} DOM[p]) union {n}\n//      if (new_set != DOM[n])\n//        DOM[n] := new_set\n//        Changed := true\n// The two algorithms are essentially the same; this implementation\n// follows the Wikipedia one.\n/**\n * Computes, for each node in the graph, its set of (pre-)dominators.\n * Supply a successor graph if you want post-dominators.\n * @param <T> type of the graph nodes\n * @param predecessors a graph, represented as a predecessor map\n * @return a map from each node to a list of its pre-dominators\n */\npublic static <T> Map<T, List<T>> dominators(Map<T, List</*@KeyFor(\"#1\")*/\nT>> predecessors) {\n    // Map</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>> dom = new HashMap</*@KeyFor({\"preds\",\"dom\"})*/ T,List</*@KeyFor({\"preds\",\"dom\"})*/ T>>();\n    Map<T, List<T>> dom = new HashMap<T, List<T>>();\n    // every element of pred's value will be a key for dom\n    @SuppressWarnings(\"keyfor\")\n    Map<T, List<T>> /*@KeyFor({\"dom\"})*/\n    preds = predecessors;\n    List<T> nodes = new ArrayList<T>(preds.keySet());\n    // Compute roots & non-roots, for convenience\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    roots = new ArrayList<T>();\n    List<T> /*@KeyFor({\"preds\",\"dom\"})*/\n    non_roots = new ArrayList<T>();\n    // Initialize result:  for roots just the root, otherwise everything\n    for (T node : preds.keySet()) {\n        if (preds.get(node).isEmpty()) {\n            // This is a root.  Its only dominator is itself.\n            Set<T> set = Collections.singleton(node);\n            dom.put(node, new ArrayList<T>(set));\n            roots.add(node);\n        } else {\n            // Initially, set all nodes as dominators;\n            // will later remove nodes that aren't dominators.\n            dom.put(node, new ArrayList<T>(nodes));\n            non_roots.add(node);\n        }\n    }\n    assert roots.size() + non_roots.size() == nodes.size();\n    // Invariants:\n    // preds and dom have the same keyset.\n    // All of the following are keys for both preds and dom:\n    //  * every key in pred\n    //  * elery element of every pred value\n    //  * every key in dom\n    //  * elery element of every dom value\n    // So, the type of pred is now\n    //\n    // rather than its original type\n    //   Map<T,List</*@KeyFor(\"preds\")*/ T>> preds\n    boolean changed = true;\n    while (changed) {\n        changed = false;\n        for (T node : non_roots) {\n            List<T> new_doms = null;\n            assert preds.containsKey(node);\n            for (T pred : preds.get(node)) {\n                assert dom.containsKey(pred);\n                /*@NonNull*/\n                List<T> dom_of_pred = dom.get(pred);\n                if (new_doms == null) {\n                    // make copy because we may side-effect new_doms\n                    new_doms = new ArrayList<T>(dom_of_pred);\n                } else {\n                    new_doms.retainAll(dom_of_pred);\n                }\n            }\n            assert new_doms != null : \"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\";\n            new_doms.add(node);\n            assert dom.containsKey(node);\n            if (!dom.get(node).equals(new_doms)) {\n                dom.put(node, new_doms);\n                changed = true;\n            }\n        }\n    }\n    for (T node : preds.keySet()) {\n        // TODO: The following two assert statements would be easier to read\n        // than the one combined one, but a bug (TODO:  Jonathan will add a\n        // bug number) prevents it from type-checking.\n        // assert dom.containsKey(node);\n        // assert dom.get(node).contains(node);\n        assert dom.containsKey(node) && dom.get(node).contains(node);\n    }\n    return dom;\n}"
            ],
            [
                "canonicalizeTimezone",
                "plume",
                "ICalAvailable",
                "static String canonicalizeTimezone(String timezone) {\n    String result = canonicalTimezones.get(timezone.toLowerCase());\n    return (result == null) ? timezone : result;\n}"
            ],
            [
                "printedTimezone",
                "plume",
                "ICalAvailable",
                "/*@Pure*/\nstatic String printedTimezone(TimeZone tz) {\n    String tzString = tz.getDisplayName();\n    String result = printedTimezones.get(tzString);\n    return (result == null) ? tzString : result;\n}"
            ],
            [
                "parseTime",
                "plume",
                "ICalAvailable",
                "// Parse a time like \"9:30pm\"\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nDateTime parseTime(String time) {\n    Matcher m = timeRegexp.matcher(time);\n    if (!m.matches()) {\n        System.err.println(\"Bad time: \" + time);\n        System.exit(1);\n    }\n    @SuppressWarnings(// Regex Checker imprecision:  matches() guarantees that group 1 exists in regexp\n    \"nullness\")\n    String /*@NonNull*/\n    hourString = m.group(1);\n    String minuteString = m.group(3);\n    String ampmString = m.group(4);\n    int hour = Integer.parseInt(hourString);\n    if ((ampmString != null) && ampmString.toLowerCase().equals(\"pm\")) {\n        hour += 12;\n    }\n    int minute = 0;\n    if (minuteString != null) {\n        minute = Integer.parseInt(minuteString);\n    }\n    DateTime result = new DateTime();\n    result.setTimeZone(tz1);\n    result.setHours(hour);\n    result.setMinutes(minute);\n    result.setSeconds(0);\n    return result;\n}"
            ],
            [
                "rangeString",
                "plume",
                "ICalAvailable",
                "static String rangeString(Period p, TimeZone tz) {\n    tf.setTimeZone(tz);\n    DateTime pstart = p.getStart();\n    DateTime pend = p.getEnd();\n    String rangeString = tf.format(pstart) + \" to \" + tf.format(pend);\n    rangeString = rangeString.replace(\" AM\", \"am\");\n    rangeString = rangeString.replace(\" PM\", \"pm\");\n    return rangeString;\n}"
            ],
            [
                "periodListString",
                "plume",
                "ICalAvailable",
                "static String periodListString(PeriodList pl, TimeZone tz) {\n    tf.setTimeZone(tz);\n    StringBuilder result = new StringBuilder();\n    // \"Object\" because PeriodList extends TreeSet, but it really ought to\n    // extend TreeSet</*@NonNull*/ Period>\n    for (Object p : pl) {\n        assert p != null : \"@AssumeAssertion(nullness): non-generic container class; elements are non-null\";\n        result.append(rangeString((Period) p, tz) + \"\\n\");\n    }\n    return result.toString();\n}"
            ],
            [
                "mergeDateAndTime",
                "plume",
                "ICalAvailable",
                "/**\n * Creates a new DateTime with date taken from the first argument and\n * time taken from the second argument.\n * @return the merged DateTime\n */\n// for iCal4j\n@SuppressWarnings(\"deprecation\")\nstatic DateTime mergeDateAndTime(DateTime date, DateTime time) {\n    if (!date.getTimeZone().equals(time.getTimeZone())) {\n        throw new Error(String.format(\"non-matching timezones: %s %s\", date.getTimeZone(), time.getTimeZone()));\n    }\n    DateTime result = new DateTime(date);\n    result.setHours(time.getHours());\n    result.setMinutes(time.getMinutes());\n    result.setSeconds(time.getSeconds());\n    return result;\n}"
            ],
            [
                "oneDayAvailable",
                "plume",
                "ICalAvailable",
                "// TODO:  don't propose times that are before the current moment.\n// Process day-by-day because otherwise weekends and evenings are included.\n// for iCal4j\n@SuppressWarnings(\"unchecked\")\nstatic /*@RequiresNonNull(\"tz1\")*/\nList<Period> oneDayAvailable(DateTime day, List<Calendar> calendars) {\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...)%n\", day);\n    }\n    List<Period> result = new ArrayList<Period>();\n    // for iCal4j\n    @SuppressWarnings(\"deprecation\")\n    int dayOfWeek = day.getDay();\n    if (!businessDays.contains(dayOfWeek)) {\n        return result;\n    }\n    for (Period bh : businessHours) {\n        DateTime start = mergeDateAndTime(day, bh.getStart());\n        DateTime end = mergeDateAndTime(day, bh.getEnd());\n        VFreeBusy request = new VFreeBusy(start, end, new Dur(0, 0, 0, 1));\n        if (debug) {\n            System.out.println(\"Request = \" + request);\n        }\n        ComponentList busyTimes = new ComponentList();\n        // Problem:  any all-day events will be treated as UTC.\n        // Instead, they should be converted to local time (tz1).\n        // But VFreeBusy does not support this, so I may need to convert\n        // daily events into a different format before inserting them.\n        for (Calendar calendar : calendars) {\n            // getComponents() returns a raw ArrayList.  Expose its element type.\n            ArrayList<Component> /*@NonNull*/\n            clist = calendar.getComponents();\n            for (Component c : clist) {\n                if (c instanceof VEvent) {\n                    VEvent v = (VEvent) c;\n                    DtStart dts = v.getStartDate();\n                    Parameter dtsValue = dts.getParameter(\"VALUE\");\n                    boolean allDay = (dtsValue != null) && dtsValue.getValue().equals(\"DATE\");\n                    // TODO: convert to the proper timezone.\n                    // Tricky: must deal with the possibility of RRULE:FREQ=\n                }\n                busyTimes.add(c);\n            }\n        }\n        VFreeBusy response = new VFreeBusy(request, busyTimes);\n        if (debug) {\n            System.out.println(\"Response = \" + response);\n        }\n        FreeBusy freefb = (FreeBusy) response.getProperty(\"FREEBUSY\");\n        if (freefb == null) {\n            if (debug) {\n                System.out.println(\"FREEBUSY property is null\");\n            }\n            continue;\n        }\n        // interned fields from a library, but not annotated so\n        @SuppressWarnings(\"interning\")\n        boolean isFree = (freefb.getParameter(Parameter.FBTYPE) == FbType.FREE);\n        assert isFree;\n        PeriodList freePeriods = freefb.getPeriods();\n        if (debug) {\n            System.out.printf(\"Free periods: %n%s%n\", periodListString(freePeriods, tz1));\n        }\n        result.addAll(freePeriods);\n    }\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...) => %s elements%n\", day, result.size());\n    }\n    return result;\n}"
            ],
            [
                "parseDate",
                "plume",
                "ICalAvailable",
                "/**\n * Parses a date when formatted in several common formats.\n * @return a Date read from the given string\n * @see dateFormats\n */\nstatic java.util.Date parseDate(String strDate) throws ParseException {\n    if (Pattern.matches(\"^[0-9][0-9]?/[0-9][0-9]?$\", date)) {\n        // for iCal4j\n        @SuppressWarnings(\"deprecation\")\n        int year = new Date().getYear() + 1900;\n        strDate = strDate + \"/\" + year;\n    }\n    for (DateFormat this_df : dateFormats) {\n        this_df.setLenient(false);\n        try {\n            java.util.Date result = this_df.parse(strDate);\n            return result;\n        } catch (ParseException e) {\n            // Try the next format in the list.\n        }\n    }\n    throw new ParseException(\"bad date \" + strDate, 0);\n}"
            ],
            [
                "formatDate",
                "plume",
                "ICalAvailable",
                "static String formatDate(DateTime d, TimeZone tz) {\n    df.setTimeZone(tz);\n    String result = df.format(d);\n    // Don't remove trailing year; it's a good double-check.\n    // Remove trailing year, such as \", 1952\".\n    // result = result.substring(0, result.length() - 6);\n    // Prepend day of week.\n    result = dffull.format(d).substring(0, 3) + \" \" + result;\n    return result;\n}"
            ],
            [
                "get_method_declaration",
                "plume",
                "BCELUtil",
                "/**\n * Returns a string describing a method declaration. It contains the access\n * flags (public, private, static, etc), the return type, the method name, and\n * the types of each of its arguments.\n * @param m the method\n * @return a string describing the method declaration\n */\npublic static String get_method_declaration(Method m) {\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n        f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n}"
            ],
            [
                "get_access_flags",
                "plume",
                "BCELUtil",
                "/**\n * Return a string representation of the access flags of method m.\n * @param m the method whose access flags to retrieve\n * @return a string representation of the access flags of method m\n */\nstatic String get_access_flags(Method m) {\n    int flags = m.getAccessFlags();\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n        if ((flags & pow) != 0) {\n            if (buf.length() > 0) {\n                buf.append(\" \");\n            }\n            if (i < Const.ACCESS_NAMES_LENGTH) {\n                buf.append(Const.getAccessName(i));\n            } else {\n                buf.append(String.format(\"ACC_BIT %x\", pow));\n            }\n        }\n        pow <<= 1;\n    }\n    return (buf.toString());\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a) {\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "get_constant_str",
                "plume",
                "BCELUtil",
                "/**\n * Returns the constant string at the specified offset.\n * @param pool the constant pool\n * @param index the index in the constant pool\n * @return the constant string at the specified offset in the constant pool\n */\npublic static String get_constant_str(ConstantPool pool, int index) {\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n        return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n        ConstantClass cc = (ConstantClass) c;\n        return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n        throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param mg the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n}"
            ],
            [
                "is_constructor",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a constructor.\n * @param m the method to test\n * @return true iff the method is a constructor\n */\npublic static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param mg the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "is_clinit",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the method is a class initializer.\n * @param m the method to test\n * @return true iff the method is a class initializer\n */\npublic static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param gen the class to test\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n}"
            ],
            [
                "in_jdk",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in the format of Class.getName();\n *   the class should not be an array\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk(/*@ClassGetName*/\nString classname) {\n    return classname.startsWith(\"java.\") || classname.startsWith(\"com.\") || classname.startsWith(\"javax.\") || classname.startsWith(\"org.\") || classname.startsWith(\"sun.\") || classname.startsWith(\"sunw.\");\n}"
            ],
            [
                "in_jdk_internalform",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the class is part of the JDK (rt.jar).\n * @param classname the class to test, in internal form\n * @return true iff the class is part of the JDK (rt.jar)\n */\npublic static boolean in_jdk_internalform(/*@InternalForm*/\nString classname) {\n    return classname.startsWith(\"java/\") || classname.startsWith(\"com/\") || classname.startsWith(\"javax/\") || classname.startsWith(\"org/\") || classname.startsWith(\"sun/\") || classname.startsWith(\"sunw/\");\n}"
            ],
            [
                "instruction_descr",
                "plume",
                "BCELUtil",
                "// TODO: write Javadoc\n@SuppressWarnings(\"rawtypes\")\npublic static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n        @SuppressWarnings(// BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n        \"nullness\")\n        InstructionHandle /*@NonNull*/\n        handle = (InstructionHandle) i.next();\n        out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n}"
            ],
            [
                "local_var_descr",
                "plume",
                "BCELUtil",
                "/**\n * Return a description of the local variables (one per line).\n * @param mg the method whose local variables to describe\n * @return a description of the local variables (one per line)\n */\npublic static String local_var_descr(MethodGen mg) {\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n        for (LocalVariableGen lvg : lvgs) {\n            out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n        }\n    }\n    return (out.toString());\n}"
            ],
            [
                "is_local_variable_type_table",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not the specified attribute is a local variable type\n * table.\n * @param a the attribute\n * @param pool the constant pool\n * @return true iff the attribute is a local variable type table\n */\npublic static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n}"
            ],
            [
                "get_attribute_name",
                "plume",
                "BCELUtil",
                "/**\n * Return the attribute name for the specified attribute.\n * @param a the attribute\n * @param pool the constant pool\n * @return the attribute name for the specified attribute\n */\npublic static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}"
            ],
            [
                "is_main",
                "plume",
                "BCELUtil",
                "/**\n * Returns whether or not this is a standard main method (static,\n * name is 'main', and one argument of string array).\n * @param mg the method to check\n * @return true iff the method is a main method\n */\npublic static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic() && mg.getName().equals(\"main\") && (arg_types.length == 1) && arg_types[0].equals(string_array));\n}"
            ],
            [
                "type_to_classgetname",
                "plume",
                "BCELUtil",
                "/**\n * Returns the Java class name, in the format of {@link Class#getName()},\n * that corresponds to type.\n * @param type the type\n * @return the Java classname that corresponds to type\n */\npublic static /*@ClassGetName*/\nString type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n}"
            ],
            [
                "type_to_class",
                "plume",
                "BCELUtil",
                "/**\n * Returns the class that corresponds to type.\n * @param type the type\n * @return the Java class that corresponds to type\n */\npublic static Class<?> type_to_class(Type type) {\n    String classname = type_to_classgetname(type);\n    try {\n        Class<?> c = UtilMDE.classForName(classname);\n        return c;\n    } catch (Exception e) {\n        throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n}"
            ],
            [
                "add_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type added to the end of types.\n * @param types the array to extend\n * @param new_type the element to add to the end of the types array\n * @return the array (or a new one), with new_type at the end\n */\npublic static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "insert_type",
                "plume",
                "BCELUtil",
                "/**\n * Returns a type array with new_type inserted at the beginning.\n * @param types the array to extend\n * @param new_type the element to add to the beginning of the types array\n * @return the array (or a new one), with new_type at the beginning\n */\npublic static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}"
            ],
            [
                "classname_to_type",
                "plume",
                "BCELUtil",
                "/**\n * Return the type corresponding to a given class name.\n * @param classname the class to convert to a type\n * @return the type corresponding to the given class name\n */\npublic static Type classname_to_type(String classname) {\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n        classname = classname.substring(0, classname.length() - 2);\n        array_depth++;\n    }\n    classname = classname.intern();\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") {\n        // interned\n        t = Type.INT;\n    } else if (classname == \"boolean\") {\n        // interned\n        t = Type.BOOLEAN;\n    } else if (classname == \"byte\") {\n        // interned\n        t = Type.BYTE;\n    } else if (classname == \"char\") {\n        // interned\n        t = Type.CHAR;\n    } else if (classname == \"double\") {\n        // interned\n        t = Type.DOUBLE;\n    } else if (classname == \"float\") {\n        // interned\n        t = Type.FLOAT;\n    } else if (classname == \"long\") {\n        // interned\n        t = Type.LONG;\n    } else if (classname == \"short\") {\n        // interned\n        t = Type.SHORT;\n    } else {\n        // must be a non-primitive\n        t = new ObjectType(classname);\n    }\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n        t = new ArrayType(t, array_depth);\n    }\n    return t;\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Array\n///\n// For arrays, see ArraysMDE.java.\n///////////////////////////////////////////////////////////////////////////\n/// BitSet\n///\n/**\n * Returns true if the cardinality of the intersection of the two\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b) >= i);\n}"
            ],
            [
                "intersectionCardinalityAtLeast",
                "plume",
                "UtilMDE",
                "/**\n * Returns true if the cardinality of the intersection of the three\n * BitSets is at least the given value.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @param i the cardinality bound\n * @return true iff size(a intersect b intersect c) &ge; i\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n        // The size is more than 10 times the limit.  So first try processing\n        // just a subset of the bits (4 times the limit).\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        intersection.and(c);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the two BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @return size(a intersect b)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n}"
            ],
            [
                "intersectionCardinality",
                "plume",
                "UtilMDE",
                "/**\n * Returns the cardinality of the intersection of the three BitSets.\n * @param a the first BitSet to intersect\n * @param b the second BitSet to intersect\n * @param c the third BitSet to intersect\n * @return size(a intersect b intersect c)\n */\n// side effect to local state (BitSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n}"
            ],
            [
                "fileInputStream",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// BufferedFileReader\n///\n// Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n/**\n * Returns an InputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStream for file\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            in = new GZIPInputStream(new FileInputStream(file));\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        in = new FileInputStream(file);\n    }\n    return in;\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return an InputStream for filename\n * @throws IOException if there is trouble reading the file\n * @throws FileNotFoundException if the file is not found\n */\npublic static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n}"
            ],
            [
                "fileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a Reader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName null, or the name of a Charset to use when reading the file\n * @return an InputStreamReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static InputStreamReader fileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibility-compressed file to read\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(String filename, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n}"
            ],
            [
                "bufferedFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @param charsetName the character set to use when reading the file\n * @return a BufferedReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static BufferedReader bufferedFileReader(File file, /*@Nullable*/\nString charsetName) throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to read\n * @return a LineNumberReader for filename\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n}"
            ],
            [
                "lineNumberFileReader",
                "plume",
                "UtilMDE",
                "/**\n * Returns a LineNumberReader for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param file the possibly-compressed file to read\n * @return a LineNumberReader for file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\npublic static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n}"
            ],
            [
                "bufferedFileWriter",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedWriter for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedWriter appends to the end\n * of the file instead of the beginning\n * @return a BufferedWriter for filename\n * @throws IOException if there is trouble writing the file\n */\n// Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\npublic static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n        file_writer = new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n        file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n}"
            ],
            [
                "bufferedFileOutputStream",
                "plume",
                "UtilMDE",
                "/**\n * Returns a BufferedOutputStream for the file, accounting for the possibility\n * that the file is compressed.\n * (A file whose name ends with \".gz\" is treated as compressed.)\n * <p>\n * Warning: The \"gzip\" program writes and reads files containing\n * concatenated gzip files.  As of Java 1.4, Java reads\n * just the first one:  it silently discards all characters (including\n * gzipped files) after the first gzipped file.\n * @param filename the possibly-compressed file to write\n * @param append if true, the resulting BufferedOutputStream appends to the end\n * of the file instead of the beginning\n * @return a BufferedOutputStream for filename\n * @throws IOException if there is trouble writing the file\n */\npublic static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}"
            ],
            [
                "isSubtype",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Class\n///\n/**\n * Return true iff sub is a subtype of sup.\n * If sub == sup, then sub is considered a subtype of sub and this method\n * returns true.\n * @param sub class to test for being a subtype\n * @param sup class to test for being a supertype\n * @return true iff sub is a subtype of sup\n */\n/*@Pure*/\npublic static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n        return true;\n    }\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n        return true;\n    }\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n        if (ifc == sup || isSubtype(ifc, sup)) {\n            return true;\n        }\n    }\n    return false;\n}"
            ],
            [
                "classForName",
                "plume",
                "UtilMDE",
                "/**\n * Like {@link Class#forName(String)}, but also works when the string\n * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n * <p>\n * If the given name can't be found, this method changes the last '.'  to\n * a dollar sign ($) and tries again.  This accounts for inner classes\n * that are incorrectly passed in in fully-qualified format instead of\n * binary format.\n * <p>\n * Recall the rather odd specification for {@link Class#forName(String)}:\n * the argument is a binary name for non-arrays, but a field descriptor\n * for arrays.  This method uses the same rules, but additionally handles\n * primitive types and, for non-arrays, fully-qualified names.\n * @param className name of the class\n * @return the Class corresponding to className\n * @throws ClassNotFoundException if the class is not found\n */\n// The annotation encourages proper use, even though this can take a\n// fully-qualified name (only for a non-array).\npublic static Class<?> classForName(/*@ClassGetName*/\nString className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n        return result;\n    } else {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            int pos = className.lastIndexOf('.');\n            if (pos < 0) {\n                throw e;\n            }\n            // checked below & exception is handled\n            @SuppressWarnings(\"signature\")\n            String /*@ClassGetName*/\n            inner_name = className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n            try {\n                return Class.forName(inner_name);\n            } catch (ClassNotFoundException ee) {\n                throw e;\n            }\n        }\n    }\n}"
            ],
            [
                "binaryNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a binary name to a field descriptor.\n * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n * or \"int\" to \"I\".\n * @param classname name of the class, in binary class name format\n * @return name of the class, in field descriptor format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@FieldDescriptor*/\nString binaryNameToFieldDescriptor(/*@BinaryName*/\nString classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n        dims++;\n        sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n        result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n        result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n}"
            ],
            [
                "primitiveTypeNameToFieldDescriptor",
                "plume",
                "UtilMDE",
                "/**\n * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n * a field descriptor (e.g., \"I\", \"D\", etc.).\n * @param primitive_name name of the type, in Java format\n * @return name of the type, in field descriptor format\n * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n */\npublic static /*@FieldDescriptor*/\nString primitiveTypeNameToFieldDescriptor(String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n        throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n}"
            ],
            [
                "binaryNameToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a BinaryName to the format of {@link Class#getName()}.\n * @param bn the binary name to convert\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString binaryNameToClassGetName(/*BinaryName*/\nString bn) {\n    if (bn.endsWith(\"[]\")) {\n        return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n        return bn;\n    }\n}"
            ],
            [
                "fieldDescriptorToClassGetName",
                "plume",
                "UtilMDE",
                "/**\n * Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n * @param fd the class, in field descriptor format\n * @return the class name, in Class.getName format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetName*/\nString fieldDescriptorToClassGetName(/*FieldDescriptor*/\nString fd) {\n    if (fd.startsWith(\"[\")) {\n        return fd.replace('/', '.');\n    } else {\n        return fieldDescriptorToBinaryName(fd);\n    }\n}"
            ],
            [
                "arglistToJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert a fully-qualified argument list from Java format to JVML format.\n * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n * @param arglist an argument list, in Java format\n * @return argument list, in JVML format\n */\npublic static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n        // substring\n        @SuppressWarnings(\"signature\")\n        String /*@BinaryName*/\n        arg = args_tokenizer.nextToken().trim();\n        result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n}"
            ],
            [
                "fieldDescriptorToBinaryName",
                "plume",
                "UtilMDE",
                "// does not convert \"V\" to \"void\".  Should it?\n/**\n * Convert a field descriptor to a binary name.\n * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n * or \"I\" to \"int\".\n * @param classname name of the type, in JVML format\n * @return name of the type, in Java format\n */\n// conversion routine\n@SuppressWarnings(\"signature\")\npublic static /*@BinaryName*/\nString fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n        throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n        dims++;\n        classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n        result = classname.substring(1, classname.length() - 1);\n    } else {\n        result = primitiveClassesFromJvm.get(classname);\n        if (result == null) {\n            throw new Error(\"Malformed base class: \" + classname);\n        }\n    }\n    for (int i = 0; i < dims; i++) {\n        result += \"[]\";\n    }\n    return result.replace('/', '.');\n}"
            ],
            [
                "arglistFromJvm",
                "plume",
                "UtilMDE",
                "/**\n * Convert an argument list from JVML format to Java format.\n * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n * @param arglist an argument list, in JVML format\n * @return argument list, in Java format\n */\npublic static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n        if (pos > 1) {\n            result += \", \";\n        }\n        int nonarray_pos = pos;\n        while (arglist.charAt(nonarray_pos) == '[') {\n            nonarray_pos++;\n        }\n        char c = arglist.charAt(nonarray_pos);\n        if (c == 'L') {\n            int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n            result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n            pos = semi_pos + 1;\n        } else {\n            String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n            if (maybe == null) {\n                // return null;\n                throw new Error(\"Malformed arglist: \" + arglist);\n            }\n            result += maybe;\n            pos = nonarray_pos + 1;\n        }\n    }\n    return result + \")\";\n}"
            ],
            [
                "defineClassFromFile",
                "plume",
                "UtilMDE",
                "/**\n * Converts the bytes in a file into an instance of class Class, and\n * resolves (links) the class.\n * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n * file name rather than an array of bytes as an argument, and also resolves\n * (links) the class.\n * @see ClassLoader#defineClass(String,byte[],int,int)\n * @param className the name of the class to define, or null if not known\n * @param pathname the pathname of a .class file\n * @return a Java Object corresponding to the Class defined in the .class file\n * @throws FileNotFoundException if the file cannot be found\n * @throws IOException if there is trouble reading the file\n */\n// Also throws UnsupportedClassVersionError and some other exceptions.\npublic static Class<?> defineClassFromFile(/*@BinaryName*/\nString className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n}"
            ],
            [
                "count_lines",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// File\n///\n/**\n * Count the number of lines in the specified file.\n * @param filename file whose size to count\n * @return number of lines in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n        while (reader.readLine() != null) {\n            count++;\n        }\n    }\n    return count;\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param filename the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n}"
            ],
            [
                "inferLineSeparator",
                "plume",
                "UtilMDE",
                "/**\n * Tries to infer the line separator used in a file.\n * @param file the file to infer a line separator from\n * @return the inferred line separator used in filename\n * @throws IOException if there is trouble reading the file\n */\npublic static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n        int unix = 0;\n        int dos = 0;\n        int mac = 0;\n        while (true) {\n            String s = r.readLine();\n            if (s == null) {\n                break;\n            }\n            if (s.endsWith(\"\\r\\n\")) {\n                dos++;\n            } else if (s.endsWith(\"\\r\")) {\n                mac++;\n            } else if (s.endsWith(\"\\n\")) {\n                unix++;\n            } else {\n                // This can happen only if the last line is not terminated.\n            }\n        }\n        if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n            return \"\\r\\n\";\n        }\n        if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n            return \"\\r\";\n        }\n        if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n            return \"\\n\";\n        }\n        // The two non-preferred line endings are tied and have more votes than\n        // the preferred line ending.  Give up and return the line separator\n        // for the system on which Java is currently running.\n        return lineSep;\n    }\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @return true iff the files have the same contents\n */\n/*@Pure*/\npublic static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n}"
            ],
            [
                "equalFiles",
                "plume",
                "UtilMDE",
                "/**\n * Return true iff the files have the same contents.\n * @param file1 first file to compare\n * @param file2 second file to compare\n * @param trimLines if true, call String.trim on each line before comparing\n * @return true iff the files have the same contents\n */\n// reads files, side effects local state\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2)) {\n        String line1 = reader1.readLine();\n        String line2 = reader2.readLine();\n        while (line1 != null && line2 != null) {\n            if (trimLines) {\n                line1 = line1.trim();\n                line2 = line2.trim();\n            }\n            if (!(line1.equals(line2))) {\n                return false;\n            }\n            line1 = reader1.readLine();\n            line2 = reader2.readLine();\n        }\n        if (line1 == null && line2 == null) {\n            return true;\n        }\n        return false;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}"
            ],
            [
                "canCreateAndWrite",
                "plume",
                "UtilMDE",
                "/**\n * Returns true\n *  if the file exists and is writable, or\n *  if the file can be created.\n * @param file the file to create and write\n * @return true iff the file can be created and written\n */\npublic static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n        return file.canWrite();\n    } else {\n        File directory = file.getParentFile();\n        if (directory == null) {\n            directory = new File(\".\");\n        }\n        // Does this test need \"directory.canRead()\" also?\n        return directory.canWrite();\n    }\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n}"
            ],
            [
                "createTempDir",
                "plume",
                "UtilMDE",
                "///\n/// Directories\n///\n/**\n * Creates an empty directory in the default temporary-file directory,\n * using the given prefix and suffix to generate its name. For example,\n * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n * someString is internally generated to ensure no temporary files of the\n * same name are generated.\n * @param prefix the prefix string to be used in generating the file's\n *  name; must be at least three characters long\n * @param suffix the suffix string to be used in generating the file's\n *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n *  An abstract pathname denoting a newly-created empty file\n * @return a File representing the newly-created temporary directory\n * @throws IllegalArgumentException If the prefix argument contains fewer\n *  than three characters\n * @throws IOException If a file could not be created\n * @throws SecurityException If a security manager exists and its\n *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n *  file to be created\n * @see java.io.File#createTempFile(String, String, File)\n */\npublic static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dirName and all its files.\n * @param dirName the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n}"
            ],
            [
                "deleteDir",
                "plume",
                "UtilMDE",
                "/**\n * Deletes the directory at dir and all its files.\n * @param dir the directory to delete\n * @return true if and only if the file or directory is successfully deleted; false otherwise\n */\npublic static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n        return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    return dir.delete();\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name file whose name to expand\n * @return file with expanded file\n */\npublic static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n        return new File(newname);\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "expandFilename",
                "plume",
                "UtilMDE",
                "/**\n * Does tilde expansion on a file name (to the user's home directory).\n * @param name filename to expand\n * @return expanded filename\n */\npublic static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n        return (name.replace(\"~\", userHome));\n    } else {\n        return name;\n    }\n}"
            ],
            [
                "java_source",
                "plume",
                "UtilMDE",
                "/**\n * Return a string version of the name that can be used in Java source.\n * On Windows, the file will return a backslash separated string.  Since\n * backslash is an escape character, it must be quoted itself inside\n * the string.\n * <p>\n * The current implementation presumes that backslashes don't appear\n * in filenames except as windows path separators.  That seems like a\n * reasonable assumption.\n *\n * @param name file to quote\n * @return a string version of the name that can be used in Java source\n */\npublic static String java_source(File name) {\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n}"
            ],
            [
                "readObject",
                "plume",
                "UtilMDE",
                "/**\n * Reads an Object from a File.\n * @param file the file from which to read\n * @return the object read from the file\n * @throws IOException if there is trouble reading the file\n * @throws ClassNotFoundException if the object's class cannot be found\n */\npublic static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            istream = new GZIPInputStream(istream);\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n}"
            ],
            [
                "readerContents",
                "plume",
                "UtilMDE",
                "/**\n * Reads the entire contents of the reader and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param r the Reader to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readerContents(Reader r) {\n    try {\n        StringBuilder contents = new StringBuilder();\n        int ch;\n        while ((ch = r.read()) != -1) {\n            contents.append((char) ch);\n        }\n        r.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n}"
            ],
            [
                "readFile",
                "plume",
                "UtilMDE",
                "// an alternate name would be \"fileContents\".\n/**\n * Reads the entire contents of the file and returns it as a string.\n * Any IOException encountered will be turned into an Error.\n * @param file the file to read\n * @return the entire contents of the reader, as a string\n */\npublic static String readFile(File file) {\n    try {\n        BufferedReader reader = UtilMDE.bufferedFileReader(file);\n        StringBuilder contents = new StringBuilder();\n        String line = reader.readLine();\n        while (line != null) {\n            contents.append(line);\n            // Note that this converts line terminators!\n            contents.append(lineSep);\n            line = reader.readLine();\n        }\n        reader.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Hashing\n///\n// In hashing, there are two separate issues.  First, one must convert\n// the input datum into an integer.  Then, one must transform the\n// resulting integer in a pseudorandom way so as to result in a number\n// that is far separated from other values that may have been near it to\n// begin with.  Often these two steps are combined, particularly if\n// one wishes to avoid creating too large an integer (losing information\n// off the top bits).\n// http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n//  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n//    h += (h<<3); h ^= (h>>11); h += (h<<15);\n//    is good.\n//  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n//  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n// In this part of the file, perhaps I will eventually write good hash\n// functions.  For now, write cheesy ones that primarily deal with the\n// first issue, transforming a data structure into a single number.  This\n// is also known as fingerprinting.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Double#hashCode()}.\n * @param x value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a) {\n    double result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(double[] a, double[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/// Don't define hash with int args; use the long versions instead.\n/**\n * Return a hash of the arguments.\n * Note that this differs from the result of {@link Long#hashCode()}.\n * But it doesn't map -1 and 0 to the same value.\n * @param l value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n        return (int) l;\n    }\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(long[] a, long[] b) {\n    return hash(hash(a), hash(b));\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a) {\n    return (a == null) ? 0 : a.hashCode();\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @param b value to be hashed\n * @param c value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString a, /*@Nullable*/\nString b, /*@Nullable*/\nString c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n}"
            ],
            [
                "hash",
                "plume",
                "UtilMDE",
                "/**\n * Return a hash of the arguments.\n * @param a value to be hashed\n * @return a hash of the arguments\n */\npublic static int hash(/*@Nullable*/\nString[] a) {\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + hash(a[i]);\n        }\n    }\n    return hash(result);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n}"
            ],
            [
                "randomElements",
                "plume",
                "UtilMDE",
                "/**\n * Return a List containing num_elts randomly chosen\n * elements from the iterator, or all the elements of the iterator if\n * there are fewer.  It examines every element of the iterator, but does\n * not keep them all in memory.\n * @param <T> type of the iterator elements\n * @param itor elements to be randomly selected from\n * @param num_elts number of elements to select\n * @param random the Random instance to use to make selections\n * @return list of num_elts elements from itor\n */\npublic static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n    while (itor.hasNext()) {\n        rs.accept(itor.next());\n    }\n    return rs.getValues();\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n}"
            ],
            [
                "incrementMap",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Map\n///\n// In Python, inlining this gave a 10x speed improvement.\n// Will the same be true for Java?\n/**\n * Increment the Integer which is indexed by key in the Map.\n * If the key isn't in the Map, it is added.\n * @param <T> type of keys in the map\n * @param m map to have one of its values incremented\n * @param key the key for the element whose value will be incremented\n * @param count how much to increment the value by\n * @return the old value, before it was incremented\n * @throws Error if the key is in the Map but maps to a non-Integer.\n */\npublic static <T> /*@Nullable*/\nInteger incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n        new_total = count;\n    } else {\n        new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n}"
            ],
            [
                "mapToString",
                "plume",
                "UtilMDE",
                "/**\n * Returns a multi-line string representation of a map.\n * @param <K> type of map keys\n * @param <V> type of map values\n * @param m map to be converted to a string\n * @return a multi-line string representation of m\n */\npublic static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @return a sorted version of m.keySet()\n */\npublic static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n}"
            ],
            [
                "sortedKeySet",
                "plume",
                "UtilMDE",
                "/**\n * Returns a sorted version of m.keySet().\n * @param <K> type of the map keys\n * @param <V> type of the map values\n * @param m a map whose keyset will be sorted\n * @param comparator the Comparator to use for sorting\n * @return a sorted version of m.keySet()\n */\npublic static <K, V> Collection</*@KeyFor(\"#1\")*/\nK> sortedKeySet(Map<K, V> m, Comparator<K> comparator) {\n    ArrayList<K> /*@KeyFor(\"#1\")*/\n    theKeys = new ArrayList</*@KeyFor(\"#1\")*/\n    K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a method signature, return the method.\n * Example calls are:\n * <pre>\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n * </pre>\n * @param method a method signature\n * @return the method corresponding to the given signature\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n        throw new Error(\"malformed method name should contain a period, open paren, and close paren: \" + method + \" <<\" + dotpos + \",\" + oparenpos + \",\" + cparenpos + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n        if (!Character.isWhitespace(method.charAt(i))) {\n            throw new Error(\"malformed method name should contain only whitespace following close paren\");\n        }\n    }\n    // throws exception if class does not exist\n    @SuppressWarnings(\"signature\")\n    String /*@BinaryNameForNonArray*/\n    classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n        String[] argnames;\n        if (all_argnames.equals(\"\")) {\n            argnames = new String[0];\n        } else {\n            argnames = split(all_argnames, ',');\n        }\n        /*@MonotonicNonNull*/\n        Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n        for (int i = 0; i < argnames.length; i++) {\n            String bnArgname = argnames[i].trim();\n            /*@ClassGetName*/\n            String cgnArgname = binaryNameToClassGetName(bnArgname);\n            argclasses_tmp[i] = classForName(cgnArgname);\n        }\n        @SuppressWarnings(\"cast\")\n        Class<?>[] argclasses_res = (Class<?>[]) argclasses_tmp;\n        argclasses = argclasses_res;\n        args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n}"
            ],
            [
                "methodForName",
                "plume",
                "UtilMDE",
                "/**\n * Given a class name and a method name in that class, return the method.\n * @param classname class in which to find the method\n * @param methodname the method name\n * @param params the parameters of the method\n * @return the method named classname.methodname with parameters params\n * @throws ClassNotFoundException if the class is not found\n * @throws NoSuchMethodException if the method is not found\n */\npublic static Method methodForName(/*@BinaryNameForNonArray*/\nString classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// ProcessBuilder\n///\n/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line\n * @return all the output of the command\n */\npublic static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n}"
            ],
            [
                "backticks",
                "plume",
                "UtilMDE",
                "/**\n * Execute the given command, and return all its output as a string.\n * @param command a command to execute on the command line, as a list of\n * strings (the command, then its arguments)\n * @return all the output of the command\n */\npublic static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n        Process p = pb.start();\n        @SuppressWarnings(// input stream is non-null because we didn't redirect the input stream\n        \"nullness\")\n        String output = UtilMDE.streamString(p.getInputStream());\n        return output;\n    } catch (IOException e) {\n        return \"IOException: \" + e.getMessage();\n    }\n}"
            ],
            [
                "propertyIsTrue",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Properties\n///\n/**\n * Determines whether a property has value \"true\", \"yes\", or \"1\".\n * @see Properties#getProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @return true iff the property has value \"true\", \"yes\", or \"1\"\n */\n// does not depend on object identity\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n        return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n}"
            ],
            [
                "appendProperty",
                "plume",
                "UtilMDE",
                "/**\n * Set the property to its previous value concatenated to the given value.\n * Return the previous value.\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to concatenate to the previous value of the property\n * @return the previous value of the property\n * @see Properties#getProperty\n * @see Properties#setProperty\n */\npublic static /*@Nullable*/\nString appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n}"
            ],
            [
                "setDefaultMaybe",
                "plume",
                "UtilMDE",
                "/**\n * Set the property only if it was not previously set.\n * @see Properties#getProperty\n * @see Properties#setProperty\n * @param p a Properties object in which to look up the property\n * @param key name of the property to look up\n * @param value value to set the property to, if it is not already set\n * @return the previous value of the property\n */\npublic static /*@Nullable*/\nString setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n        p.setProperty(key, value);\n    }\n    return currentValue;\n}"
            ],
            [
                "getPrivateField",
                "plume",
                "UtilMDE",
                "// TODO: set the field back to private after is is accessed.\n/**\n * Reads the given field, which may be private.\n * Leaves the field accessible.\n * Use with care!\n * @param o object in which to set the field\n * @param fieldName name of field to set\n * @return new value of field\n * @throws NoSuchFieldException if the field does not exist in the object\n */\npublic static /*@Nullable*/\nObject getPrivateField(Object o, String fieldName) throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) {\n        // Class is interned\n        // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n        try {\n            Field f = c.getDeclaredField(fieldName);\n            f.setAccessible(true);\n            return f.get(o);\n        } catch (IllegalAccessException e) {\n            System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n            throw new Error(\"This can't happen: \" + e);\n        } catch (NoSuchFieldException e) {\n            if (c.getSuperclass() == Object.class) {\n                // Class is interned\n                throw e;\n            }\n            // nothing to do; will now examine superclass\n        }\n        c = c.getSuperclass();\n        assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n}"
            ],
            [
                "getFromSet",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set\n///\n/**\n * Return the object in this set that is equal to key.\n * The Set abstraction doesn't provide this; it only provides \"contains\".\n * Returns null if the argument is null, or if it isn't in the set.\n * @param set a set in which to look up the value\n * @param key the value to look up in the set\n * @return the object in this set that is equal to key, or null\n */\npublic static /*@Nullable*/\nObject getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n        return null;\n    }\n    for (Object elt : set) {\n        if (key.equals(elt)) {\n            return elt;\n        }\n    }\n    return null;\n}"
            ],
            [
                "streamString",
                "plume",
                "UtilMDE",
                "/**\n * Return a String containing all the characters from the input stream.\n * @param is input stream to read\n * @return a String containing all the characters from the input stream\n */\npublic static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n}"
            ],
            [
                "replaceString",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// String\n///\n/**\n * Return a new string which is the text of target with all instances of\n * oldStr replaced by newStr.\n * @param target the string to do replacement in\n * @param oldStr the substring to replace\n * @param newStr the replacement\n * @return target with all instances of oldStr replaced by newStr\n */\npublic static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n        throw new IllegalArgumentException();\n    }\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n        result.append(target.substring(lastend, pos));\n        result.append(newStr);\n        lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter character.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, String delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "split",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings representing the characters between\n * successive instances of the delimiter String.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).\n * @see #split(String s, char delim)\n * @param s the string to split\n * @param delim delimiter to split the string on\n * @return array of length at least 1, containing s split on delimiter\n */\npublic static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n        throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(// Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    \"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new /*@NonNull*/\n    String[result_list.size()]);\n    return result;\n}"
            ],
            [
                "splitLines",
                "plume",
                "UtilMDE",
                "/**\n * Return an array of Strings, one for each line in the argument.\n * Always returns an array of length at least 1 (it might contain only the\n * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n * are supported.  Note that a string that ends with a line separator\n * will return an empty string as the last element of the array.\n * @see #split(String s, char delim)\n * @param s the string to split\n * @return an array of Strings, one for each line in the argument\n */\npublic static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the array elements, placing the\n * delimiter between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n        return \"\";\n    }\n    if (a.length == 1) {\n        return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n        sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see plume.ArraysMDE#toString(int[])\n * @param a array of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(Object... a) {\n    return join(a, lineSep);\n}"
            ],
            [
                "join",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * delimiter between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @param delim delimiter to place between printed representations\n * @return the concatenation of the string representations of the values, with the delimiter between\n */\npublic static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n        return \"\";\n    }\n    if (v.size() == 1) {\n        return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n        sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n}"
            ],
            [
                "joinLines",
                "plume",
                "UtilMDE",
                "/**\n * Concatenate the string representations of the objects, placing the\n * system-specific line separator between them.\n * @see java.util.AbstractCollection#toString()\n * @param v list of values to concatenate\n * @return the concatenation of the string representations of the values, each on its own line\n */\npublic static String joinLines(List<String> v) {\n    return join(v, lineSep);\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Escape \\, \", newline, and carriage-return characters in the\n * target as \\\\, \\\", \\n, and \\r; return a new string if any\n * modifications were necessary.  The intent is that by surrounding\n * the return value with double quote marks, the result will be a\n * Java string literal denoting the original string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        switch(c) {\n            case '\\\"':\n            case '\\\\':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append('\\\\');\n                post_esc = i;\n                break;\n            case // not lineSep\n            '\\n':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                // not lineSep\n                sb.append(\"\\\\n\");\n                post_esc = i + 1;\n                break;\n            case '\\r':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append(\"\\\\r\");\n                post_esc = i + 1;\n                break;\n            default:\n        }\n    }\n    if (sb.length() == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "escapeNonJava",
                "plume",
                "UtilMDE",
                "// The overhead of this is too high to call in escapeNonJava(String), so\n// it is inlined there.\n/**\n * Like {@link #escapeNonJava(String)}, but for a single character.\n * @param ch character to quote\n * @return quoted version och ch\n */\npublic static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch(c) {\n        case '\\\"':\n            return \"\\\\\\\"\";\n        case '\\\\':\n            return \"\\\\\\\\\";\n        case // not lineSep\n        '\\n':\n            // not lineSep\n            return \"\\\\n\";\n        case '\\r':\n            return \"\\\\r\";\n        default:\n            return new String(new char[] { c });\n    }\n}"
            ],
            [
                "escapeNonASCII",
                "plume",
                "UtilMDE",
                "/**\n * Escape unprintable characters in the target, following the usual\n * Java backslash conventions, so that the result is sure to be\n * printable ASCII.  Returns a new string.\n * @param orig string to quote\n * @return quoted version of orig\n */\npublic static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n}"
            ],
            [
                "unescapeNonJava",
                "plume",
                "UtilMDE",
                "/**\n * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n * one-character equivalents.  All other backslashes are removed\n * (for instance, octal/hex escape sequences are not turned into\n * their respective characters). This is the inverse operation of\n * escapeNonJava(). Previously known as unquote().\n * @param orig string to quoto\n * @return quoted version of orig\n */\npublic static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n        if (this_esc == orig.length() - 1) {\n            sb.append(orig.substring(post_esc, this_esc + 1));\n            post_esc = this_esc + 1;\n            break;\n        }\n        switch(orig.charAt(this_esc + 1)) {\n            case 'n':\n                sb.append(orig.substring(post_esc, this_esc));\n                // not lineSep\n                sb.append('\\n');\n                post_esc = this_esc + 2;\n                break;\n            case 'r':\n                sb.append(orig.substring(post_esc, this_esc));\n                sb.append('\\r');\n                post_esc = this_esc + 2;\n                break;\n            case '\\\\':\n                // This is not in the default case because the search would find\n                // the quoted backslash.  Here we incluce the first backslash in\n                // the output, but not the first.\n                sb.append(orig.substring(post_esc, this_esc + 1));\n                post_esc = this_esc + 2;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                sb.append(orig.substring(post_esc, this_esc));\n                char octal_char = 0;\n                int ii = this_esc + 1;\n                while (ii < orig.length()) {\n                    char ch = orig.charAt(ii++);\n                    if ((ch < '0') || (ch > '8')) {\n                        break;\n                    }\n                    octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n                }\n                sb.append(octal_char);\n                post_esc = ii - 1;\n                break;\n            default:\n                // In the default case, retain the character following the backslash,\n                // but discard the backslash itself.  \"\\*\" is just a one-character string.\n                sb.append(orig.substring(post_esc, this_esc));\n                post_esc = this_esc + 1;\n                break;\n        }\n        this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}"
            ],
            [
                "removeWhitespaceAround",
                "plume",
                "UtilMDE",
                "// Use the built-in String.trim()!\n// /** Return the string with all leading and trailing whitespace stripped. */\n// public static String trimWhitespace(String s) {\n//   int len = s.length();\n//   if (len == 0)\n//     return s;\n//   int first_non_ws = 0;\n//   int last_non_ws = len-1;\n//   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n//     first_non_ws++;\n//   if (first_non_ws == len)\n//     return \"\";\n//   while (Character.isWhitespace(s.charAt(last_non_ws)))\n//     last_non_ws--;\n//   if ((first_non_ws == 0) && (last_non_ws == len)) {\n//     return s;\n//   } else {\n//     return s.substring(first_non_ws, last_non_ws+1);\n//   }\n// }\n// // // Testing:\n// // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n// // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n// // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n// // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n/**\n * Remove all whitespace before or after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace abutting\n * @return version of arg, with whitespace abutting delimiter removed\n */\npublic static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n}"
            ],
            [
                "removeWhitespaceAfter",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace after instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace after\n * @return version of arg, with whitespace after delimiter removed\n */\npublic static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index + delim_len;\n        while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index++;\n        }\n        // if (non_ws_index == arg.length()) {\n        //   System.out.println(\"No nonspace character at end of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index + delim_len) {\n            arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n        }\n        delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n}"
            ],
            [
                "removeWhitespaceBefore",
                "plume",
                "UtilMDE",
                "/**\n * Remove all whitespace before instances of delimiter.\n * @param arg string to remove whitespace in\n * @param delimiter string to remove whitespace before\n * @return version of arg, with whitespace before delimiter removed\n */\npublic static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index - 1;\n        while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index--;\n        }\n        // if (non_ws_index == -1) {\n        //   System.out.println(\"No nonspace character at front of: \" + arg);\n        // } else {\n        //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n        // }\n        if (non_ws_index != delim_index - 1) {\n            arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n        }\n        delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n}"
            ],
            [
                "nplural",
                "plume",
                "UtilMDE",
                "/**\n * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n * @param n count of nouns\n * @param noun word being counted\n * @return noun, if n==1; otherwise, pluralization of noun\n */\npublic static String nplural(int n, String noun) {\n    if (n == 1) {\n        return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\") || noun.endsWith(\"s\") || noun.endsWith(\"sh\") || noun.endsWith(\"x\")) {\n        return n + \" \" + noun + \"es\";\n    } else {\n        return n + \" \" + noun + \"s\";\n    }\n}"
            ],
            [
                "lpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the left if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String lpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString() + s;\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Returns a string of the specified length, truncated if necessary,\n * and padded with spaces to the right if necessary.\n * @param s string to truncate or pad\n * @param length goal length\n * @return s truncated or padded to length characters\n */\npublic static String rpad(String s, int length) {\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    } else {\n        return s.substring(0, length);\n    }\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n * @param num int whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "rpad",
                "plume",
                "UtilMDE",
                "/**\n * Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n * @param num double whose string representation to truncate or pad\n * @param length goal length\n * @return a string representation of num truncated or padded to length characters\n */\npublic static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the character appears in the string.\n * @param s string to search in\n * @param ch character to search for\n * @return number of times the character appears in the string\n */\npublic static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "count",
                "plume",
                "UtilMDE",
                "/**\n * Return the number of times the second string appears in the first.\n * @param s string to search in\n * @param sub string to search for\n * @return number of times the substring appears in the string\n */\npublic static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// StringTokenizer\n///\n/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n * <p>\n * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n * (probably due to backward-compatibility).\n * @param str a string to be parsed\n * @param delim the delimiters\n * @param returnDelims flag indicating whether to return the delimiters as tokens\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n * @param str a string to be parsed\n * @param delim the delimiters\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n}"
            ],
            [
                "tokens",
                "plume",
                "UtilMDE",
                "/**\n * Return a Vector of the Strings returned by\n * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n * @param str a string to be parsed\n * @return vector of strings resulting from tokenization\n */\npublic static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n}"
            ],
            [
                "backTrace",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Throwable\n///\n/**\n * Return a String representation of the backtrace of the given Throwable.\n * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n * @param t the Throwable to obtain a backtrace of\n * @return a String representation of the backtrace of the given Throwable\n */\npublic static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n}"
            ],
            [
                "sortList",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Collections\n///\n/**\n * Return the sorted version of the list.  Does not alter the list.\n * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n * @return a sorted version of the list\n * @param <T> type of elements of the list\n * @param l a list to sort\n * @param c a sorted version of the list\n */\npublic static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n}"
            ],
            [
                "removeDuplicates",
                "plume",
                "UtilMDE",
                "// This should perhaps be named withoutDuplicates to emphasize that\n// it does not side-effect its argument.\n/**\n * Return a copy of the list with duplicates removed.\n * Retains the original order.\n * @param <T> type of elements of the list\n * @param l a list to remove duplicates from\n * @return a copy of the list with duplicates removed\n */\npublic static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n}"
            ],
            [
                "deepEquals",
                "plume",
                "UtilMDE",
                "/**\n * Determines deep equality for the elements.\n * <ul>\n * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n * <li>If both are lists, uses deepEquals recursively on each element.\n * <li>For other types, just uses equals() and does not recursively call this method.\n * </ul>\n * @param o1 first value to compare\n * @param o2 second value to comare\n * @return true iff o1 and o2 are deeply equal\n */\n// side effect to static field deepEqualsUnderway\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean deepEquals(/*@Nullable*/\nObject o1, /*@Nullable*/\nObject o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    // creates local state\n    @SuppressWarnings(\"purity\")\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n        return true;\n    }\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n        List<?> l1 = (List<?>) o1;\n        List<?> l2 = (List<?>) o2;\n        if (l1.size() != l2.size()) {\n            return false;\n        }\n        try {\n            deepEqualsUnderway.add(mypair);\n            for (int i = 0; i < l1.size(); i++) {\n                Object e1 = l1.get(i);\n                Object e2 = l2.get(i);\n                if (!deepEquals(e1, e2)) {\n                    return false;\n                }\n            }\n        } finally {\n            deepEqualsUnderway.remove(mypair);\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}"
            ],
            [
                "makeVector",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Vector\n///\n/**\n * Returns a vector containing the elements of the enumeration.\n * @param <T> type of the enumeration and vector elements\n * @param e an enumeration to convert to a Vector\n * @return a vector containing the elements of the enumeration\n */\npublic static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n        result.addElement(e.nextElement());\n    }\n    return result;\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "// Rather than writing something like VectorToStringArray, use\n//   v.toArray(new String[0])\n/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of the specified objects starting at index\n * start over dims dimensions, for dims &gt; 0.\n * <p>\n * For example, create_combinations (1, 0, {a, b, c}) returns:\n * <pre>\n *    {a}, {b}, {c}\n * </pre>\n * And create_combinations (2, 0, {a, b, c}) returns:\n * <pre>\n *    {a, a}, {a, b}, {a, c}\n *    {b, b}, {b, c},\n *    {c, c}\n * </pre>\n * @param <T> type of the input list elements, and type of the innermost output list elements\n * @param dims number of dimensions:  that is, size of each innermost list\n * @param start initial index\n * @param objs list of elements to\n * @return list of lists of length dims, each of which combines elements from objs\n */\npublic static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n    if (dims < 1) {\n        throw new IllegalArgumentException();\n    }\n    List<List<T>> results = new ArrayList<List<T>>();\n    for (int i = start; i < objs.size(); i++) {\n        if (dims == 1) {\n            List<T> simple = new ArrayList<T>();\n            simple.add(objs.get(i));\n            results.add(simple);\n        } else {\n            List<List<T>> combos = create_combinations(dims - 1, i, objs);\n            for (List<T> lt : combos) {\n                List<T> simple = new ArrayList<T>();\n                simple.add(objs.get(i));\n                simple.addAll(lt);\n                results.add(simple);\n            }\n        }\n    }\n    return (results);\n}"
            ],
            [
                "create_combinations",
                "plume",
                "UtilMDE",
                "/**\n * Returns a list of lists of each combination (with repetition, but\n * not permutations) of integers from start to cnt (inclusive) over\n * arity dimensions.\n * <p>\n * For example, create_combinations (1, 0, 2) returns:\n * <pre>\n *    {0}, {1}, {2}\n * </pre>\n * And create_combinations (2, 0, 2) returns:\n * <pre>\n *    {0, 0}, {0, 1}, {0, 2}\n *    {1, 1}  {1, 2},\n *    {2, 2}\n * </pre>\n * @param arity size of each innermost list\n * @param start initial value\n * @param cnt maximum element value\n * @return list of lists of length arity, each of which combines integers from start to cnt\n */\npublic static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n        results.add(new ArrayList<Integer>());\n        return (results);\n    }\n    for (int i = start; i <= cnt; i++) {\n        ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n        for (ArrayList<Integer> li : combos) {\n            ArrayList<Integer> simple = new ArrayList<Integer>();\n            simple.add(new Integer(i));\n            simple.addAll(li);\n            results.add(simple);\n        }\n    }\n    return (results);\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(/*@FullyQualifiedName*/\nString qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n}"
            ],
            [
                "fullyQualifiedNameToSimpleName",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified fully qualified name.  For example, if qualified_name\n * is java.lang.String, String will be returned.\n * @param qualified_name the fully-qualified name of a class\n * @return the simple unqualified name of the class\n */\n// TODO: does not follow the specification for inner classes (where the\n// type name should be empty), but I think this is more informative anyway.\n// string conversion\n@SuppressWarnings(\"signature\")\npublic static /*@ClassGetSimpleName*/\nString fullyQualifiedNameToSimpleName(/*@FullyQualifiedName*/\nString qualified_name) {\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n        return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n}"
            ],
            [
                "unqualified_name",
                "plume",
                "UtilMDE",
                "/**\n * Returns the simple unqualified class name that corresponds to the\n * specified class.  For example if qualified name of the class\n * is java.lang.String, String will be returned.\n *\n * @deprecated use {@link Class#getSimpleName()} instead.\n *\n * @param cls a class\n * @return the simple unqualified name of the class\n */\n@Deprecated\npublic static /*@ClassGetSimpleName*/\nString unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n}"
            ],
            [
                "abbreviateNumber",
                "plume",
                "UtilMDE",
                "/**\n * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n * of precision in the result (counting both sides of the decimal point).\n * @param val a numeric value\n * @return an abbreviated string representation of the value\n */\npublic static String abbreviateNumber(long val) {\n    double dval = (double) val;\n    String mag = \"\";\n    if (val < 1000) {\n        // nothing to do\n    } else if (val < 1000000) {\n        dval = val / 1000.0;\n        mag = \"K\";\n    } else if (val < 1000000000) {\n        dval = val / 1000000.0;\n        mag = \"M\";\n    } else {\n        dval = val / 1000000000.0;\n        mag = \"G\";\n    }\n    String precision = \"0\";\n    if (dval < 10) {\n        precision = \"2\";\n    } else if (dval < 100) {\n        precision = \"1\";\n    }\n    // format string computed from precision and mag\n    @SuppressWarnings(\"formatter\")\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeIntSet",
                "/**\n * Merges a list of LimitedSizeIntSet objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param max_values the maximum size for the returned LimitedSizeIntSet\n * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n * @return a LimitedSizeIntSet that merges the elements of slist\n */\npublic static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist) {\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ],
            [
                "of",
                "plume",
                "Triple",
                "/**\n * Factory method with short name and no need to name type parameters.\n * @param <A> type of first argument\n * @param <B> type of second argument\n * @param <C> type of third argument\n * @param a first argument\n * @param b second argument\n * @param c third argument\n * @return a triple of the values (a, b, c)\n */\npublic static <A, B, C> Triple<A, B, C> of(A a, B b, C c) {\n    return new Triple<A, B, C>(a, b, c);\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// min, max\n///\n// Could also add linear-time orderStatistics if I liked.\n/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int min(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long min(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double min(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer min(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long min(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() < result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min",
                "plume",
                "ArraysMDE",
                "/**\n * Return the smallest value in the array.\n * @param a an array\n * @return the smallest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double min(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int max(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long max(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static double max(double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Integer max(Integer[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    // to return a value actually in the array\n    Integer result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Long max(Long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() > result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "max",
                "plume",
                "ArraysMDE",
                "/**\n * Return the largest value in the array.\n * @param a an array\n * @return the largest value in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static Double max(Double[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    // to return a value actually in the array\n    Double result = a[0];\n    // for faster comparison\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int[] min_max(int[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] { result_min, result_max };\n}"
            ],
            [
                "min_max",
                "plume",
                "ArraysMDE",
                "/**\n * Return a two-element array containing the smallest and largest values in the array.\n * @param a an array\n * @return a two-element array containing the smallest and largest values in the array\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long[] min_max(long[] a) {\n    if (a.length == 0) {\n        // return null;\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] { result_min, result_max };\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static int element_range(int[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "element_range",
                "plume",
                "ArraysMDE",
                "/**\n * Return the difference between the smallest and largest array elements.\n * @param a an array\n * @return the difference between the smallest and largest array elements\n * @throws ArrayIndexOutOfBoundsException if the array has length 0\n */\npublic static long element_range(long[] a) {\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of integers.\n * @param a an array\n * @return the sum of an array of integers\n */\npublic static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of integers.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of integers\n */\npublic static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of an array of doubles.\n * @param a an array\n * @return the sum of an array of doubles\n */\npublic static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}"
            ],
            [
                "sum",
                "plume",
                "ArraysMDE",
                "/**\n * Returns the sum of all the elements of a 2d array of doubles.\n * @param a a 2d array\n * @return the sum of all the elements of a 2d array of doubles\n */\npublic static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf\n///\n/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> type of the elements of the array\n * @param a an array\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt) {\n    if (elt == null) {\n        return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using the equals method.\n * @param <T> the type of the elements\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static <T> int indexOf(T[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n *    Identical to List.indexOf, but included for completeness.\n * @param a a list\n * @param elt the element to search for\n * @return the first index whose element is equal to the specified element,\n *    or -1 if no such element is found in the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    return a.indexOf(elt);\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using the equals method.\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.List#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a.get(i))) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyNull*/\nObject[] a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt) {\n    for (int i = 0; i < a.size(); i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the list,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in that section of the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOfEq(List<? extends /*@PolyNull*/\nObject> a, /*@Nullable*/\nObject elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first occurrence of the given element in the array.\n * @param a an array\n * @param elt the element to search for\n * @param minindex first index at which to search\n * @param indexlimit first index at which not to search\n * @return the first index i containing the specified element,\n *    such that minindex &le; i &lt; indexlimit,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// indexOf, for finding subarrays\n///\n// This is analogous to Common Lisp's \"search\" function.\n// This implementation is very inefficient; I could use tricky Boyer-Moore\n// search techniques if I liked, but it's not worth it to me yet.\n/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n// The signature on this method is unnecessarily strict because it\n// requires that the component types be identical.  The signature should\n// be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n// @PolyAll qualifier does not yet take an argument.\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given array elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, /*@PolyAll*/\nObject[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if no such element is found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(/*@PolyAll*/\nObject[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using the equals method.\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if no such element is found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOfEq",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the list that matches the given list elementwise,\n *    testing for equality using == (not the equals method).\n * @param a a list\n * @param sub subsequence to search for\n * @return the first index at which the second list starts in the first list,\n *    or -1 if the element is not found in the list\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index at which the second array starts in the first array,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "indexOf",
                "plume",
                "ArraysMDE",
                "/**\n * Searches for the first subsequence of the array that matches the given array elementwise.\n * @param a an array\n * @param sub subsequence to search for\n * @return the first index containing the specified element,\n *    or -1 if the element is not found in the array\n * @see java.util.Vector#indexOf(java.lang.Object)\n * @see java.lang.String#indexOf(java.lang.String)\n */\n/*@Pure*/\npublic static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// mismatch\n///\n// This is analogous to Common Lisp's \"mismatch\" function.\n// Put it off until later; for now, use the simpler subarray function,\n// which is a specialization of mismatch,\n///////////////////////////////////////////////////////////////////////////\n/// subarray extraction\n///\n// Note that the second argument is a length, not an end position.\n// That's to avoid confusion over whether it would be the last included\n// index or the first non-included index.\n/**\n * Return a subarray of the given array.\n * @return a subarray of the given array\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n */\n/*@SideEffectFree*/\npublic static Object[] subarray(/*@PolyAll*/\nObject[] a, int startindex, int length) {\n    /*@PolyAll*/\n    Object[] result = new /*@PolyAll*/\n    Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a sublist of the given list.\n * @param <T> type of the elements\n * @param a the original list\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a sublist of the given list\n */\n/*@SideEffectFree*/\npublic static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static String[] subarray(/*@PolyAll*/\nString[] a, int startindex, int length) {\n    /*@PolyAll*/\n    String[] result = new /*@PolyAll*/\n    String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "subarray",
                "plume",
                "ArraysMDE",
                "/**\n * Return a subarray of the given array.\n * @param a the original array\n * @param startindex the first index to be included\n * @param length the number of elements to include (not an end index,\n *        to avoid confusion over whether it would be the last included\n *        index or the first non-included index)\n * @return a subarray of the given array\n */\n/*@SideEffectFree*/\npublic static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// subarray testing\n///\n/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, /*@PolyNull*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(/*@PolyAll*/\nObject[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, /*@PolyAll*/\nObject[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using the equals method.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return the first index at which the second array starts in the first array,\n *    or -1 if no such element is found in the array\n */\n/*@Pure*/\npublic static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarrayEq",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first,\n *    testing for equality using == (not the equals method).\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubarray",
                "plume",
                "ArraysMDE",
                "/**\n * Determines whether the second array is a subarray of the first,\n *    starting at the specified index of the first.\n * @param a an array\n * @param sub subsequence to search for\n * @param a_offset first index at which to search\n * @return true iff sub is a contiguous subarray of a\n */\n/*@Pure*/\npublic static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(T[] a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.length + b.size()];\n            System.arraycopy(a, 0, result, 0, a.length);\n            // System.arraycopy(b, 0, result, a.length, b.size());\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.length] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, T[] b) {\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.length];\n            // System.arraycopy(a, 0, result, 0, a.size());\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            System.arraycopy(b, 0, result, a.size(), b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param <T> the type of the sequence elements\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static <T> T[] concat(/*@Nullable*/\nList<T> a, /*@Nullable*/\nList<T> b) {\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new /*@MonotonicNonNull*/\n            Object[a.size() + b.size()];\n            // System.arraycopy(a, 0, result, 0, a.length);\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            // System.arraycopy(b, 0, result, a.length, b.length);\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.size()] = b.get(i);\n            }\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "// Note: PolyAll is not quite right.  Need to review.\n/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first array to concatenate\n * @param b the second array to concatenate\n * @return an array that concatenates the arguments\n */\npublic static String[] concat(/*@PolyAll*/\nString[] a, /*@PolyAll*/\nString[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new String[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            /*@PolyAll*/\n            String[] result = new String[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static byte[] concat(byte[] a, byte[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new byte[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            byte[] result = new byte[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static boolean[] concat(boolean[] a, boolean[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new boolean[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            boolean[] result = new boolean[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static char[] concat(char[] a, char[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new char[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            char[] result = new char[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static double[] concat(double[] a, double[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new double[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            double[] result = new double[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static float[] concat(float[] a, float[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new float[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            float[] result = new float[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static int[] concat(int[] a, int[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new int[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            int[] result = new int[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static long[] concat(long[] a, long[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new long[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            long[] result = new long[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "concat",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array that contains all the elements of both argument\n * arrays, in order.\n * Returns a new array unless one argument is null, in which case\n * it returns the other array.\n * @param a the first sequence to concatenate\n * @param b the second sequence to concatenate\n * @return an array that concatenates the arguments\n */\npublic static short[] concat(short[] a, short[] b) {\n    if (a == null) {\n        if (b == null) {\n            return new short[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            short[] result = new short[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Printing\n///\n// This should be extended to all types, when I get around to it.  The\n// methods are patterned after that of java.util.Vector (and use its\n// output format).\n/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@PolyAll*/\nObject[] a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, each element is quoted like a Java String.\n * @param a an array\n * @return a string representation of the array, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@PolyAll*/\nObject[] a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * Furthermore, if quoted is true, then each element is quoted like a Java String.\n * @param a an array\n * @param quoted whether to quote the array elements\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@PolyAll*/\nObject[] a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            if (quoted && a[i] instanceof String) {\n                String elt = (String) a[i];\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava(elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(a[i]);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toString(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, false);\n}"
            ],
            [
                "toStringQuoted",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @return a string representation of the collection, with the elements quoted\n * @see java.util.Vector#toString\n */\n/*@SideEffectFree*/\npublic static String toStringQuoted(/*@Nullable*/\nCollection<?> a) {\n    return toString(a, true);\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the collection.\n * The representation is patterned after that of java.util.Vector.\n * @param a a collection\n * @param quoted whether to quote the collection elements that are Java strings\n * @return a string representation of the list\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(/*@Nullable*/\nCollection<?> a, boolean quoted) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n        Iterator<?> itor = a.iterator();\n        sb.append(itor.next());\n        while (itor.hasNext()) {\n            sb.append(\", \");\n            Object elt = itor.next();\n            if (quoted && elt instanceof String) {\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava((String) elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(elt);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(int[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(long[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(double[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(float[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Return a string representation of the array.\n * The representation is patterned after that of java.util.Vector.\n * @param a an array\n * @return a string representation of the array\n * @see java.util.Vector#toString\n */\n// side effect to local state (string creation)\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(boolean[] a) {\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}"
            ],
            [
                "toString",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls the appropriate\n * toString() method.  Only call this method if obj is a boolean, double,\n * int, long, or Object array.\n * @param obj an array\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@SideEffectFree*/\nString toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n        return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n        return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n        return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n        return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n        return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n        return toString((List<?>) obj);\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "length",
                "plume",
                "ArraysMDE",
                "/**\n * Casts obj down to the proper array type then calls .length.\n * Only call this method if obj is a boolean, double, int, long, or Object array.\n * @param obj a list\n * @return a string representation of the array\n * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n */\n// defensive coding: throw exception when argument is invalid\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nint length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n        return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n        return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n        return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n        return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n        return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n        return ((List<?>) obj).size();\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Sortedness\n///\n/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted.\n * @param a an array\n * @return true iff the array is sorted\n */\n/*@Pure*/\npublic static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "sorted_descending",
                "plume",
                "ArraysMDE",
                "/**\n * Returns whether the array is sorted in desending order.\n * @param a an array\n * @return true iff the array is sorted in desending order\n */\n/*@Pure*/\npublic static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Boolean n = Boolean.valueOf(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Byte n = new Byte(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Float n = new Float(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Short n = new Short(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        Integer n = new Integer(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space. Equality checking\n * uses the .equals() method for java.lang.Double.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Double n = new Double(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n        // Could be optimized not to create the last element,\n        // but that would make the code much less readable.\n        Long n = new Long(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param a an array\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a[i]);\n    }\n    return true;\n}"
            ],
            [
                "noDuplicates",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff a does not contain duplicate elements,\n * using O(n) time and O(n) space.\n * @param <T> the type of the elements\n * @param a a list\n * @return true iff a does not contain duplicate elements\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static </*@Pure*/\nT> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n        if (hs.contains(a.get(i))) {\n            return false;\n        }\n        // Could be optimized not to add the last element,\n        // but that would make the code much less readable.\n        hs.add(a.get(i));\n    }\n    return true;\n}"
            ],
            [
                "fn_is_permutation",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Arrays as partial functions of int->int\n///\n/**\n * Returns true if the array is a permutation of [0..a.length).\n * @param a an array, representing a function\n * @return true iff all elements of a are in [0..a.length) and a\n * contains no duplicates.\n */\n// side effect to local state (array)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int n = a[i];\n        if (n < 0 || n >= a.length || see[n]) {\n            return false;\n        }\n        see[n] = true;\n    }\n    return true;\n}"
            ],
            [
                "fn_is_total",
                "plume",
                "ArraysMDE",
                "/**\n * Return true iff the array does not contain -1.\n * @param a an array, representing a function\n * @return true iff no element of a maps to -1\n */\n/*@Pure*/\npublic static boolean fn_is_total(int[] a) {\n    // not found\n    return indexOf(a, -1) == -1;\n}"
            ],
            [
                "fn_identity",
                "plume",
                "ArraysMDE",
                "/**\n * Return an array [0..lenth).\n * @param length the length of the result\n * @return fresh array that is the identity function of the given length\n */\npublic static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n        result[i] = i;\n    }\n    return result;\n}"
            ],
            [
                "fn_inverse_permutation",
                "plume",
                "ArraysMDE",
                "/**\n * Requires that fn_is_permutation(a) holds.\n * @param a the input permutation\n * @return fresh array which is the inverse of the given permutation\n * @see #fn_is_permutation(int[])\n */\npublic static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n}"
            ],
            [
                "fn_inverse",
                "plume",
                "ArraysMDE",
                "/**\n * Return the inverse of the given function, which is represented as an array.\n * @param a an array representing a function from [0..a.length) to [0..arange);\n *  each element of a is between 0 and arange inclusive\n * @param arange length of the argument's range and the result's domain\n * @return function from [0..arange) to [0..a.length) that is the inverse of a\n * @throws IllegalArgumentException if a value of a is outside of arange\n * @exception UnsupportedOperationException when the function is not invertible\n */\npublic static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n        int ai = a[i];\n        if (ai < -1 || ai >= arange) {\n            throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n        }\n        // ai is either -1 or a valid index\n        if (ai >= 0) {\n            if (result[ai] != -1) {\n                throw new UnsupportedOperationException(String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n            }\n            result[ai] = i;\n        }\n    }\n    return result;\n}"
            ],
            [
                "fn_compose",
                "plume",
                "ArraysMDE",
                "/**\n * Return the composition of the given two functions, all of which are\n * represented as arrays.\n * @param a function from [0..a.length) to [0..b.length)\n * @param b function from [0..b.length) to range R\n * @return function from [0..a.length) to range R that is the\n * composition of a and b\n */\npublic static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int inner = a[i];\n        if (inner == -1) {\n            result[i] = -1;\n        } else {\n            result[i] = b[inner];\n        }\n    }\n    return result;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Set operations, such as subset, unions, and intersections\n///\n// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Long(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Long elt = new Long(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Double(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Double elt = new Double(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "isSubset",
                "plume",
                "ArraysMDE",
                "// This implementation is O(n^2) when the smaller really is a subset, but\n// might be quicker when it is not.  Sorting both sets has (minimum\n// and maximum) running time of Theta(n log n).\n/**\n * Return whether smaller is a subset of bigger.  The implementation is to\n * use collections because we want to take advantage of HashSet's\n * constant time membership tests.\n * @param smaller first set to test\n * @param bigger second set to test\n * @return true iff smaller is a subset of bigger\n */\n// side effect to local state (HashSet)\n@SuppressWarnings(\"purity\")\npublic static /*@Pure*/\nboolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(bigger[i]);\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        if (!setBigger.contains(smaller[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// nullness\n///\n/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(/*@PolyAll*/\nObject[] a) {\n    if (a.length == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(/*@PolyAll*/\nObject[] a) {\n    for (int i = 0; i < a.length; i++) {\n        if (!(a[i] == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "any_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if a contains null.\n * @param a an array\n * @return true iff some element of a is null (false if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n        return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/\n    Object) null) >= 0;\n}"
            ],
            [
                "all_null",
                "plume",
                "ArraysMDE",
                "/**\n * Return true if all elements of a are null.\n * @param a an array\n * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n */\n/*@Pure*/\npublic static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n        if (!(a.get(i) == null)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "int_array_iterator",
                "plume",
                "TestPlume",
                "///////////////////////////////////////////////////////////////////////////\n/// Utility functions\n///\npublic static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n        asList.add(nums[i]);\n    }\n    return asList.iterator();\n}"
            ],
            [
                "int_iterator_array",
                "plume",
                "TestPlume",
                "public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    return v;\n}"
            ],
            [
                "toVector",
                "plume",
                "TestPlume",
                "public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n        v.add(e.nextElement());\n    }\n    return v;\n}"
            ],
            [
                "merge",
                "plume",
                "LimitedSizeSet",
                "/**\n * Merges a list of LimitedSizeSet&lt;T&gt; objects into a single object that\n * represents the values seen by the entire list.  Returns the new\n * object, whose max_values is the given integer.\n * @param <T> (super)type of elements of the sets\n * @param max_values the maximum size for the returned LimitedSizeSet\n * @param slist a list of LimitedSizeSet, whose elements will be merged\n * @return a LimitedSizeSet that merges the elements of slist\n */\npublic static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist) {\n    LimitedSizeSet<T> result = new LimitedSizeSet<T>(max_values);\n    for (LimitedSizeSet<? extends T> s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "serialVersionUID",
                "plume",
                "FileIOException",
                "static final long serialVersionUID = 20050923L;"
            ],
            [
                "counter",
                "plume",
                "DeterministicObject",
                "/**\n * The number of objects created so far.\n */\nstatic int counter = 0;"
            ],
            [
                "home",
                "plume",
                "MultiVersionControl",
                "@Option(value = \"User home directory\", noDocDefault = true)\npublic static String home = System.getProperty(\"user.home\");"
            ],
            [
                "debug",
                "plume",
                "MultiVersionControl",
                "// It would be good to be able to set this per-checkout.\n// This variable is static because it is used in static methods.\n@Option(\"Print debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "idf",
                "plume",
                "MultiVersionControl",
                "static IsDirectoryFilter idf = new IsDirectoryFilter();"
            ],
            [
                "help",
                "plume",
                "Lookup",
                "/**\n * Show detailed help information and exit.\n */\n@OptionGroup(\"Getting help\")\n@Option(\"-h Show detailed help information\")\npublic static boolean help = false;"
            ],
            [
                "verbose",
                "plume",
                "Lookup",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "entry_file",
                "plume",
                "Lookup",
                "// This uses only the first file because the default search path might be\n// something like user:system and you might want only your version of the\n// system files.  It might be useful to also support (via another flag,\n// or by taking over this one, or by the syntax of the separator, or in\n// some other way) specifying multiple files on the command line.\n/**\n * Specify the colon-separated search list for the file that contains\n * information to be searched.  Only the first file found is used, though\n * it may itself contain include directives.\n */\n@OptionGroup(\"Where to search\")\n@Option(\"-f Specify the colon-separated search list of files of information; may only be supplied once\")\npublic static String entry_file = \"~/lookup/root\";"
            ],
            [
                "search_body",
                "plume",
                "Lookup",
                "/**\n * Search the body of long entries in addition to the entry's\n * description.  The bodies of short entries are always searched.\n */\n@Option(\"-b Search body of long entries for matches\")\npublic static boolean search_body = false;"
            ],
            [
                "regular_expressions",
                "plume",
                "Lookup",
                "/**\n * Specifies that keywords are regular expressions.  If false, keywords\n * are text matches.\n */\n@OptionGroup(\"What to search for\")\n@Option(\"-e Keywords are regular expressions\")\npublic static boolean regular_expressions = false;"
            ],
            [
                "case_sensitive",
                "plume",
                "Lookup",
                "/**\n * If true, keywords matching is case sensistive.  By default, both\n * regular expressions and text keywords are case-insensitive.\n */\n@Option(\"-c Keywords are case sensistive\")\npublic static boolean case_sensitive = false;"
            ],
            [
                "word_match",
                "plume",
                "Lookup",
                "/**\n * If true, match a text keyword only as a separate word, not as a\n * substring of a word.  This option is ignored if\n * regular_expressions is true.\n */\n@Option(\"-w Only match text keywords against complete words\")\npublic static boolean word_match = false;"
            ],
            [
                "print_all",
                "plume",
                "Lookup",
                "/**\n * By default, if multiple entries are matched, only a synopsis\n * of each entry is printed.  If 'print_all' is selected then\n * the body of each matching entry is printed.\n */\n@OptionGroup(\"How to print matches\")\n@Option(\"-a Print the entire entry for each match\")\npublic static boolean print_all = false;"
            ],
            [
                "item_num",
                "plume",
                "Lookup",
                "/**\n * Specifies which item to print when there are multiple matches.\n * The index is 1-based; that is, it starts counting at 1.\n */\n@Option(\"-i Choose a specific item when there are multiple matches; index is 1-based\")\npublic static Integer /*@Nullable*/\nitem_num;"
            ],
            [
                "show_location",
                "plume",
                "Lookup",
                "/**\n * If true, show the filename/line number of each matching entry\n * in the output.\n */\n@Option(\"-l Show the location of each matching entry\")\npublic static boolean show_location = false;"
            ],
            [
                "entry_start_re",
                "plume",
                "Lookup",
                "@OptionGroup(\"Customizing format of files to be searched\")\n@Option(\"Regex that denotes the start of a long entry\")\npublic static Pattern /*@Regex(1)*/\nentry_start_re = Pattern.compile(\"^>entry *()\");"
            ],
            [
                "entry_stop_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that denotes the end of a long entry\")\npublic static Pattern entry_stop_re = Pattern.compile(\"^<entry\");"
            ],
            [
                "description_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that finds an entry's description (for long entries)\")\npublic static Pattern /*@Nullable*/\ndescription_re = null;"
            ],
            [
                "comment_re",
                "plume",
                "Lookup",
                "// If \"\", gets set to null immediately after option processing.\n@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Nullable*/\n/*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "Lookup",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "runtime",
                "plume",
                "FileCompiler",
                "/**\n * The Runtime of the JVM.\n */\npublic static Runtime runtime = java.lang.Runtime.getRuntime();"
            ],
            [
                "java_filename_pattern",
                "plume",
                "FileCompiler",
                "/**\n * Matches the names of Java source files.\n * Match group 1 is the complete filename.\n */\nstatic Pattern /*@Regex(1)*/\njava_filename_pattern;"
            ],
            [
                "responsible",
                "plume",
                "TaskManager",
                "// Command line options\n@Option(\"-r Include only those tasks assigned to the specified person\")\npublic static String /*@Nullable*/\nresponsible = null;"
            ],
            [
                "milestone",
                "plume",
                "TaskManager",
                "@Option(\"-m Include only those tasks required for the specified milestone\")\npublic static String /*@Nullable*/\nmilestone = null;"
            ],
            [
                "completed",
                "plume",
                "TaskManager",
                "@Option(\"-c Include only completed tasks\")\npublic static boolean completed = false;"
            ],
            [
                "open",
                "plume",
                "TaskManager",
                "@Option(\"-o Include only open tasks\")\npublic static boolean open = false;"
            ],
            [
                "verbose",
                "plume",
                "TaskManager",
                "@Option(\"-v Print progress information\")\npublic static boolean verbose = false;"
            ],
            [
                "format",
                "plume",
                "TaskManager",
                "@Option(\"-f Specify output format\")\npublic static OutputFormat format = OutputFormat.short_ascii;"
            ],
            [
                "comment_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an entire comment (not just a comment start)\")\npublic static String /*@Regex*/\ncomment_re = \"^%.*\";"
            ],
            [
                "include_re",
                "plume",
                "TaskManager",
                "@Option(\"Regex that matches an include directive; group 1 is the file name\")\npublic static String /*@Regex(1)*/\ninclude_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";"
            ],
            [
                "lineSep",
                "plume",
                "TaskManager",
                "// line.separator property is a legal regex\n@SuppressWarnings(\"regex\")\npublic static final String /*@Regex*/\nlineSep = System.getProperty(\"line.separator\");"
            ],
            [
                "minversion",
                "plume",
                "ClassFileVersion",
                "/**\n * Only report versions that are at least this large.\n */\nstatic double minversion = 0;"
            ],
            [
                "debug",
                "plume",
                "DeclarationAnnotations",
                "static boolean debug = false;"
            ],
            [
                "date",
                "plume",
                "ICalAvailable",
                "/// User options\n@Option(\"first date to summarize\")\npublic static String date = \"today\";"
            ],
            [
                "start_date",
                "plume",
                "ICalAvailable",
                "public static DateTime start_date = new DateTime();"
            ],
            [
                "days",
                "plume",
                "ICalAvailable",
                "@Option(\"number of calendar days to summarize\")\npublic static int days = 8;"
            ],
            [
                "iCal_URL",
                "plume",
                "ICalAvailable",
                "/**\n * For a Google calendar:  go to settings, then click on the green \"ICAL\"\n * icon for the \"private address\".\n */\n@Option(\"<url> schedule in iCal format\")\npublic static List<String> iCal_URL = new ArrayList<String>();"
            ],
            [
                "business_hours",
                "plume",
                "ICalAvailable",
                "/**\n * A list of time ranges, expressed as a String.\n * Example: 9am-5pm,7:30pm-9:30pm\n */\n@Option(\"time ranges during which appointments are permitted\")\npublic static String business_hours = \"9am-5pm\";"
            ],
            [
                "businessHours",
                "plume",
                "ICalAvailable",
                "// initialize to 9am-5pm\nstatic List<Period> businessHours = new ArrayList<Period>();"
            ],
            [
                "businessDays",
                "plume",
                "ICalAvailable",
                "// initialize to Mon-Fri\nstatic List<Integer> businessDays = new ArrayList<Integer>();"
            ],
            [
                "tzRegistry",
                "plume",
                "ICalAvailable",
                "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();"
            ],
            [
                "timezone1",
                "plume",
                "ICalAvailable",
                "/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * Available times are printed in this time zone.  It defaults to the\n * system time zone.\n */\n// don't need \"e.g.: America/New_York\" in message:  the default is an example\n@Option(value = \"<timezone> time zone, e.g.: America/New_York\", noDocDefault = true)\npublic static String timezone1 = TimeZone.getDefault().getID();"
            ],
            [
                "tz1",
                "plume",
                "ICalAvailable",
                "// Either of these initializations causes a NullPointerException\n// at net.fortuna.ical4j.model.TimeZone.<init>(TimeZone.java:67)\n// static TimeZone tz1 = new TimeZone(new VTimeZone());\n// static TimeZone tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));\nstatic TimeZone /*@MonotonicNonNull*/\ntz1;"
            ],
            [
                "timezone2",
                "plume",
                "ICalAvailable",
                "// If I'm outputting in a different timezone, then my notion of a \"day\"\n// may be different than the other timezone's notion of a \"day\".  This\n// doesn't seem important enough to fix right now.\n/**\n * Time zone as an Olson timezone ID, e.g.: America/New_York.\n * If set, then free times are printed in two time zones.\n */\n@Option(\"<timezone> optional second time zone, e.g.: America/New_York\")\npublic static String /*@Nullable*/\ntimezone2;"
            ],
            [
                "tz2",
                "plume",
                "ICalAvailable",
                "static TimeZone /*@Nullable*/\ntz2;"
            ],
            [
                "debug",
                "plume",
                "ICalAvailable",
                "/// Other variables\n@Option(\"enable debugging output\")\npublic static boolean debug = false;"
            ],
            [
                "calendars",
                "plume",
                "ICalAvailable",
                "/**\n * The appointments (the times that are unavailable for a meeting).\n */\nstatic List<Calendar> calendars = new ArrayList<Calendar>();"
            ],
            [
                "tf",
                "plume",
                "ICalAvailable",
                "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);"
            ],
            [
                "df",
                "plume",
                "ICalAvailable",
                "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);"
            ],
            [
                "dffull",
                "plume",
                "ICalAvailable",
                "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);"
            ],
            [
                "canonicalTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> canonicalTimezones = new HashMap<String, String>();"
            ],
            [
                "printedTimezones",
                "plume",
                "ICalAvailable",
                "static Map<String, String> printedTimezones = new HashMap<String, String>();"
            ],
            [
                "timeRegexp",
                "plume",
                "ICalAvailable",
                "static Pattern /*@Regex(4)*/\ntimeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");"
            ],
            [
                "dateFormats",
                "plume",
                "ICalAvailable",
                "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};"
            ],
            [
                "skip_checks",
                "plume",
                "BCELUtil",
                "/**\n * Controls whether the checks in checkMgen are actually performed.\n */\npublic static boolean skip_checks = false;"
            ],
            [
                "userHome",
                "plume",
                "UtilMDE",
                "static final String userHome = System.getProperty(\"user.home\");"
            ],
            [
                "args_seen",
                "plume",
                "UtilMDE",
                "///////////////////////////////////////////////////////////////////////////\n/// Method\n///\n/**\n * Maps from a comma-delimited string of arg types, such as appears in a\n * method signature, to an array of Class objects, one for each arg\n * type. Example keys include: \"java.lang.String, java.lang.String,\n * java.lang.Class[]\" and \"int,int\".\n */\nstatic HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();"
            ],
            [
                "serialVersionUID",
                "plume",
                "UtilMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "NullableStringComparator",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeIntSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "split_lists",
                "plume",
                "Options",
                "/**\n * When true, an argument to a option of list type is split, on\n * whitespace, into multiple arguments each of which is added to the\n * list.  When false, each argument to an option of list type is treated\n * as a single element, no matter what characters it contains.\n */\n@Option(\"Treat arguments to lists as space-separated.\")\npublic static boolean split_lists = false;"
            ],
            [
                "serialVersionUID",
                "plume",
                "Options",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArgException",
                "static final long serialVersionUID = 20051223L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ArraysMDE",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "StringArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "IntArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LongArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ComparableArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "ObjectArrayComparatorLengthFirst",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "short_run",
                "plume",
                "TestPlume",
                "// If true, do 100 instead of 100000 iterations when testing randomElements.\n// This saves only a little time.  However, it is significant when running\n// under instrumentation such as that of Chicory.\nstatic boolean short_run = false;"
            ],
            [
                "mass",
                "plume",
                "TestPlume",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestPlume",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestPlume",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestPlume",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestPlume",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestPlume",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestPlume",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "mass",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-m Set the mass\")\npublic static int mass;"
            ],
            [
                "x",
                "plume",
                "TestOptionGroups1",
                "@OptionGroup(\"Coordinate options\")\n@Option(\"-x Set the X coordinate\")\npublic static int x;"
            ],
            [
                "y",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-y Set the Y coordinate\")\npublic static int y;"
            ],
            [
                "z",
                "plume",
                "TestOptionGroups1",
                "@Option(\"-z Set the Z coordinate\")\npublic static int z;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(value = \"Internal options\", unpublicized = true)\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups2",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups2",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "help",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"General options\")\n@Option(value = \"-h Display help message\", aliases = { \"-help\" })\npublic static boolean help = false;"
            ],
            [
                "mu",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Internal options\")\n@Unpublicized\n@Option(\"Set mu\")\npublic static double mu = 4902.7;"
            ],
            [
                "pi",
                "plume",
                "TestOptionGroups3",
                "@Unpublicized\n@Option(\"Set pi\")\npublic static double pi = 3.14;"
            ],
            [
                "color",
                "plume",
                "TestOptionGroups3",
                "@OptionGroup(\"Display options\")\n@Option(value = \"Use colors\", aliases = { \"--colour\" })\npublic static boolean color = false;"
            ],
            [
                "firstPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the first compression pass\")\npublic static Compressor /*@Nullable*/\nfirstPass;"
            ],
            [
                "secondPass",
                "plume",
                "TestOptionsEnums",
                "@Option(\"Set the second compression pass\")\npublic static Compressor /*@Nullable*/\nsecondPass;"
            ],
            [
                "serialVersionUID",
                "plume",
                "LimitedSizeSet",
                "// We are Serializable, so we specify a version to allow changes to\n// method signatures without breaking serialization.  If you add or\n// remove fields, you should change this number to the current date.\nstatic final long serialVersionUID = 20031021L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "FuzzyFloat",
                "static final long serialVersionUID = 20150812L;"
            ],
            [
                "serialVersionUID",
                "plume",
                "DoubleArrayComparatorLexical",
                "static final long serialVersionUID = 20150812L;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "nums",
                "java.util.Iterator",
                "Iterator<Long>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hasNext",
                "java.util",
                "Iterator",
                "public abstract boolean hasNext()"
            ],
            [
                "next",
                "java.util",
                "Iterator",
                "public abstract E next()"
            ],
            [
                "equals",
                "",
                "long[]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "long[]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "long[]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "long[]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "long[]",
                "public T[] clone();"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "length",
                "",
                "long[]",
                "public final int length;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]