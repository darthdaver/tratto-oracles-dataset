[
    {
        "id": 26542,
        "oracle": "maxSize >= 0;",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg",
        "className": "RankingPathElementList",
        "javadocTag": "@param maxSize maximum number of paths the list is able to store.",
        "methodJavadoc": "    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param prevPathElementList paths, list of <code>\n     * RankingPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     * @param maxSize maximum number of paths the list is able to store.\n     */",
        "methodSourceCode": "RankingPathElementList(Graph<V, E> graph, int maxSize, RankingPathElementList<V, E> elementList, E edge, V guardVertexToNotDisconnect){\n    super(graph, maxSize, elementList, edge);\n    this.guardVertexToNotDisconnect = guardVertexToNotDisconnect;\n    // loop over the path elements in increasing order of weight.\n    for (int i = 0; (i < elementList.size()) && (size() < maxSize); i++) {\n        RankingPathElement<V, E> prevPathElement = elementList.get(i);\n        if (isNotValidPath(prevPathElement, edge)) {\n            // go to the next path element in the loop\n            continue;\n        }\n        double weight = calculatePathWeight(prevPathElement, edge);\n        RankingPathElement<V, E> newPathElement = new RankingPathElement<V, E>(this.graph, prevPathElement, edge, weight);\n        // the new path is inserted at the end of the list.\n        this.pathElements.add(newPathElement);\n    }\n}",
        "classJavadoc": "/**\n * List of simple paths in increasing order of weight.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * RankingPathElementList.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * List of simple paths in increasing order of weight.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\nfinal class RankingPathElementList<V, E>\n    extends AbstractPathElementList<V, E, RankingPathElement<V, E>>\n{\n    /**\n     * Vertex that paths of the list must not disconnect.\n     */\n    private V guardVertexToNotDisconnect = null;\n\n    private Map<RankingPathElement<V, E>, Boolean> path2disconnect =\n        new HashMap<RankingPathElement<V, E>, Boolean>();\n\n    /**\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize max number of paths the list is able to store.\n     */\n    RankingPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        RankingPathElement<V, E> pathElement)\n    {\n        super(graph, maxSize, pathElement);\n    }\n\n    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param prevPathElementList paths, list of <code>\n     * RankingPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     * @param maxSize maximum number of paths the list is able to store.\n     */\n    RankingPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        RankingPathElementList<V, E> elementList,\n        E edge)\n    {\n        this(graph, maxSize, elementList, edge, null);\n\n        assert (!this.pathElements.isEmpty());\n    }\n\n    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param prevPathElementList paths, list of <code>\n     * RankingPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     * @param maxSize maximum number of paths the list is able to store.\n     */\n    RankingPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        RankingPathElementList<V, E> elementList,\n        E edge,\n        V guardVertexToNotDisconnect)\n    {\n        super(graph, maxSize, elementList, edge);\n        this.guardVertexToNotDisconnect = guardVertexToNotDisconnect;\n\n        // loop over the path elements in increasing order of weight.\n        for (int i = 0; (i < elementList.size()) && (size() < maxSize); i++) {\n            RankingPathElement<V, E> prevPathElement = elementList.get(i);\n\n            if (isNotValidPath(prevPathElement, edge)) {\n                // go to the next path element in the loop\n                continue;\n            }\n\n            double weight = calculatePathWeight(prevPathElement, edge);\n            RankingPathElement<V, E> newPathElement =\n                new RankingPathElement<V, E>(\n                    this.graph,\n                    prevPathElement,\n                    edge,\n                    weight);\n\n            // the new path is inserted at the end of the list.\n            this.pathElements.add(newPathElement);\n        }\n    }\n\n    /**\n     * Creates an empty list. The list size is 0.\n     *\n     * @param maxSize max number of paths the list is able to store.\n     */\n    RankingPathElementList(Graph<V, E> graph, int maxSize, V vertex)\n    {\n        super(graph, maxSize, vertex);\n    }\n\n    /**\n     * <p>Adds paths in the list at vertex y. Candidate paths are obtained by\n     * concatenating the specified edge (v->y) to the paths <code>\n     * elementList</code> at vertex v.</p>\n     *\n     * Complexity =\n     *\n     * <ul>\n     * <li>w/o guard-vertex: O(<code>k*np</code>) where <code>k</code> is the\n     * max size limit of the list and <code>np</code> is the maximum number of\n     * vertices in the paths stored in the list</li>\n     * <li>with guard-vertex: O(<code>k*(m+n)</code>) where <code>k</code> is\n     * the max size limit of the list, <code>m</code> is the number of edges of\n     * the graph and <code>n</code> is the number of vertices of the graph,\n     * O(<code>m+n</code>) being the complexity of the <code>\n     * ConnectivityInspector</code> to check whether a path exists towards the\n     * guard-vertex</li>\n     * </ul>\n     *\n     * @param elementList list of paths at vertex v.\n     * @param edge edge (v->y).\n     *\n     * @return <code>true</code> if at least one path has been added in the\n     * list, <code>false</code> otherwise.\n     */\n    public boolean addPathElements(\n        RankingPathElementList<V, E> elementList,\n        E edge)\n    {\n        assert (this.vertex.equals(\n            Graphs.getOppositeVertex(\n                this.graph,\n                edge,\n                elementList.getVertex())));\n\n        boolean pathAdded = false;\n\n        // loop over the paths elements of the list at vertex v.\n        for (\n            int vIndex = 0, yIndex = 0;\n            vIndex < elementList.size();\n            vIndex++)\n        {\n            RankingPathElement<V, E> prevPathElement = elementList.get(vIndex);\n\n            if (isNotValidPath(prevPathElement, edge)) {\n                // checks if path is simple and if guard-vertex is not\n                // disconnected.\n                continue;\n            }\n            double newPathWeight = calculatePathWeight(prevPathElement, edge);\n            RankingPathElement<V, E> newPathElement =\n                new RankingPathElement<V, E>(\n                    this.graph,\n                    prevPathElement,\n                    edge,\n                    newPathWeight);\n\n            // loop over the paths of the list at vertex y from yIndex to the\n            // end.\n            RankingPathElement<V, E> yPathElement = null;\n            for (; yIndex < size(); yIndex++) {\n                yPathElement = get(yIndex);\n\n                // case when the new path is shorter than the path Py stored at\n                // index y\n                if (newPathWeight < yPathElement.getWeight()) {\n                    this.pathElements.add(yIndex, newPathElement);\n                    pathAdded = true;\n\n                    // ensures max size limit is not exceeded.\n                    if (size() > this.maxSize) {\n                        this.pathElements.remove(this.maxSize);\n                    }\n                    break;\n                }\n\n                // case when the new path is of the same length as the path Py\n                // stored at index y\n                if (newPathWeight == yPathElement.getWeight()) {\n                    this.pathElements.add(yIndex + 1, newPathElement);\n                    pathAdded = true;\n\n                    // ensures max size limit is not exceeded.\n                    if (size() > this.maxSize) {\n                        this.pathElements.remove(this.maxSize);\n                    }\n                    break;\n                }\n            }\n\n            // case when the new path is longer than the longest path in the\n            // list (Py stored at the last index y)\n            if (newPathWeight > yPathElement.getWeight()) {\n                // ensures max size limit is not exceeded.\n                if (size() < this.maxSize) {\n                    // the new path is inserted at the end of the list.\n                    this.pathElements.add(newPathElement);\n                    pathAdded = true;\n                } else {\n                    // max size limit is reached -> end of the loop over the\n                    // paths elements of the list at vertex v.\n                    break;\n                }\n            }\n        }\n\n        return pathAdded;\n    }\n\n    /**\n     * @return list of <code>RankingPathElement</code>.\n     */\n    List<RankingPathElement<V, E>> getPathElements()\n    {\n        return this.pathElements;\n    }\n\n    /**\n     * Costs taken into account are the weights stored in <code>Edge</code>\n     * objects.\n     *\n     * @param pathElement\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the cost obtained by concatenation.\n     *\n     * @see Graph#getEdgeWeight(E)\n     */\n    private double calculatePathWeight(\n        RankingPathElement<V, E> pathElement,\n        E edge)\n    {\n        double pathWeight = this.graph.getEdgeWeight(edge);\n\n        // otherwise it's the start vertex.\n        if ((pathElement.getPrevEdge() != null)) {\n            pathWeight += pathElement.getWeight();\n        }\n\n        return pathWeight;\n    }\n\n    /**\n     * Ensures that paths of the list do not disconnect the guard-vertex.\n     *\n     * @return <code>true</code> if the specified path element disconnects the\n     * guard-vertex, <code>false</code> otherwise.\n     */\n    private boolean isGuardVertexDisconnected(\n        RankingPathElement<V, E> prevPathElement)\n    {\n        if (this.guardVertexToNotDisconnect == null) {\n            return false;\n        }\n\n        if (this.path2disconnect.containsKey(prevPathElement)) {\n            return this.path2disconnect.get(prevPathElement);\n        }\n\n        ConnectivityInspector<V, E> connectivityInspector;\n        MaskFunctor<V, E> connectivityMask;\n\n        if (this.graph instanceof DirectedGraph<?, ?>) {\n            connectivityMask = new PathMask<V, E>(prevPathElement);\n            DirectedMaskSubgraph<V, E> connectivityGraph =\n                new DirectedMaskSubgraph<V, E>(\n                    (DirectedGraph<V, E>) this.graph,\n                    connectivityMask);\n            connectivityInspector =\n                new ConnectivityInspector<V, E>(\n                    connectivityGraph);\n        } else {\n            connectivityMask = new PathMask<V, E>(prevPathElement);\n            UndirectedMaskSubgraph<V, E> connectivityGraph =\n                new UndirectedMaskSubgraph<V, E>(\n                    (UndirectedGraph<V, E>) this.graph,\n                    connectivityMask);\n            connectivityInspector =\n                new ConnectivityInspector<V, E>(\n                    connectivityGraph);\n        }\n\n        if (connectivityMask.isVertexMasked(this.guardVertexToNotDisconnect)) {\n            // the guard-vertex was already in the path element -> invalid path\n            this.path2disconnect.put(prevPathElement, true);\n            return true;\n        }\n\n        if (!connectivityInspector.pathExists(\n                this.vertex,\n                this.guardVertexToNotDisconnect))\n        {\n            this.path2disconnect.put(prevPathElement, true);\n            return true;\n        }\n\n        this.path2disconnect.put(prevPathElement, false);\n        return false;\n    }\n\n    private boolean isNotValidPath(\n        RankingPathElement<V, E> prevPathElement,\n        E edge)\n    {\n        return !isSimplePath(prevPathElement, edge)\n            || isGuardVertexDisconnected(prevPathElement);\n    }\n\n    /**\n     * Ensures that paths of the list are simple (check that the vertex was not\n     * already in the path element).\n     *\n     * @param prevPathElement\n     * @param edge\n     *\n     * @return <code>true</code> if the resulting path (obtained by\n     * concatenating the specified edge to the specified path) is simple, <code>\n     * false</code> otherwise.\n     */\n    private boolean isSimplePath(\n        RankingPathElement<V, E> prevPathElement,\n        E edge)\n    {\n        V endVertex =\n            Graphs.getOppositeVertex(\n                this.graph,\n                edge,\n                prevPathElement.getVertex());\n        assert (endVertex.equals(this.vertex));\n\n        RankingPathElement<V, E> pathElementToTest = prevPathElement;\n        do {\n            if (pathElementToTest.getVertex().equals(endVertex)) {\n                return false;\n            } else {\n                pathElementToTest = pathElementToTest.getPrevPathElement();\n            }\n        } while (pathElementToTest != null);\n\n        return true;\n    }\n\n    private static class PathMask<V, E>\n        implements MaskFunctor<V, E>\n    {\n        private Set<E> maskedEdges;\n\n        private Set<V> maskedVertices;\n\n        /**\n         * Creates a mask for all the edges and the vertices of the path\n         * (including the 2 extremity vertices).\n         *\n         * @param pathElement\n         */\n        PathMask(RankingPathElement<V, E> pathElement)\n        {\n            this.maskedEdges = new HashSet<E>();\n            this.maskedVertices = new HashSet<V>();\n\n            while (pathElement.getPrevEdge() != null) {\n                this.maskedEdges.add(pathElement.getPrevEdge());\n                this.maskedVertices.add(pathElement.getVertex());\n                pathElement = pathElement.getPrevPathElement();\n            }\n            this.maskedVertices.add(pathElement.getVertex());\n        }\n\n        // implement MaskFunctor\n        @Override public boolean isEdgeMasked(E edge)\n        {\n            return this.maskedEdges.contains(edge);\n        }\n\n        // implement MaskFunctor\n        @Override public boolean isVertexMasked(V vertex)\n        {\n            return this.maskedVertices.contains(vertex);\n        }\n    }\n}\n\n// End RankingPathElementList.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "graph",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "maxSize",
                "",
                "int"
            ],
            [
                "elementList",
                "org.jgrapht.alg.RankingPathElementList",
                "RankingPathElementList<V, E>"
            ],
            [
                "edge",
                "",
                "E"
            ],
            [
                "guardVertexToNotDisconnect",
                "",
                "V"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "size",
                "org.jgrapht.alg",
                "AbstractPathElementList",
                "public int size()"
            ],
            [
                "contains",
                "java.util",
                "AbstractCollection",
                "public boolean contains(Object arg0)"
            ],
            [
                "get",
                "org.jgrapht.alg",
                "AbstractPathElementList",
                "public T get(int arg0)"
            ],
            [
                "removeAll",
                "java.util",
                "AbstractCollection",
                "public boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "retainAll",
                "java.util",
                "AbstractCollection",
                "public boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "listIterator",
                "java.util",
                "AbstractList",
                "public ListIterator<E> listIterator()"
            ],
            [
                "remove",
                "java.util",
                "AbstractCollection",
                "public boolean remove(Object arg0)"
            ],
            [
                "indexOf",
                "java.util",
                "AbstractList",
                "public int indexOf(Object arg0)"
            ],
            [
                "removeIf",
                "java.util",
                "Collection",
                "public default boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "add",
                "java.util",
                "AbstractList",
                "public boolean add(E arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "containsAll",
                "java.util",
                "AbstractCollection",
                "public boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "isEmpty",
                "java.util",
                "AbstractCollection",
                "public boolean isEmpty()"
            ],
            [
                "subList",
                "java.util",
                "AbstractList",
                "public List<E> subList(int arg0, int arg1)"
            ],
            [
                "set",
                "java.util",
                "AbstractList",
                "public E set(int arg0, E arg1)"
            ],
            [
                "addAll",
                "java.util",
                "AbstractList",
                "public boolean addAll(int arg0, Collection<? extends E> arg1)"
            ],
            [
                "addAll",
                "java.util",
                "AbstractCollection",
                "public boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "getVertex",
                "org.jgrapht.alg",
                "AbstractPathElementList",
                "public V getVertex()"
            ],
            [
                "equals",
                "java.util",
                "AbstractList",
                "public boolean equals(Object arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "AbstractList",
                "public ListIterator<E> listIterator(int arg0)"
            ],
            [
                "get",
                "java.util",
                "AbstractList",
                "public abstract E get(int arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "AbstractList",
                "public int hashCode()"
            ],
            [
                "getPathElements",
                "org.jgrapht.alg",
                "RankingPathElementList",
                "/**\n * @return list of <code>RankingPathElement</code>.\n */\nList<RankingPathElement<V, E>> getPathElements() {\n    return this.pathElements;\n}"
            ],
            [
                "iterator",
                "java.util",
                "AbstractList",
                "public Iterator<E> iterator()"
            ],
            [
                "toArray",
                "java.util",
                "AbstractCollection",
                "public Object[] toArray()"
            ],
            [
                "lastIndexOf",
                "java.util",
                "AbstractList",
                "public int lastIndexOf(Object arg0)"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "addPathElements",
                "org.jgrapht.alg",
                "RankingPathElementList",
                "/**\n * <p>Adds paths in the list at vertex y. Candidate paths are obtained by\n * concatenating the specified edge (v->y) to the paths <code>\n * elementList</code> at vertex v.</p>\n *\n * Complexity =\n *\n * <ul>\n * <li>w/o guard-vertex: O(<code>k*np</code>) where <code>k</code> is the\n * max size limit of the list and <code>np</code> is the maximum number of\n * vertices in the paths stored in the list</li>\n * <li>with guard-vertex: O(<code>k*(m+n)</code>) where <code>k</code> is\n * the max size limit of the list, <code>m</code> is the number of edges of\n * the graph and <code>n</code> is the number of vertices of the graph,\n * O(<code>m+n</code>) being the complexity of the <code>\n * ConnectivityInspector</code> to check whether a path exists towards the\n * guard-vertex</li>\n * </ul>\n *\n * @param elementList list of paths at vertex v.\n * @param edge edge (v->y).\n *\n * @return <code>true</code> if at least one path has been added in the\n * list, <code>false</code> otherwise.\n */\npublic boolean addPathElements(RankingPathElementList<V, E> elementList, E edge) {\n    assert (this.vertex.equals(Graphs.getOppositeVertex(this.graph, edge, elementList.getVertex())));\n    boolean pathAdded = false;\n    // loop over the paths elements of the list at vertex v.\n    for (int vIndex = 0, yIndex = 0; vIndex < elementList.size(); vIndex++) {\n        RankingPathElement<V, E> prevPathElement = elementList.get(vIndex);\n        if (isNotValidPath(prevPathElement, edge)) {\n            // checks if path is simple and if guard-vertex is not\n            // disconnected.\n            continue;\n        }\n        double newPathWeight = calculatePathWeight(prevPathElement, edge);\n        RankingPathElement<V, E> newPathElement = new RankingPathElement<V, E>(this.graph, prevPathElement, edge, newPathWeight);\n        // loop over the paths of the list at vertex y from yIndex to the\n        // end.\n        RankingPathElement<V, E> yPathElement = null;\n        for (; yIndex < size(); yIndex++) {\n            yPathElement = get(yIndex);\n            // case when the new path is shorter than the path Py stored at\n            // index y\n            if (newPathWeight < yPathElement.getWeight()) {\n                this.pathElements.add(yIndex, newPathElement);\n                pathAdded = true;\n                // ensures max size limit is not exceeded.\n                if (size() > this.maxSize) {\n                    this.pathElements.remove(this.maxSize);\n                }\n                break;\n            }\n            // case when the new path is of the same length as the path Py\n            // stored at index y\n            if (newPathWeight == yPathElement.getWeight()) {\n                this.pathElements.add(yIndex + 1, newPathElement);\n                pathAdded = true;\n                // ensures max size limit is not exceeded.\n                if (size() > this.maxSize) {\n                    this.pathElements.remove(this.maxSize);\n                }\n                break;\n            }\n        }\n        // case when the new path is longer than the longest path in the\n        // list (Py stored at the last index y)\n        if (newPathWeight > yPathElement.getWeight()) {\n            // ensures max size limit is not exceeded.\n            if (size() < this.maxSize) {\n                // the new path is inserted at the end of the list.\n                this.pathElements.add(newPathElement);\n                pathAdded = true;\n            } else {\n                // max size limit is reached -> end of the loop over the\n                // paths elements of the list at vertex v.\n                break;\n            }\n        }\n    }\n    return pathAdded;\n}"
            ],
            [
                "remove",
                "java.util",
                "AbstractList",
                "public E remove(int arg0)"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "toArray",
                "java.util",
                "AbstractCollection",
                "public <T> T[] toArray(T[] arg0)"
            ],
            [
                "toString",
                "java.util",
                "AbstractCollection",
                "public String toString()"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "add",
                "java.util",
                "AbstractCollection",
                "public boolean add(E arg0)"
            ],
            [
                "iterator",
                "java.util",
                "AbstractCollection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "size",
                "java.util",
                "AbstractCollection",
                "public abstract int size()"
            ],
            [
                "remove",
                "java.util",
                "Collection",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "contains",
                "java.util",
                "Collection",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "add",
                "java.util",
                "Collection",
                "public abstract boolean add(E arg0)"
            ],
            [
                "iterator",
                "java.util",
                "Collection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "hashCode",
                "java.util",
                "Collection",
                "public abstract int hashCode()"
            ],
            [
                "addAll",
                "java.util",
                "Collection",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "size",
                "java.util",
                "Collection",
                "public abstract int size()"
            ],
            [
                "equals",
                "java.util",
                "Collection",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract Object[] toArray()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "isEmpty",
                "java.util",
                "Collection",
                "public abstract boolean isEmpty()"
            ],
            [
                "isEmpty",
                "java.util",
                "List",
                "public abstract boolean isEmpty()"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "List",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "size",
                "java.util",
                "List",
                "public abstract int size()"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator(int arg0)"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract E remove(int arg0)"
            ],
            [
                "indexOf",
                "java.util",
                "List",
                "public abstract int indexOf(Object arg0)"
            ],
            [
                "get",
                "java.util",
                "List",
                "public abstract E get(int arg0)"
            ],
            [
                "spliterator",
                "java.util",
                "List",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "subList",
                "java.util",
                "List",
                "public abstract List<E> subList(int arg0, int arg1)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract Object[] toArray()"
            ],
            [
                "add",
                "java.util",
                "List",
                "public abstract boolean add(E arg0)"
            ],
            [
                "lastIndexOf",
                "java.util",
                "List",
                "public abstract int lastIndexOf(Object arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator()"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)"
            ],
            [
                "containsAll",
                "java.util",
                "List",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "set",
                "java.util",
                "List",
                "public abstract E set(int arg0, E arg1)"
            ],
            [
                "contains",
                "java.util",
                "List",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "List",
                "public abstract int hashCode()"
            ],
            [
                "iterator",
                "java.util",
                "List",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "equals",
                "java.util",
                "List",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "removeAll",
                "java.util",
                "List",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "graph",
                "org.jgrapht.alg",
                "AbstractPathElementList",
                "protected Graph<V, E> graph;"
            ],
            [
                "maxSize",
                "org.jgrapht.alg",
                "AbstractPathElementList",
                "protected int maxSize;"
            ],
            [
                "pathElements",
                "org.jgrapht.alg",
                "AbstractPathElementList",
                "protected ArrayList<RankingPathElement<V, E>> pathElements;"
            ],
            [
                "vertex",
                "org.jgrapht.alg",
                "AbstractPathElementList",
                "protected V vertex;"
            ],
            [
                "modCount",
                "java.util",
                "AbstractList",
                "protected int modCount;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26575,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg",
        "className": "DirectedNeighborIndex",
        "javadocTag": "@param v the vertex whose successors are desired",
        "methodJavadoc": "    /**\n     * Returns the set of vertices which are the successors of a specified\n     * vertex. If the graph is a multigraph, vertices may appear more than once\n     * in the returned list. Because a list of successors can not be efficiently\n     * maintained, it is reconstructed on every invocation by duplicating\n     * entries in the neighbor set. It is thus more efficient to use {@link\n     * #successorsOf(Object)} unless duplicate neighbors are required.\n     *\n     * @param v the vertex whose successors are desired\n     *\n     * @return all successors of the specified vertex\n     */",
        "methodSourceCode": "public List<V> successorListOf(V v){\n    return getSuccessors(v).getNeighborList();\n}",
        "classJavadoc": "/**\n * Maintains a cache of each vertex's neighbors. While lists of neighbors can be\n * obtained from {@link Graphs}, they are re-calculated at each invocation by\n * walking a vertex's incident edges, which becomes inordinately expensive when\n * performed often.\n *\n * <p>A vertex's neighbors are cached the first time they are asked for (i.e.\n * the index is built on demand). The index will only be updated automatically\n * if it is added to the associated graph as a listener. If it is added as a\n * listener to a graph other than the one it indexes, results are undefined.</p>\n *\n * @author Charles Fry\n * @since Dec 13, 2005\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* --------------------------\n * DirectedNeighborIndex.java\n * --------------------------\n * (C) Copyright 2005-2008, by Charles Fry and Contributors.\n *\n * Original Author:  Charles Fry\n *\n * $Id$\n *\n * Changes\n * -------\n * 13-Dec-2005 : Initial revision (CF);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.NeighborIndex.*;\nimport org.jgrapht.event.*;\n\n\n/**\n * Maintains a cache of each vertex's neighbors. While lists of neighbors can be\n * obtained from {@link Graphs}, they are re-calculated at each invocation by\n * walking a vertex's incident edges, which becomes inordinately expensive when\n * performed often.\n *\n * <p>A vertex's neighbors are cached the first time they are asked for (i.e.\n * the index is built on demand). The index will only be updated automatically\n * if it is added to the associated graph as a listener. If it is added as a\n * listener to a graph other than the one it indexes, results are undefined.</p>\n *\n * @author Charles Fry\n * @since Dec 13, 2005\n */\npublic class DirectedNeighborIndex<V, E>\n    implements GraphListener<V, E>\n{\n    Map<V, Neighbors<V, E>> predecessorMap = new HashMap<V, Neighbors<V, E>>();\n    Map<V, Neighbors<V, E>> successorMap = new HashMap<V, Neighbors<V, E>>();\n    private DirectedGraph<V, E> graph;\n\n    /**\n     * Creates a neighbor index for the specified directed graph.\n     *\n     * @param g the graph for which a neighbor index is to be created.\n     */\n    public DirectedNeighborIndex(DirectedGraph<V, E> g)\n    {\n        graph = g;\n    }\n\n    /**\n     * Returns the set of vertices which are the predecessors of a specified\n     * vertex. The returned set is backed by the index, and will be updated when\n     * the graph changes as long as the index has been added as a listener to\n     * the graph.\n     *\n     * @param v the vertex whose predecessors are desired\n     *\n     * @return all unique predecessors of the specified vertex\n     */\n    public Set<V> predecessorsOf(V v)\n    {\n        return getPredecessors(v).getNeighbors();\n    }\n\n    /**\n     * Returns the set of vertices which are the predecessors of a specified\n     * vertex. If the graph is a multigraph, vertices may appear more than once\n     * in the returned list. Because a list of predecessors can not be\n     * efficiently maintained, it is reconstructed on every invocation by\n     * duplicating entries in the neighbor set. It is thus more efficient to use\n     * {@link #predecessorsOf(Object)} unless duplicate neighbors are required.\n     *\n     * @param v the vertex whose predecessors are desired\n     *\n     * @return all predecessors of the specified vertex\n     */\n    public List<V> predecessorListOf(V v)\n    {\n        return getPredecessors(v).getNeighborList();\n    }\n\n    /**\n     * Returns the set of vertices which are the successors of a specified\n     * vertex. The returned set is backed by the index, and will be updated when\n     * the graph changes as long as the index has been added as a listener to\n     * the graph.\n     *\n     * @param v the vertex whose successors are desired\n     *\n     * @return all unique successors of the specified vertex\n     */\n    public Set<V> successorsOf(V v)\n    {\n        return getSuccessors(v).getNeighbors();\n    }\n\n    /**\n     * Returns the set of vertices which are the successors of a specified\n     * vertex. If the graph is a multigraph, vertices may appear more than once\n     * in the returned list. Because a list of successors can not be efficiently\n     * maintained, it is reconstructed on every invocation by duplicating\n     * entries in the neighbor set. It is thus more efficient to use {@link\n     * #successorsOf(Object)} unless duplicate neighbors are required.\n     *\n     * @param v the vertex whose successors are desired\n     *\n     * @return all successors of the specified vertex\n     */\n    public List<V> successorListOf(V v)\n    {\n        return getSuccessors(v).getNeighborList();\n    }\n\n    /**\n     * @see GraphListener#edgeAdded(GraphEdgeChangeEvent)\n     */\n    @Override public void edgeAdded(GraphEdgeChangeEvent<V, E> e)\n    {\n        E edge = e.getEdge();\n        V source = graph.getEdgeSource(edge);\n        V target = graph.getEdgeTarget(edge);\n\n        // if a map does not already contain an entry,\n        // then skip addNeighbor, since instantiating the map\n        // will take care of processing the edge (which has already\n        // been added)\n\n        if (successorMap.containsKey(source)) {\n            getSuccessors(source).addNeighbor(target);\n        } else {\n            getSuccessors(source);\n        }\n        if (predecessorMap.containsKey(target)) {\n            getPredecessors(target).addNeighbor(source);\n        } else {\n            getPredecessors(target);\n        }\n    }\n\n    /**\n     * @see GraphListener#edgeRemoved(GraphEdgeChangeEvent)\n     */\n    @Override public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)\n    {\n        E edge = e.getEdge();\n        V source = e.getEdgeSource();\n        V target = e.getEdgeTarget();\n        if (successorMap.containsKey(source)) {\n            successorMap.get(source).removeNeighbor(target);\n        }\n        if (predecessorMap.containsKey(target)) {\n            predecessorMap.get(target).removeNeighbor(source);\n        }\n    }\n\n    /**\n     * @see VertexSetListener#vertexAdded(GraphVertexChangeEvent)\n     */\n    @Override public void vertexAdded(GraphVertexChangeEvent<V> e)\n    {\n        // nothing to cache until there are edges\n    }\n\n    /**\n     * @see VertexSetListener#vertexRemoved(GraphVertexChangeEvent)\n     */\n    @Override public void vertexRemoved(GraphVertexChangeEvent<V> e)\n    {\n        predecessorMap.remove(e.getVertex());\n        successorMap.remove(e.getVertex());\n    }\n\n    private Neighbors<V, E> getPredecessors(V v)\n    {\n        Neighbors<V, E> neighbors = predecessorMap.get(v);\n        if (neighbors == null) {\n            neighbors =\n                new Neighbors<V, E>(v,\n                    Graphs.predecessorListOf(graph, v));\n            predecessorMap.put(v, neighbors);\n        }\n        return neighbors;\n    }\n\n    private Neighbors<V, E> getSuccessors(V v)\n    {\n        Neighbors<V, E> neighbors = successorMap.get(v);\n        if (neighbors == null) {\n            neighbors =\n                new Neighbors<V, E>(v,\n                    Graphs.successorListOf(graph, v));\n            successorMap.put(v, neighbors);\n        }\n        return neighbors;\n    }\n}\n\n// End DirectedNeighborIndex.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "v",
                "",
                "V"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "predecessorListOf",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "/**\n * Returns the set of vertices which are the predecessors of a specified\n * vertex. If the graph is a multigraph, vertices may appear more than once\n * in the returned list. Because a list of predecessors can not be\n * efficiently maintained, it is reconstructed on every invocation by\n * duplicating entries in the neighbor set. It is thus more efficient to use\n * {@link #predecessorsOf(Object)} unless duplicate neighbors are required.\n *\n * @param v the vertex whose predecessors are desired\n *\n * @return all predecessors of the specified vertex\n */\npublic List<V> predecessorListOf(V v) {\n    return getPredecessors(v).getNeighborList();\n}"
            ],
            [
                "successorsOf",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "/**\n * Returns the set of vertices which are the successors of a specified\n * vertex. The returned set is backed by the index, and will be updated when\n * the graph changes as long as the index has been added as a listener to\n * the graph.\n *\n * @param v the vertex whose successors are desired\n *\n * @return all unique successors of the specified vertex\n */\npublic Set<V> successorsOf(V v) {\n    return getSuccessors(v).getNeighbors();\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "predecessorsOf",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "/**\n * Returns the set of vertices which are the predecessors of a specified\n * vertex. The returned set is backed by the index, and will be updated when\n * the graph changes as long as the index has been added as a listener to\n * the graph.\n *\n * @param v the vertex whose predecessors are desired\n *\n * @return all unique predecessors of the specified vertex\n */\npublic Set<V> predecessorsOf(V v) {\n    return getPredecessors(v).getNeighbors();\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "/**\n * Returns the set of vertices which are the successors of a specified\n * vertex. If the graph is a multigraph, vertices may appear more than once\n * in the returned list. Because a list of successors can not be efficiently\n * maintained, it is reconstructed on every invocation by duplicating\n * entries in the neighbor set. It is thus more efficient to use {@link\n * #successorsOf(Object)} unless duplicate neighbors are required.\n *\n * @param v the vertex whose successors are desired\n *\n * @return all successors of the specified vertex\n */\npublic List<V> successorListOf(V v) {\n    return getSuccessors(v).getNeighborList();\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "containsAll",
                "java.util",
                "List",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "equals",
                "java.util",
                "List",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "List",
                "public abstract int hashCode()"
            ],
            [
                "removeAll",
                "java.util",
                "List",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "isEmpty",
                "java.util",
                "List",
                "public abstract boolean isEmpty()"
            ],
            [
                "indexOf",
                "java.util",
                "List",
                "public abstract int indexOf(Object arg0)"
            ],
            [
                "spliterator",
                "java.util",
                "List",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "get",
                "java.util",
                "List",
                "public abstract E get(int arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator(int arg0)"
            ],
            [
                "subList",
                "java.util",
                "List",
                "public abstract List<E> subList(int arg0, int arg1)"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)"
            ],
            [
                "add",
                "java.util",
                "List",
                "public abstract boolean add(E arg0)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract E remove(int arg0)"
            ],
            [
                "set",
                "java.util",
                "List",
                "public abstract E set(int arg0, E arg1)"
            ],
            [
                "size",
                "java.util",
                "List",
                "public abstract int size()"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract Object[] toArray()"
            ],
            [
                "retainAll",
                "java.util",
                "List",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "contains",
                "java.util",
                "List",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator()"
            ],
            [
                "lastIndexOf",
                "java.util",
                "List",
                "public abstract int lastIndexOf(Object arg0)"
            ],
            [
                "iterator",
                "java.util",
                "List",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "size",
                "java.util",
                "Collection",
                "public abstract int size()"
            ],
            [
                "iterator",
                "java.util",
                "Collection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract Object[] toArray()"
            ],
            [
                "contains",
                "java.util",
                "Collection",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "isEmpty",
                "java.util",
                "Collection",
                "public abstract boolean isEmpty()"
            ],
            [
                "add",
                "java.util",
                "Collection",
                "public abstract boolean add(E arg0)"
            ],
            [
                "equals",
                "java.util",
                "Collection",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "Collection",
                "public abstract int hashCode()"
            ],
            [
                "addAll",
                "java.util",
                "Collection",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "remove",
                "java.util",
                "Collection",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "removeIf",
                "java.util",
                "Collection",
                "public default boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "predecessorMap",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "Map<V, Neighbors<V, E>> predecessorMap = new HashMap<V, Neighbors<V, E>>();"
            ],
            [
                "successorMap",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "Map<V, Neighbors<V, E>> successorMap = new HashMap<V, Neighbors<V, E>>();"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26576,
        "oracle": ";",
        "oracleType": "NORMAL_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg",
        "className": "DirectedNeighborIndex",
        "javadocTag": "@return all successors of the specified vertex",
        "methodJavadoc": "    /**\n     * Returns the set of vertices which are the successors of a specified\n     * vertex. If the graph is a multigraph, vertices may appear more than once\n     * in the returned list. Because a list of successors can not be efficiently\n     * maintained, it is reconstructed on every invocation by duplicating\n     * entries in the neighbor set. It is thus more efficient to use {@link\n     * #successorsOf(Object)} unless duplicate neighbors are required.\n     *\n     * @param v the vertex whose successors are desired\n     *\n     * @return all successors of the specified vertex\n     */",
        "methodSourceCode": "public List<V> successorListOf(V v){\n    return getSuccessors(v).getNeighborList();\n}",
        "classJavadoc": "/**\n * Maintains a cache of each vertex's neighbors. While lists of neighbors can be\n * obtained from {@link Graphs}, they are re-calculated at each invocation by\n * walking a vertex's incident edges, which becomes inordinately expensive when\n * performed often.\n *\n * <p>A vertex's neighbors are cached the first time they are asked for (i.e.\n * the index is built on demand). The index will only be updated automatically\n * if it is added to the associated graph as a listener. If it is added as a\n * listener to a graph other than the one it indexes, results are undefined.</p>\n *\n * @author Charles Fry\n * @since Dec 13, 2005\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* --------------------------\n * DirectedNeighborIndex.java\n * --------------------------\n * (C) Copyright 2005-2008, by Charles Fry and Contributors.\n *\n * Original Author:  Charles Fry\n *\n * $Id$\n *\n * Changes\n * -------\n * 13-Dec-2005 : Initial revision (CF);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.NeighborIndex.*;\nimport org.jgrapht.event.*;\n\n\n/**\n * Maintains a cache of each vertex's neighbors. While lists of neighbors can be\n * obtained from {@link Graphs}, they are re-calculated at each invocation by\n * walking a vertex's incident edges, which becomes inordinately expensive when\n * performed often.\n *\n * <p>A vertex's neighbors are cached the first time they are asked for (i.e.\n * the index is built on demand). The index will only be updated automatically\n * if it is added to the associated graph as a listener. If it is added as a\n * listener to a graph other than the one it indexes, results are undefined.</p>\n *\n * @author Charles Fry\n * @since Dec 13, 2005\n */\npublic class DirectedNeighborIndex<V, E>\n    implements GraphListener<V, E>\n{\n    Map<V, Neighbors<V, E>> predecessorMap = new HashMap<V, Neighbors<V, E>>();\n    Map<V, Neighbors<V, E>> successorMap = new HashMap<V, Neighbors<V, E>>();\n    private DirectedGraph<V, E> graph;\n\n    /**\n     * Creates a neighbor index for the specified directed graph.\n     *\n     * @param g the graph for which a neighbor index is to be created.\n     */\n    public DirectedNeighborIndex(DirectedGraph<V, E> g)\n    {\n        graph = g;\n    }\n\n    /**\n     * Returns the set of vertices which are the predecessors of a specified\n     * vertex. The returned set is backed by the index, and will be updated when\n     * the graph changes as long as the index has been added as a listener to\n     * the graph.\n     *\n     * @param v the vertex whose predecessors are desired\n     *\n     * @return all unique predecessors of the specified vertex\n     */\n    public Set<V> predecessorsOf(V v)\n    {\n        return getPredecessors(v).getNeighbors();\n    }\n\n    /**\n     * Returns the set of vertices which are the predecessors of a specified\n     * vertex. If the graph is a multigraph, vertices may appear more than once\n     * in the returned list. Because a list of predecessors can not be\n     * efficiently maintained, it is reconstructed on every invocation by\n     * duplicating entries in the neighbor set. It is thus more efficient to use\n     * {@link #predecessorsOf(Object)} unless duplicate neighbors are required.\n     *\n     * @param v the vertex whose predecessors are desired\n     *\n     * @return all predecessors of the specified vertex\n     */\n    public List<V> predecessorListOf(V v)\n    {\n        return getPredecessors(v).getNeighborList();\n    }\n\n    /**\n     * Returns the set of vertices which are the successors of a specified\n     * vertex. The returned set is backed by the index, and will be updated when\n     * the graph changes as long as the index has been added as a listener to\n     * the graph.\n     *\n     * @param v the vertex whose successors are desired\n     *\n     * @return all unique successors of the specified vertex\n     */\n    public Set<V> successorsOf(V v)\n    {\n        return getSuccessors(v).getNeighbors();\n    }\n\n    /**\n     * Returns the set of vertices which are the successors of a specified\n     * vertex. If the graph is a multigraph, vertices may appear more than once\n     * in the returned list. Because a list of successors can not be efficiently\n     * maintained, it is reconstructed on every invocation by duplicating\n     * entries in the neighbor set. It is thus more efficient to use {@link\n     * #successorsOf(Object)} unless duplicate neighbors are required.\n     *\n     * @param v the vertex whose successors are desired\n     *\n     * @return all successors of the specified vertex\n     */\n    public List<V> successorListOf(V v)\n    {\n        return getSuccessors(v).getNeighborList();\n    }\n\n    /**\n     * @see GraphListener#edgeAdded(GraphEdgeChangeEvent)\n     */\n    @Override public void edgeAdded(GraphEdgeChangeEvent<V, E> e)\n    {\n        E edge = e.getEdge();\n        V source = graph.getEdgeSource(edge);\n        V target = graph.getEdgeTarget(edge);\n\n        // if a map does not already contain an entry,\n        // then skip addNeighbor, since instantiating the map\n        // will take care of processing the edge (which has already\n        // been added)\n\n        if (successorMap.containsKey(source)) {\n            getSuccessors(source).addNeighbor(target);\n        } else {\n            getSuccessors(source);\n        }\n        if (predecessorMap.containsKey(target)) {\n            getPredecessors(target).addNeighbor(source);\n        } else {\n            getPredecessors(target);\n        }\n    }\n\n    /**\n     * @see GraphListener#edgeRemoved(GraphEdgeChangeEvent)\n     */\n    @Override public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)\n    {\n        E edge = e.getEdge();\n        V source = e.getEdgeSource();\n        V target = e.getEdgeTarget();\n        if (successorMap.containsKey(source)) {\n            successorMap.get(source).removeNeighbor(target);\n        }\n        if (predecessorMap.containsKey(target)) {\n            predecessorMap.get(target).removeNeighbor(source);\n        }\n    }\n\n    /**\n     * @see VertexSetListener#vertexAdded(GraphVertexChangeEvent)\n     */\n    @Override public void vertexAdded(GraphVertexChangeEvent<V> e)\n    {\n        // nothing to cache until there are edges\n    }\n\n    /**\n     * @see VertexSetListener#vertexRemoved(GraphVertexChangeEvent)\n     */\n    @Override public void vertexRemoved(GraphVertexChangeEvent<V> e)\n    {\n        predecessorMap.remove(e.getVertex());\n        successorMap.remove(e.getVertex());\n    }\n\n    private Neighbors<V, E> getPredecessors(V v)\n    {\n        Neighbors<V, E> neighbors = predecessorMap.get(v);\n        if (neighbors == null) {\n            neighbors =\n                new Neighbors<V, E>(v,\n                    Graphs.predecessorListOf(graph, v));\n            predecessorMap.put(v, neighbors);\n        }\n        return neighbors;\n    }\n\n    private Neighbors<V, E> getSuccessors(V v)\n    {\n        Neighbors<V, E> neighbors = successorMap.get(v);\n        if (neighbors == null) {\n            neighbors =\n                new Neighbors<V, E>(v,\n                    Graphs.successorListOf(graph, v));\n            successorMap.put(v, neighbors);\n        }\n        return neighbors;\n    }\n}\n\n// End DirectedNeighborIndex.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "v",
                "",
                "V"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "successorsOf",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "/**\n * Returns the set of vertices which are the successors of a specified\n * vertex. The returned set is backed by the index, and will be updated when\n * the graph changes as long as the index has been added as a listener to\n * the graph.\n *\n * @param v the vertex whose successors are desired\n *\n * @return all unique successors of the specified vertex\n */\npublic Set<V> successorsOf(V v) {\n    return getSuccessors(v).getNeighbors();\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "/**\n * Returns the set of vertices which are the predecessors of a specified\n * vertex. If the graph is a multigraph, vertices may appear more than once\n * in the returned list. Because a list of predecessors can not be\n * efficiently maintained, it is reconstructed on every invocation by\n * duplicating entries in the neighbor set. It is thus more efficient to use\n * {@link #predecessorsOf(Object)} unless duplicate neighbors are required.\n *\n * @param v the vertex whose predecessors are desired\n *\n * @return all predecessors of the specified vertex\n */\npublic List<V> predecessorListOf(V v) {\n    return getPredecessors(v).getNeighborList();\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "/**\n * Returns the set of vertices which are the successors of a specified\n * vertex. If the graph is a multigraph, vertices may appear more than once\n * in the returned list. Because a list of successors can not be efficiently\n * maintained, it is reconstructed on every invocation by duplicating\n * entries in the neighbor set. It is thus more efficient to use {@link\n * #successorsOf(Object)} unless duplicate neighbors are required.\n *\n * @param v the vertex whose successors are desired\n *\n * @return all successors of the specified vertex\n */\npublic List<V> successorListOf(V v) {\n    return getSuccessors(v).getNeighborList();\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "predecessorsOf",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "/**\n * Returns the set of vertices which are the predecessors of a specified\n * vertex. The returned set is backed by the index, and will be updated when\n * the graph changes as long as the index has been added as a listener to\n * the graph.\n *\n * @param v the vertex whose predecessors are desired\n *\n * @return all unique predecessors of the specified vertex\n */\npublic Set<V> predecessorsOf(V v) {\n    return getPredecessors(v).getNeighbors();\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "containsAll",
                "java.util",
                "List",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator()"
            ],
            [
                "indexOf",
                "java.util",
                "List",
                "public abstract int indexOf(Object arg0)"
            ],
            [
                "subList",
                "java.util",
                "List",
                "public abstract List<E> subList(int arg0, int arg1)"
            ],
            [
                "isEmpty",
                "java.util",
                "List",
                "public abstract boolean isEmpty()"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "removeAll",
                "java.util",
                "List",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "size",
                "java.util",
                "List",
                "public abstract int size()"
            ],
            [
                "add",
                "java.util",
                "List",
                "public abstract boolean add(E arg0)"
            ],
            [
                "iterator",
                "java.util",
                "List",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "contains",
                "java.util",
                "List",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "equals",
                "java.util",
                "List",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator(int arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "List",
                "public abstract int hashCode()"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "lastIndexOf",
                "java.util",
                "List",
                "public abstract int lastIndexOf(Object arg0)"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract E remove(int arg0)"
            ],
            [
                "get",
                "java.util",
                "List",
                "public abstract E get(int arg0)"
            ],
            [
                "spliterator",
                "java.util",
                "List",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "retainAll",
                "java.util",
                "List",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "set",
                "java.util",
                "List",
                "public abstract E set(int arg0, E arg1)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract Object[] toArray()"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "equals",
                "java.util",
                "Collection",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "addAll",
                "java.util",
                "Collection",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract Object[] toArray()"
            ],
            [
                "size",
                "java.util",
                "Collection",
                "public abstract int size()"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "remove",
                "java.util",
                "Collection",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "add",
                "java.util",
                "Collection",
                "public abstract boolean add(E arg0)"
            ],
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "Collection",
                "public abstract int hashCode()"
            ],
            [
                "iterator",
                "java.util",
                "Collection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "isEmpty",
                "java.util",
                "Collection",
                "public abstract boolean isEmpty()"
            ],
            [
                "contains",
                "java.util",
                "Collection",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "removeIf",
                "java.util",
                "Collection",
                "public default boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "predecessorMap",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "Map<V, Neighbors<V, E>> predecessorMap = new HashMap<V, Neighbors<V, E>>();"
            ],
            [
                "successorMap",
                "org.jgrapht.alg",
                "DirectedNeighborIndex",
                "Map<V, Neighbors<V, E>> successorMap = new HashMap<V, Neighbors<V, E>>();"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26594,
        "oracle": "(g == null) == false;",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg",
        "className": "HamiltonianCycle",
        "javadocTag": "@param g is the graph to find the optimal tour for.",
        "methodJavadoc": "    /**\n     * This method will return an approximate minimal traveling salesman tour\n     * (hamiltonian cycle). This algorithm requires that the graph be complete\n     * and the triangle inequality exists (if x,y,z are vertices then\n     * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n     * guarantee a hamiltonian cycle such that the total weight of the cycle is\n     * less than or equal to double the total weight of the optimal hamiltonian\n     * cycle. The optimal solution is NP-complete, so this is a decent\n     * approximation that runs in polynomial time.\n     *\n     * @param <V>\n     * @param <E>\n     * @param g is the graph to find the optimal tour for.\n     *\n     * @return The optimal tour as a list of vertices.\n     */",
        "methodSourceCode": "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g){\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}",
        "classJavadoc": "/**\n * This class will deal with finding the optimal or approximately optimal\n * minimum tour (hamiltonian cycle) or commonly known as the <a\n * href=\"http://mathworld.wolfram.com/TravelingSalesmanProblem.html\">Traveling\n * Salesman Problem</a>.\n *\n * @author Andrew Newell\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * HamiltonianCycle.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Andrew Newell\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 17-Feb-2008 : Initial revision (AN);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * This class will deal with finding the optimal or approximately optimal\n * minimum tour (hamiltonian cycle) or commonly known as the <a\n * href=\"http://mathworld.wolfram.com/TravelingSalesmanProblem.html\">Traveling\n * Salesman Problem</a>.\n *\n * @author Andrew Newell\n */\npublic class HamiltonianCycle\n{\n    /**\n     * This method will return an approximate minimal traveling salesman tour\n     * (hamiltonian cycle). This algorithm requires that the graph be complete\n     * and the triangle inequality exists (if x,y,z are vertices then\n     * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n     * guarantee a hamiltonian cycle such that the total weight of the cycle is\n     * less than or equal to double the total weight of the optimal hamiltonian\n     * cycle. The optimal solution is NP-complete, so this is a decent\n     * approximation that runs in polynomial time.\n     *\n     * @param <V>\n     * @param <E>\n     * @param g is the graph to find the optimal tour for.\n     *\n     * @return The optimal tour as a list of vertices.\n     */\n    public static <V, E> List<V> getApproximateOptimalForCompleteGraph(\n        SimpleWeightedGraph<V, E> g)\n    {\n        List<V> vertices = new LinkedList<V>(g.vertexSet());\n\n        // If the graph is not complete then return null since this algorithm\n        // requires the graph be complete\n        if ((vertices.size() * (vertices.size() - 1) / 2)\n            != g.edgeSet().size())\n        {\n            return null;\n        }\n\n        List<V> tour = new LinkedList<V>();\n\n        // Each iteration a new vertex will be added to the tour until all\n        // vertices have been added\n        while (tour.size() != g.vertexSet().size()) {\n            boolean firstEdge = true;\n            double minEdgeValue = 0;\n            int minVertexFound = 0;\n            int vertexConnectedTo = 0;\n\n            // A check will be made for the shortest edge to a vertex not within\n            // the tour and that new vertex will be added to the vertex\n            for (int i = 0; i < tour.size(); i++) {\n                V v = tour.get(i);\n                for (int j = 0; j < vertices.size(); j++) {\n                    double weight =\n                        g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                    if (firstEdge || (weight < minEdgeValue)) {\n                        firstEdge = false;\n                        minEdgeValue = weight;\n                        minVertexFound = j;\n                        vertexConnectedTo = i;\n                    }\n                }\n            }\n            tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n            vertices.remove(minVertexFound);\n        }\n        return tour;\n    }\n}\n\n// End HamiltonianCycle.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "g",
                "org.jgrapht.graph.SimpleWeightedGraph",
                "SimpleWeightedGraph<V, E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "createDirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public double getEdgeWeight(E arg0)"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addVertex(V arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsVertex(V arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgesOf(V arg0)"
            ],
            [
                "isAllowingMultipleEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingMultipleEdges()"
            ],
            [
                "inDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int inDegreeOf(V arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeTarget(E arg0)"
            ],
            [
                "degreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int degreeOf(V arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<V> vertexSet()"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsEdge(E arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgeSet()"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeVertex(V arg0)"
            ],
            [
                "createUndirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()"
            ],
            [
                "isAllowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingLoops()"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeEdge(E arg0)"
            ],
            [
                "clone",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Object clone()"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E addEdge(V arg0, V arg1)"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "outDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int outDegreeOf(V arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E getEdge(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeSource(E arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E removeEdge(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public String toString()"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "degreeOf",
                "org.jgrapht",
                "UndirectedGraph",
                "public abstract int degreeOf(V arg0)"
            ],
            [
                "iterator",
                "java.util",
                "List",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "contains",
                "java.util",
                "List",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator(int arg0)"
            ],
            [
                "add",
                "java.util",
                "List",
                "public abstract boolean add(E arg0)"
            ],
            [
                "subList",
                "java.util",
                "List",
                "public abstract List<E> subList(int arg0, int arg1)"
            ],
            [
                "hashCode",
                "java.util",
                "List",
                "public abstract int hashCode()"
            ],
            [
                "isEmpty",
                "java.util",
                "List",
                "public abstract boolean isEmpty()"
            ],
            [
                "size",
                "java.util",
                "List",
                "public abstract int size()"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "listIterator",
                "java.util",
                "List",
                "public abstract ListIterator<E> listIterator()"
            ],
            [
                "spliterator",
                "java.util",
                "List",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "set",
                "java.util",
                "List",
                "public abstract E set(int arg0, E arg1)"
            ],
            [
                "indexOf",
                "java.util",
                "List",
                "public abstract int indexOf(Object arg0)"
            ],
            [
                "removeAll",
                "java.util",
                "List",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)"
            ],
            [
                "remove",
                "java.util",
                "List",
                "public abstract E remove(int arg0)"
            ],
            [
                "toArray",
                "java.util",
                "List",
                "public abstract Object[] toArray()"
            ],
            [
                "equals",
                "java.util",
                "List",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "List",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "get",
                "java.util",
                "List",
                "public abstract E get(int arg0)"
            ],
            [
                "containsAll",
                "java.util",
                "List",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "lastIndexOf",
                "java.util",
                "List",
                "public abstract int lastIndexOf(Object arg0)"
            ],
            [
                "addAll",
                "java.util",
                "List",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "add",
                "java.util",
                "Collection",
                "public abstract boolean add(E arg0)"
            ],
            [
                "iterator",
                "java.util",
                "Collection",
                "public abstract Iterator<E> iterator()"
            ],
            [
                "removeAll",
                "java.util",
                "Collection",
                "public abstract boolean removeAll(Collection<? extends Object> arg0)"
            ],
            [
                "removeIf",
                "java.util",
                "Collection",
                "public default boolean removeIf(Predicate<? super E> arg0)"
            ],
            [
                "retainAll",
                "java.util",
                "Collection",
                "public abstract boolean retainAll(Collection<? extends Object> arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract <T> T[] toArray(T[] arg0)"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public default <T> T[] toArray(IntFunction<T[]> arg0)"
            ],
            [
                "addAll",
                "java.util",
                "Collection",
                "public abstract boolean addAll(Collection<? extends E> arg0)"
            ],
            [
                "spliterator",
                "java.util",
                "Collection",
                "public default Spliterator<E> spliterator()"
            ],
            [
                "containsAll",
                "java.util",
                "Collection",
                "public abstract boolean containsAll(Collection<? extends Object> arg0)"
            ],
            [
                "parallelStream",
                "java.util",
                "Collection",
                "public default Stream<E> parallelStream()"
            ],
            [
                "remove",
                "java.util",
                "Collection",
                "public abstract boolean remove(Object arg0)"
            ],
            [
                "hashCode",
                "java.util",
                "Collection",
                "public abstract int hashCode()"
            ],
            [
                "isEmpty",
                "java.util",
                "Collection",
                "public abstract boolean isEmpty()"
            ],
            [
                "stream",
                "java.util",
                "Collection",
                "public default Stream<E> stream()"
            ],
            [
                "contains",
                "java.util",
                "Collection",
                "public abstract boolean contains(Object arg0)"
            ],
            [
                "size",
                "java.util",
                "Collection",
                "public abstract int size()"
            ],
            [
                "toArray",
                "java.util",
                "Collection",
                "public abstract Object[] toArray()"
            ],
            [
                "equals",
                "java.util",
                "Collection",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "iterator",
                "java.lang",
                "Iterable",
                "public abstract Iterator<T> iterator()"
            ],
            [
                "spliterator",
                "java.lang",
                "Iterable",
                "public default Spliterator<T> spliterator()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "allowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "boolean allowingLoops;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26616,
        "oracle": ";",
        "oracleType": "NORMAL_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.alg",
        "className": "CycleDetector",
        "javadocTag": "@return true if v is on at least one cycle",
        "methodJavadoc": "    /**\n     * Performs yes/no cycle detection on an individual vertex.\n     *\n     * @param v the vertex to test\n     *\n     * @return true if v is on at least one cycle\n     */",
        "methodSourceCode": "public boolean detectCyclesContainingVertex(V v){\n    try {\n        execute(null, v);\n    } catch (CycleDetectedException ex) {\n        return true;\n    }\n    return false;\n}",
        "classJavadoc": "/**\n * Performs cycle detection on a graph. The <i>inspected graph</i> is specified\n * at construction time and cannot be modified. Currently, the detector supports\n * only directed graphs.\n *\n * @author John V. Sichi\n * @since Sept 16, 2004\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * CycleDetector.java\n * ------------------\n * (C) Copyright 2004-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 16-Sept-2004 : Initial revision (JVS);\n * 07-Jun-2005 : Made generic (CH);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.interfaces.*;\nimport org.jgrapht.traverse.*;\n\n\n/**\n * Performs cycle detection on a graph. The <i>inspected graph</i> is specified\n * at construction time and cannot be modified. Currently, the detector supports\n * only directed graphs.\n *\n * @author John V. Sichi\n * @since Sept 16, 2004\n */\npublic class CycleDetector<V, E>\n{\n    /**\n     * Graph on which cycle detection is being performed.\n     */\n    DirectedGraph<V, E> graph;\n\n    /**\n     * Creates a cycle detector for the specified graph. Currently only directed\n     * graphs are supported.\n     *\n     * @param graph the DirectedGraph in which to detect cycles\n     */\n    public CycleDetector(DirectedGraph<V, E> graph)\n    {\n        this.graph = graph;\n    }\n\n    /**\n     * Performs yes/no cycle detection on the entire graph.\n     *\n     * @return true iff the graph contains at least one cycle\n     */\n    public boolean detectCycles()\n    {\n        try {\n            execute(null, null);\n        } catch (CycleDetectedException ex) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Performs yes/no cycle detection on an individual vertex.\n     *\n     * @param v the vertex to test\n     *\n     * @return true if v is on at least one cycle\n     */\n    public boolean detectCyclesContainingVertex(V v)\n    {\n        try {\n            execute(null, v);\n        } catch (CycleDetectedException ex) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Finds the vertex set for the subgraph of all cycles.\n     *\n     * @return set of all vertices which participate in at least one cycle in\n     * this graph\n     */\n    public Set<V> findCycles()\n    {\n        // ProbeIterator can't be used to handle this case,\n        // so use StrongConnectivityAlgorithm instead.\n        StrongConnectivityAlgorithm<V, E> inspector =\n            new KosarajuStrongConnectivityInspector<V, E>(graph);\n        List<Set<V>> components = inspector.stronglyConnectedSets();\n\n        // A vertex participates in a cycle if either of the following is\n        // true:  (a) it is in a component whose size is greater than 1\n        // or (b) it is a self-loop\n\n        Set<V> set = new HashSet<V>();\n        for (Set<V> component : components) {\n            if (component.size() > 1) {\n                // cycle\n                set.addAll(component);\n            } else {\n                V v = component.iterator().next();\n                if (graph.containsEdge(v, v)) {\n                    // self-loop\n                    set.add(v);\n                }\n            }\n        }\n\n        return set;\n    }\n\n    /**\n     * Finds the vertex set for the subgraph of all cycles which contain a\n     * particular vertex.\n     *\n     * <p>REVIEW jvs 25-Aug-2006: This implementation is not guaranteed to cover\n     * all cases. If you want to be absolutely certain that you report vertices\n     * from all cycles containing v, it's safer (but less efficient) to use\n     * StrongConnectivityAlgorithm instead and return the strongly connected\n     * component containing v.\n     *\n     * @param v the vertex to test\n     *\n     * @return set of all vertices reachable from v via at least one cycle\n     */\n    public Set<V> findCyclesContainingVertex(V v)\n    {\n        Set<V> set = new HashSet<V>();\n        execute(set, v);\n\n        return set;\n    }\n\n    private void execute(Set<V> s, V v)\n    {\n        ProbeIterator iter = new ProbeIterator(s, v);\n\n        while (iter.hasNext()) {\n            iter.next();\n        }\n    }\n\n    /**\n     * Exception thrown internally when a cycle is detected during a yes/no\n     * cycle test. Must be caught by top-level detection method.\n     */\n    private static class CycleDetectedException\n        extends RuntimeException\n    {\n        private static final long serialVersionUID = 3834305137802950712L;\n    }\n\n    /**\n     * Version of DFS which maintains a backtracking path used to probe for\n     * cycles.\n     */\n    private class ProbeIterator\n        extends DepthFirstIterator<V, E>\n    {\n        private List<V> path;\n        private Set<V> cycleSet;\n        private V root;\n\n        ProbeIterator(Set<V> cycleSet, V startVertex)\n        {\n            super(graph, startVertex);\n            root = startVertex;\n            this.cycleSet = cycleSet;\n            path = new ArrayList<V>();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override protected void encounterVertexAgain(V vertex, E edge)\n        {\n            super.encounterVertexAgain(vertex, edge);\n\n            int i;\n\n            if (root != null) {\n                // For rooted detection, the path must either\n                // double back to the root, or to a node of a cycle\n                // which has already been detected.\n                if (vertex.equals(root)) {\n                    i = 0;\n                } else if ((cycleSet != null) && cycleSet.contains(vertex)) {\n                    i = 0;\n                } else {\n                    return;\n                }\n            } else {\n                i = path.indexOf(vertex);\n            }\n\n            if (i > -1) {\n                if (cycleSet == null) {\n                    // we're doing yes/no cycle detection\n                    throw new CycleDetectedException();\n                } else {\n                    for (; i < path.size(); ++i) {\n                        cycleSet.add(path.get(i));\n                    }\n                }\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override protected V provideNextVertex()\n        {\n            V v = super.provideNextVertex();\n\n            // backtrack\n            for (int i = path.size() - 1; i >= 0; --i) {\n                if (graph.containsEdge(path.get(i), v)) {\n                    break;\n                }\n\n                path.remove(i);\n            }\n\n            path.add(v);\n\n            return v;\n        }\n    }\n}\n\n// End CycleDetector.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "v",
                "",
                "V"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "findCycles",
                "org.jgrapht.alg",
                "CycleDetector",
                "/**\n * Finds the vertex set for the subgraph of all cycles.\n *\n * @return set of all vertices which participate in at least one cycle in\n * this graph\n */\npublic Set<V> findCycles() {\n    // ProbeIterator can't be used to handle this case,\n    // so use StrongConnectivityAlgorithm instead.\n    StrongConnectivityAlgorithm<V, E> inspector = new KosarajuStrongConnectivityInspector<V, E>(graph);\n    List<Set<V>> components = inspector.stronglyConnectedSets();\n    // A vertex participates in a cycle if either of the following is\n    // true:  (a) it is in a component whose size is greater than 1\n    // or (b) it is a self-loop\n    Set<V> set = new HashSet<V>();\n    for (Set<V> component : components) {\n        if (component.size() > 1) {\n            // cycle\n            set.addAll(component);\n        } else {\n            V v = component.iterator().next();\n            if (graph.containsEdge(v, v)) {\n                // self-loop\n                set.add(v);\n            }\n        }\n    }\n    return set;\n}"
            ],
            [
                "detectCyclesContainingVertex",
                "org.jgrapht.alg",
                "CycleDetector",
                "/**\n * Performs yes/no cycle detection on an individual vertex.\n *\n * @param v the vertex to test\n *\n * @return true if v is on at least one cycle\n */\npublic boolean detectCyclesContainingVertex(V v) {\n    try {\n        execute(null, v);\n    } catch (CycleDetectedException ex) {\n        return true;\n    }\n    return false;\n}"
            ],
            [
                "detectCycles",
                "org.jgrapht.alg",
                "CycleDetector",
                "/**\n * Performs yes/no cycle detection on the entire graph.\n *\n * @return true iff the graph contains at least one cycle\n */\npublic boolean detectCycles() {\n    try {\n        execute(null, null);\n    } catch (CycleDetectedException ex) {\n        return true;\n    }\n    return false;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "findCyclesContainingVertex",
                "org.jgrapht.alg",
                "CycleDetector",
                "/**\n * Finds the vertex set for the subgraph of all cycles which contain a\n * particular vertex.\n *\n * <p>REVIEW jvs 25-Aug-2006: This implementation is not guaranteed to cover\n * all cases. If you want to be absolutely certain that you report vertices\n * from all cycles containing v, it's safer (but less efficient) to use\n * StrongConnectivityAlgorithm instead and return the strongly connected\n * component containing v.\n *\n * @param v the vertex to test\n *\n * @return set of all vertices reachable from v via at least one cycle\n */\npublic Set<V> findCyclesContainingVertex(V v) {\n    Set<V> set = new HashSet<V>();\n    execute(set, v);\n    return set;\n}"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "graph",
                "org.jgrapht.alg",
                "CycleDetector",
                "/**\n * Graph on which cycle detection is being performed.\n */\nDirectedGraph<V, E> graph;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]