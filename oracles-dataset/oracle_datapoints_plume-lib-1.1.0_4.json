[ {
  "id" : 10328,
  "oracle" : "start >= 0 && start < seq.length;",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "Intern",
  "javadocTag" : "@param start the index of the start of the subsequence to be interned",
  "methodJavadoc" : "    /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */",
  "methodSourceCode" : "public static String[] internSubsequence(/*@PolyNull*/\n/*@Interned*/\nString[] seq, int start, int end){\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    sai = new SequenceAndIndices<String[]>(seq, start, end);\n    // same nullness as key\n    @SuppressWarnings(\"nullness\")\n    WeakReference<String[]> /*@PolyNull*/\n    /*@Interned*/\n    /*@Interned*/\n    lookup = internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        /*@PolyNull*/\n        /*@Interned*/\n        String[] /*@Interned*/\n        subseq = Intern.intern(subseq_uninterned);\n        // safe because map does no side effects\n        @SuppressWarnings(\"nullness\")\n        Object // assignment just so there is a place to hang the @SuppressWarnings annotation\n        ignore = internedStringSequenceAndIndices.put(sai, new WeakReference<String[]>(subseq));\n        return subseq;\n    }\n}",
  "classJavadoc" : "/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */",
  "classSourceCode" : "package plume;\n\nimport java.lang.ref.WeakReference;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\n/*>>>\nimport org.checkerframework.checker.interning.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()</code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==</code> instead of\n * <code>.equals()</code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n */\npublic final class Intern {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private Intern() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Strings\n  ///\n\n  /**\n   * Replace each element of the array by its interned version.\n   * Side-effects the array, but also returns it.\n   * @param a the array whose elements to intern in place\n   * @return an interned version of a\n   * @see String#intern\n   */\n  @SuppressWarnings(\"interning\") // side-effects the array in place (dangerous, but convenient)\n  public static /*@Interned*/ String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (a[i] != null) {\n        a[i] = a[i].intern();\n      }\n    }\n    return a;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Testing interning\n  ///\n\n  /**\n   * Return true if the argument is interned (is canonical among all\n   * objects equal to itself).\n   * @param value the value to test for interning\n   * @return true iff value is interned\n   */\n  @SuppressWarnings(\"interning\") // interning implementation\n  /*@Pure*/\n  public static boolean isInterned(/*@Nullable*/ Object value) {\n    if (value == null) {\n      // nothing to do\n      return true;\n    } else if (value instanceof String) {\n      return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n      return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n      return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n      return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n      return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n      return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n      return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n      return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n      return (value == intern((Object[]) value));\n    } else {\n      // Nothing to do, because we don't intern other types.\n      // System.out.println(\"What type? \" + value.getClass().getName());\n      return true;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning objects\n  ///\n\n  /**\n   * Hasher object which hashes and compares Integers.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class IntegerHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Integer i = (Integer) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Longs.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   */\n  private static final class LongHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Long i = (Long) o;\n      return i.intValue();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares int[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(int[], int[])\n   */\n  private static final class IntArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((int[]) a1, (int[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((int[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares long[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals (long[], long[])\n   */\n  private static final class LongArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((long[]) a1, (long[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((long[]) o);\n    }\n  }\n\n  private static final int FACTOR = 23;\n  // private static final double DOUBLE_FACTOR = 65537;\n  private static final double DOUBLE_FACTOR = 263;\n\n  /**\n   * Hasher object which hashes and compares Doubles.\n   * @see Hasher\n   */\n  private static final class DoubleHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Double d = (Double) o;\n      return d.hashCode();\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares double[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[],Object[])\n   */\n  private static final class DoubleArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      // \"Arrays.equals\" considers +0.0 != -0.0.\n      // Also, it gives inconsistent results (on different JVMs/classpaths?).\n      // return Arrays.equals((double[])a1, (double[])a2);\n      double[] da1 = (double[]) a1;\n      double[] da2 = (double[]) a2;\n      if (da1.length != da2.length) {\n        return false;\n      }\n      for (int i = 0; i < da1.length; i++) {\n        if (!((da1[i] == da2[i]) || (Double.isNaN(da1[i]) && Double.isNaN(da2[i])))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      double[] a = (double[]) o;\n      // Not Arrays.hashCode(a), for consistency with equals method\n      // immediately above.\n      double running = 0;\n      for (int i = 0; i < a.length; i++) {\n        double elt = (Double.isNaN(a[i]) ? 0.0 : a[i]);\n        running = running * FACTOR + elt * DOUBLE_FACTOR;\n      }\n      // Could add \"... % Integer.MAX_VALUE\" here; is that good to do?\n      long result = Math.round(running);\n      return (int) (result % Integer.MAX_VALUE);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   * Arrays.equals\n   */\n  private static final class StringArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((String[]) a1, (String[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((String[]) o);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares Object[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[], Object[])\n   */\n  private static final class ObjectArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((/*@Nullable*/ Object[]) a1, (/*@Nullable*/ Object[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((Object[]) o);\n    }\n  }\n\n  // Each of these maps has:\n  //   key = an interned object\n  //   value = a WeakReference for the object itself.\n  // They can be looked up using a non-interned value; equality tests know\n  // nothing of the interning types.\n\n  private static WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>\n      internedIntegers;\n  private static WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>> internedLongs;\n  private static WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>\n      internedIntArrays;\n  private static WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>\n      internedLongArrays;\n  private static WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>\n      internedDoubles;\n  private static /*@Interned*/ Double internedDoubleNaN;\n  private static /*@Interned*/ Double internedDoubleZero;\n  private static WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>\n      internedDoubleArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringArrays;\n  private static WeakHasherMap<\n          /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectArrays;\n  private static WeakHasherMap<\n          SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>\n      internedIntSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>\n      internedLongSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>\n      internedDoubleSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>\n      internedObjectSequenceAndIndices;\n  private static WeakHasherMap<\n          SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n          WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>\n      internedStringSequenceAndIndices;\n\n  static {\n    internedIntegers =\n        new WeakHasherMap</*@Interned*/ Integer, WeakReference</*@Interned*/ Integer>>(\n            new IntegerHasher());\n    internedLongs =\n        new WeakHasherMap</*@Interned*/ Long, WeakReference</*@Interned*/ Long>>(new LongHasher());\n    internedIntArrays =\n        new WeakHasherMap<int /*@Interned*/ [], WeakReference<int /*@Interned*/ []>>(\n            new IntArrayHasher());\n    internedLongArrays =\n        new WeakHasherMap<long /*@Interned*/ [], WeakReference<long /*@Interned*/ []>>(\n            new LongArrayHasher());\n    internedDoubles =\n        new WeakHasherMap</*@Interned*/ Double, WeakReference</*@Interned*/ Double>>(\n            new DoubleHasher());\n    internedDoubleNaN = new /*@Interned*/ Double(Double.NaN);\n    internedDoubleZero = new /*@Interned*/ Double(0);\n    internedDoubleArrays =\n        new WeakHasherMap<double /*@Interned*/ [], WeakReference<double /*@Interned*/ []>>(\n            new DoubleArrayHasher());\n    internedStringArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new StringArrayHasher());\n    internedObjectArrays =\n        new WeakHasherMap<\n            /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [],\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new ObjectArrayHasher());\n    internedIntSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<int /*@Interned*/ []>, WeakReference<int /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<int /*@Interned*/ []>());\n    internedLongSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<long /*@Interned*/ []>, WeakReference<long /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<long /*@Interned*/ []>());\n    internedDoubleSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices<double /*@Interned*/ []>, WeakReference<double /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher<double /*@Interned*/ []>());\n    internedObjectSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>());\n    internedStringSequenceAndIndices =\n        new WeakHasherMap<\n            SequenceAndIndices</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>,\n            WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>>(\n            new SequenceAndIndicesHasher</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>());\n  }\n\n  // For testing only\n  public static int numIntegers() {\n    return internedIntegers.size();\n  }\n\n  public static int numLongs() {\n    return internedLongs.size();\n  }\n\n  public static int numIntArrays() {\n    return internedIntArrays.size();\n  }\n\n  public static int numLongArrays() {\n    return internedLongArrays.size();\n  }\n\n  public static int numDoubles() {\n    return internedDoubles.size();\n  }\n\n  public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n  }\n\n  public static int numStringArrays() {\n    return internedStringArrays.size();\n  }\n\n  public static int numObjectArrays() {\n    return internedObjectArrays.size();\n  }\n\n  public static Iterator</*@Interned*/ Integer> integers() {\n    return internedIntegers.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Long> longs() {\n    return internedLongs.keySet().iterator();\n  }\n\n  public static Iterator<int /*@Interned*/ []> intArrays() {\n    return internedIntArrays.keySet().iterator();\n  }\n\n  public static Iterator<long /*@Interned*/ []> longArrays() {\n    return internedLongArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Interned*/ Double> doubles() {\n    return internedDoubles.keySet().iterator();\n  }\n\n  public static Iterator<double /*@Interned*/ []> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n  }\n\n  public static Iterator</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n  }\n\n  /**\n   * Interns a String.\n   * Delegates to the builtin String.intern() method.\n   * Provided for completeness.\n   * @param a the string to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ String intern(/*@PolyNull*/ String a) {\n    // Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n      return null;\n    }\n    return a.intern();\n  }\n\n  /**\n   * Interns a long.\n   * A no-op.  Provided for completeness.\n   * @param l the long to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static long intern(long l) {\n    return l;\n  }\n\n  /**\n   * Interns a double\n   * A no-op.  Provided for completeness.\n   * @param d the double to intern\n   * @return an interned version of the argument\n   */\n  /*@Pure*/\n  public static double intern(double d) {\n    return d;\n  }\n\n  /**\n   * Intern (canonicalize) an Integer.\n   * Return a canonical representation for the Integer.\n   * @param a an Integer to canonicalize\n   * @return a canonical representation for the Integer\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Intern.valueOf is intended to promise\n  // the same).  This does not currently take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"}) // interning implementation\n  /*@Pure*/\n  public static /*@Interned*/ Integer intern(Integer a) {\n    WeakReference</*@Interned*/ Integer> lookup = internedIntegers.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Integer result = (/*@Interned*/ Integer) a;\n      internedIntegers.put(result, new WeakReference</*@Interned*/ Integer>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Integer internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Integer with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Integer parsed from s\n   */\n  public static /*@Interned*/ Integer internedInteger(String s) {\n    return intern(Integer.decode(s));\n  }\n\n  /**\n   * Intern (canonicalize) a Long.\n   * Return a canonical representation for the Long.\n   * @param a the value to intern\n   * @return a canonical representation for the Long\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Long.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Long intern(Long a) {\n    WeakReference</*@Interned*/ Long> lookup = internedLongs.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Long result = (/*@Interned*/ Long) a;\n      internedLongs.put(result, new WeakReference</*@Interned*/ Long>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   */\n  public static /*@Interned*/ Long internedLong(long i) {\n    return intern(Long.valueOf(i));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Long with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Long parsed from s\n   */\n  public static /*@Interned*/ Long internedLong(String s) {\n    return intern(Long.decode(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) an int[].\n   * Return a canonical representation for the int[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the int[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static int /*@Interned*/ [] intern(int[] a) {\n    // Throwable stack = new Throwable(\"debug traceback\");\n    // stack.fillInStackTrace();\n    // stack.printStackTrace();\n\n    WeakReference<int /*@Interned*/ []> lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ int[] result = (int /*@Interned*/ []) a;\n      internedIntArrays.put(result, new WeakReference<int /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a long[].\n   * Return a canonical representation for the long[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the long[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static long /*@Interned*/ [] intern(long[] a) {\n    //System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    //                   a, Arrays.toString (a));\n    WeakReference<long /*@Interned*/ []> lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ long[] result = (long /*@Interned*/ []) a;\n      internedLongArrays.put(result, new WeakReference<long /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) a Double.\n   * Return a canonical representation for the Double.\n   * @param a the Double to canonicalize\n   * @return a canonical representation for the Double\n   */\n  // TODO: JLS 5.1.7 requires that the boxing conversion interns integer\n  // values between -128 and 127 (and Double.valueOf is intended to promise\n  // the same).  This could take advantage of that.\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static /*@Interned*/ Double intern(Double a) {\n    // Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n      return internedDoubleNaN;\n    }\n    // Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) { // catches both positive and negative zero\n      return internedDoubleZero;\n    }\n    WeakReference</*@Interned*/ Double> lookup = internedDoubles.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ Double result = (/*@Interned*/ Double) a;\n      internedDoubles.put(result, new WeakReference</*@Interned*/ Double>(result));\n      return result;\n    }\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value i.\n   * @param d the value to intern\n   * @return an interned Double with value d\n   */\n  public static /*@Interned*/ Double internedDouble(double d) {\n    return intern(Double.valueOf(d));\n  }\n\n  // Not sure whether this convenience method is really worth it.\n  /** Returns an interned Double with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Double parsed from s\n   */\n  public static /*@Interned*/ Double internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n  }\n\n  // I might prefer to have the intern methods first check using a straight\n  // eq hashing, which would be more efficient if the array is already\n  // interned.  (How frequent do I expect that to be, and how much would\n  // that really improve performance even in that case?)\n\n  /**\n   * Intern (canonicalize) a double[].\n   * Return a canonical representation for the double[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the double[] array\n   */\n  @SuppressWarnings({\"interning\", \"purity\"})\n  /*@Pure*/\n  public static double /*@Interned*/ [] intern(double[] a) {\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") // cast is redundant (except in JSR 308)\n      /*@Interned*/ double[] result = (double /*@Interned*/ []) a;\n      internedDoubleArrays.put(result, new WeakReference<double /*@Interned*/ []>(result));\n      return result;\n    }\n  }\n\n  /**\n   * Intern (canonicalize) an String[].\n   * Return a canonical representation for the String[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the String[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ String[] a) {\n\n    // Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n      assert a[k] == Intern.intern(a[k]);\n    }\n\n    WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ String /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ String /*@Interned*/ []) a;\n      internedStringArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ String /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Intern (canonicalize) an Object[].\n   * Return a canonical representation for the Object[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the Object[] array\n   */\n  @SuppressWarnings({\n    \"interning\", // interns its argument\n    \"purity\",\n    \"cast\"\n  }) // cast is redundant (except in JSR 308)\n  /*@Pure*/\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] intern(\n      /*@PolyNull*/ /*@Interned*/ Object[] a) {\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectArrays.get(a);\n    /*@Nullable*/ /*@Interned*/ Object /*@Interned*/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (/*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []) a;\n      internedObjectArrays.put(\n          result, new WeakReference</*@Nullable*/ /*@Interned*/ Object /*@Interned*/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") // Polynull because value = parameter a, so same type & nullness as for parameter a\n    /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] polyresult = result;\n    return polyresult;\n  }\n\n  /**\n   * Convenince method to intern an Object when we don't know its\n   * runtime type.  Its runtime type must be one of the types for\n   * which we have an intern() method, else an exception is thrown.\n   * If the argument is an array, its elements should themselves be\n   * interned.\n   * @param a an Object to canonicalize\n   * @return a canonical version of a\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static /*@Interned*/ /*@PolyNull*/ Object intern(/*@PolyNull*/ Object a) {\n    if (a == null) {\n      return null;\n    } else if (a instanceof String) {\n      return intern((String) a);\n    } else if (a instanceof String[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ String[] asArray = (/*@Interned*/ String[]) a;\n      return intern(asArray);\n    } else if (a instanceof Integer) {\n      return intern((Integer) a);\n    } else if (a instanceof Long) {\n      return intern((Long) a);\n    } else if (a instanceof int[]) {\n      return intern((int[]) a);\n    } else if (a instanceof long[]) {\n      return intern((long[]) a);\n    } else if (a instanceof Double) {\n      return intern((Double) a);\n    } else if (a instanceof double[]) {\n      return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n      @SuppressWarnings(\"interning\")\n      /*@Interned*/ Object[] asArray = (/*@Interned*/ Object[]) a;\n      return intern(asArray);\n    } else {\n      throw new IllegalArgumentException(\n          \"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n  }\n\n  /**\n   * Return the subsequence of seq from start (inclusive) to end\n   * (exclusive) that is interned.  What's different about this method\n   * from manually finding the subsequence and interning the\n   * subsequence is that if the subsequence is already interned, we\n   * can avoid having to compute the sequence.  Since derived\n   * variables in Daikon compute the subsequence many times, this\n   * shortcut saves quite a bit of computation.  It saves even more\n   * when there may be many derived variables that are non-canonical,\n   * since they are guaranteed to be ==.\n   * <p>\n   * Requires that seq is already interned.\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   */\n  public static int /*@Interned*/ [] internSubsequence(int /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int /*@Interned*/ []> sai =\n        new SequenceAndIndices<int /*@Interned*/ []>(seq, start, end);\n    WeakReference<int /*@Interned*/ []> lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n      int /*@Interned*/ [] subseq = Intern.intern(subseqUninterned);\n      internedIntSequenceAndIndices.put(sai, new WeakReference<int /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static long /*@Interned*/ [] internSubsequence(\n      long /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long /*@Interned*/ []> sai =\n        new SequenceAndIndices<long /*@Interned*/ []>(seq, start, end);\n    WeakReference<long /*@Interned*/ []> lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      long /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedLongSequenceAndIndices.put(sai, new WeakReference<long /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static double /*@Interned*/ [] internSubsequence(\n      double /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double /*@Interned*/ []> sai =\n        new SequenceAndIndices<double /*@Interned*/ []>(seq, start, end);\n    WeakReference<double /*@Interned*/ []> lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      double /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      internedDoubleSequenceAndIndices.put(sai, new WeakReference<double /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []> lookup =\n        internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedObjectSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ Object /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   */\n  public static /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] internSubsequence(\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> sai =\n        new SequenceAndIndices</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") // same nullness as key\n    WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []> lookup =\n        internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      /*@PolyNull*/ /*@Interned*/ String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      /*@PolyNull*/ /*@Interned*/ String /*@Interned*/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") // safe because map does no side effects\n      Object\n          ignore = // assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedStringSequenceAndIndices.put(\n                  sai,\n                  new WeakReference</*@PolyNull*/ /*@Interned*/ String /*@Interned*/ []>(subseq));\n      return subseq;\n    }\n  }\n\n  /**\n   * Data structure for storing triples of a sequence and start and\n   * end indices, to represent a subsequence.  Requires that the\n   * sequence be interned.  Used for interning the repeated finding\n   * of subsequences on the same sequence.\n   */\n  private static final class SequenceAndIndices<T extends /*@Interned*/ Object> {\n    public T seq;\n    public int start;\n    public int end;\n\n    /**\n     * @param seq an interned array\n     */\n    public SequenceAndIndices(T seq, int start, int end) {\n      this.seq = seq;\n      this.start = start;\n      this.end = end;\n      assert isInterned(seq);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ /*@Nullable*/ Object other) {\n      if (other instanceof SequenceAndIndices<?>) {\n        @SuppressWarnings(\"unchecked\")\n        SequenceAndIndices<T> other_sai = (SequenceAndIndices<T>) other;\n        return equals(other_sai);\n      } else {\n        return false;\n      }\n    }\n\n    /*@Pure*/\n    public boolean equals(\n        /*>>>@GuardSatisfied SequenceAndIndices<T> this,*/\n        /*@GuardSatisfied*/ SequenceAndIndices<T> other) {\n      return ((this.seq == other.seq) && this.start == other.start && this.end == other.end);\n    }\n\n    /*@Pure*/\n    public int hashCode(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return seq.hashCode() + start * 30 - end * 2;\n    }\n\n    // For debugging\n    /*@SideEffectFree*/\n    public String toString(/*>>>@GuardSatisfied SequenceAndIndices<T> this*/) {\n      return \"SAI(\" + start + \",\" + end + \") from: \" + ArraysMDE.toString(seq);\n    }\n  }\n\n  /**\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   */\n  private static final class SequenceAndIndicesHasher<T extends /*@Interned*/ Object>\n      implements Hasher {\n    public boolean equals(Object a1, Object a2) {\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai1 = (SequenceAndIndices<T>) a1;\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai2 = (SequenceAndIndices<T>) a2;\n      // The SAI objects are *not* interned, but the arrays inside them are.\n      return sai1.equals(sai2);\n    }\n\n    public int hashCode(Object o) {\n      return o.hashCode();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #1\n  ///\n\n  /// Interning arrays:  old implmentation.\n  /// The problem with this is that it doesn't release keys.\n  // // I can also use Arrays.equals() to compare two arrays of base\n  // // or Object type; but that doesn't do ordering.  (It does properly deal\n  // // with the possibility that the argument is null, which this doesn't\n  // // right now.  I may want to err in this implementation if the arguments\n  // // are null or the lengths are not equal -- if I never mix arrays of\n  // // different lengths.)\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical numbers).\n  // static final class IntArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     int[] a1 = (int[])o1;\n  //     int[] a2 = (int[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i] - a2[i];\n  //       if (tmp != 0)\n  //         return tmp;\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // // Note: this comparator imposes orderings that are inconsistent with equals.\n  // // That is, it may return 0 if the arrays are not equal (but do contain\n  // // identical objects).\n  // static final class ObjectArrayComparator implements Comparator, Serializable {\n  //   /*@Pure*/\n  //   public int compare(Object o1, Object o2) {\n  //     if (o1 == o2)\n  //       return 0;\n  //     Object[] a1 = (Object[])o1;\n  //     Object[] a2 = (Object[])o2;\n  //     int tmp;\n  //     tmp = a1.length - a2.length;\n  //     if (tmp != 0)\n  //       return tmp;\n  //     for (int i=0; i<a1.length; i++) {\n  //       tmp = a1[i].hashCode() - a2[i].hashCode();\n  //       if (tmp != 0)\n  //         return tmp;\n  //       // I'm counting on the fact that hashCode returns a different\n  //       // number for each Object in the system.  This checks that assumption.\n  //       assert a1[i].equals(a2[i]);\n  //     }\n  //     return 0;\n  //   }\n  // }\n\n  // private static TreeSet internedIntArrays;\n  // private static TreeSet internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new TreeSet(new IntArrayComparator());\n  //   internedObjectArrays = new TreeSet(new ObjectArrayComparator());\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   boolean added = internedIntArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (int[])internedIntArrays.tailSet(a).first();\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   boolean added = internedObjectArrays.add(a);\n  //   if (added) {\n  //     return a;\n  //   } else {\n  //     return (Object[])internedObjectArrays.tailSet(a).first();\n  //   }\n  // }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Interning arrays:  old implementation #2\n  ///\n\n  /// This doesn't work because there are no references to the Wrappers,\n  /// so all of the WeakHashMap elements are immediately removed.\n\n  // // Create an ArrayWrapper which redefines equal (and hash) to act the\n  // // way I want them to.\n\n  // static final class IntArrayWrapper {\n  //   private int[] a;\n  //   IntArrayWrapper(int[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(IntArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i];\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // static final class ObjectArrayWrapper {\n  //   private Object[] a;\n  //   ObjectArrayWrapper(Object[] a) {\n  //     this.a = a;\n  //   }\n  //   boolean equals(ObjectArrayWrapper other) {\n  //     return Arrays.equals(a, other.a);\n  //   }\n  //   static final int FACTOR = 23;\n  //   // Alternately, just xor all the element hash codes.\n  //   public int hashCode() {\n  //     int result = 0;\n  //     for (int i=0; i<a.length; i++) {\n  //       result = result * FACTOR + a[i].hashCode();\n  //     }\n  //     return result;\n  //   }\n  // }\n\n  // // Map from an ArrayWrapper to the array (I don't need to map to a\n  // // WeakReference because the array isn't the key of the WeakHashMap).\n\n  // // non-private for debugging only\n  // static WeakHashMap internedIntArrays;\n  // static WeakHashMap internedObjectArrays;\n  // // private static WeakHashMap internedIntArrays;\n  // // private static WeakHashMap internedObjectArrays;\n\n  // static {\n  //   internedIntArrays = new WeakHashMap();\n  //   internedObjectArrays = new WeakHashMap();\n  // }\n\n  // public static int[] internIntArray(int[] a) {\n  //   IntArrayWrapper w = new IntArrayWrapper(a);\n  //   Object result = internedIntArrays.get(w);\n  //   if (result != null)\n  //     return (int[])result;\n  //   else {\n  //     internedIntArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n  // // All the elements should already themselves be interned\n  // public static Object[] internObjectArray(Object[] a) {\n  //   ObjectArrayWrapper w = new ObjectArrayWrapper(a);\n  //   Object result = internedObjectArrays.get(w);\n  //   if (result != null)\n  //     return (Object[])result;\n  //   else {\n  //     internedObjectArrays.put(w, a);\n  //     return a;\n  //   }\n  // }\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "seq", "", "String[]" ], [ "start", "", "int" ], [ "end", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "", "java.lang.String[]", "public boolean equals(Object);" ], [ "toString", "", "java.lang.String[]", "public String toString()" ], [ "hashCode", "", "java.lang.String[]", "public native int hashCode()" ], [ "getClass", "", "java.lang.String[]", "public final native Class getClass();" ], [ "clone", "", "java.lang.String[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "java.lang", "String[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10345,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "RandomSelector",
  "javadocTag" : "@param r the seed to give for random number generation.\n\nSets 'number_to_take' = num_elts",
  "methodJavadoc" : "    /** @param num_elts the number of elements intended to be selected\n   * from the input elements\n   * @param r the seed to give for random number generation.\n   *\n   * Sets 'number_to_take' = num_elts\n   */",
  "methodSourceCode" : "public RandomSelector(int num_elts, Random r){\n    values = new ArrayList<T>();\n    this.num_elts = num_elts;\n    observed = 0;\n    generator = r;\n}",
  "classJavadoc" : "/**\n * RandomSelector selects k elements uniformly at random from\n * an arbitrary iterator, using O(k) space.  A naive algorithm would use O(n)\n * space.  For example, selecting 1 element from a FileStream\n * containing 1000 elements will take O(1) space. The class takes as\n * input the number k during initialization and then can accept() any\n * number of Objects in the future.  At any point in time, getValues()\n * will either return k randomly selected elements from the elements\n * previous accepted or if accept() was called fewer than k times, will\n * return all elements previously accepted.\n *\n * <p>The random selection is independent between every constructed\n * instance of RandomSelector objects, but for the same instance,\n * multiple calls to getValues() are not independent. Making two calls\n * to consecutive getValues() without an accept() in between will\n * return two new Lists containing the same elements.\n *\n * <p>A second mode allows for a fixed probability of randomly keeping\n *  each item as opposed to a fixed number of samples.\n *\n * <P>SPECFIELDS:\n * <BR>current_values  : Set : The values chosen based on the Objects observed\n * <BR>number_observed : int : The number of Objects observed\n * <BR>number_to_take  : int : The number of elements to choose ('k' above)\n * <BR>keep_probability: double :  The percentage of elements to keep\n * <BR>selector_mode :\n *       {FIXED,PERCENT}  : either fixed amount of samples or fixed percent.\n *\n * <P>Example use:\n * <br> // randomly selects 100 lines of text from a file\n * <pre>\n *  List selectedLines = null;\n *  try {\n *     BufferedReader br = new BufferedReader\n *       (new FileReader (\"myfile.txt\"));\n *     RandomSelector selector = new RandomSelector (100);\n *     while (br.ready()) {\n *       selector.accept (br.readLine());\n *     }\n *     selectedLines = selector.getValues();\n *   }\n *   catch (IOException e2) { e2.printStackTrace(); }\n * </pre>\n *\n * @param <T> the type of elements being selected over\n */",
  "classSourceCode" : "package plume;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * RandomSelector selects k elements uniformly at random from\n * an arbitrary iterator, using O(k) space.  A naive algorithm would use O(n)\n * space.  For example, selecting 1 element from a FileStream\n * containing 1000 elements will take O(1) space. The class takes as\n * input the number k during initialization and then can accept() any\n * number of Objects in the future.  At any point in time, getValues()\n * will either return k randomly selected elements from the elements\n * previous accepted or if accept() was called fewer than k times, will\n * return all elements previously accepted.\n *\n * <p>The random selection is independent between every constructed\n * instance of RandomSelector objects, but for the same instance,\n * multiple calls to getValues() are not independent. Making two calls\n * to consecutive getValues() without an accept() in between will\n * return two new Lists containing the same elements.\n *\n * <p>A second mode allows for a fixed probability of randomly keeping\n *  each item as opposed to a fixed number of samples.\n *\n * <P>SPECFIELDS:\n * <BR>current_values  : Set : The values chosen based on the Objects observed\n * <BR>number_observed : int : The number of Objects observed\n * <BR>number_to_take  : int : The number of elements to choose ('k' above)\n * <BR>keep_probability: double :  The percentage of elements to keep\n * <BR>selector_mode :\n *       {FIXED,PERCENT}  : either fixed amount of samples or fixed percent.\n *\n * <P>Example use:\n * <br> // randomly selects 100 lines of text from a file\n * <pre>\n *  List selectedLines = null;\n *  try {\n *     BufferedReader br = new BufferedReader\n *       (new FileReader (\"myfile.txt\"));\n *     RandomSelector selector = new RandomSelector (100);\n *     while (br.ready()) {\n *       selector.accept (br.readLine());\n *     }\n *     selectedLines = selector.getValues();\n *   }\n *   catch (IOException e2) { e2.printStackTrace(); }\n * </pre>\n *\n * @param <T> the type of elements being selected over\n */\npublic class RandomSelector<T> {\n\n  // Rep Invariant: values != null && values.size() <= num_elts &&\n  //                ((num_elts == -1 && coin_toss_mode == true) ||\n  //                 (keep_probability == -1.0 && coin_toss_mode == false))\n\n  // Abstraction Function:\n  // 1. for all elements, 'val' of AF(current_values),\n  //    this.values.indexOf (val) != -1\n  // 2. AF(number_observed) = this.observed\n  // 3. AF(number_to_take) = this.num_elts\n  // 4. AF(keep_probability) = this.keep_probability\n  // 5. AF(selector_mode) = fixed amount if coin_toss_mode == true\n  //                        fixed percentage if coin_toss_mode == false\n\n  private int num_elts = -1;\n  private int observed;\n  private Random generator;\n  private ArrayList<T> values;\n  private boolean coin_toss_mode = false;\n  private double keep_probability = -1.0;\n\n  /** @param num_elts the number of elements intended to be selected\n   * from the input elements\n   *\n   * Sets 'number_to_take' = num_elts\n   */\n  public RandomSelector(int num_elts) {\n    this(num_elts, new Random());\n  }\n\n  /** @param num_elts the number of elements intended to be selected\n   * from the input elements\n   * @param r the seed to give for random number generation.\n   *\n   * Sets 'number_to_take' = num_elts\n   */\n  public RandomSelector(int num_elts, Random r) {\n    values = new ArrayList<T>();\n    this.num_elts = num_elts;\n    observed = 0;\n    generator = r;\n  }\n\n  /** @param keep_probability the probability that each element is\n   * selected from the oncoming Iteration\n   * @param r the seed to give for random number generation\n   */\n  public RandomSelector(double keep_probability, Random r) {\n    values = new ArrayList<T>();\n    this.keep_probability = keep_probability;\n    coin_toss_mode = true;\n    observed = 0;\n    generator = r;\n  }\n\n  /** <P>When in fixed sample mode, increments the number of\n   * observed elements i by 1, then with probability k / i, the\n   * Object 'next' will be added to the currently selected values\n   * 'current_values' where k is equal to 'number_to_take'. If the\n   * size of current_values exceeds number_to_take, then one of the\n   * existing elements in current_values will be removed at random.\n   *\n   *\n   * <P>When in probability mode, adds next to 'current_values' with\n   * probability equal to 'keep_probability'.\n   *\n   * @param next value to be added to this selector\n   */\n  public void accept(T next) {\n\n    // if we are in coin toss mode, then we want to keep\n    // with probability == keep_probability.\n    if (coin_toss_mode) {\n      if (generator.nextDouble() < keep_probability) {\n        values.add(next);\n        // System.out.println (\"ACCEPTED \" + keep_probability );\n      } else {\n        // System.out.println (\"didn't accept \" + keep_probability );\n      }\n      return;\n    }\n\n    // in fixed sample mode, the i-th element has a k/i chance\n    // of being accepted where k is number_to_take.\n    if (generator.nextDouble() < ((double) num_elts / (++observed))) {\n      if (values.size() < num_elts) {\n        values.add(next);\n      } else {\n        int rem = generator.nextInt(values.size());\n        values.set(rem, next);\n      }\n    }\n    // do nothing if the probability condition is not met\n  }\n\n  /** Returns current_values, modifies none.\n   * @return current_values\n   */\n  public List<T> getValues() {\n    // avoid concurrent mod errors and rep exposure\n    ArrayList<T> ret = new ArrayList<T>();\n    ret.addAll(values);\n    return ret;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "\"number_to_take\"", "String" ] ],
  "tokensMethodArguments" : [ [ "num_elts", "", "int" ], [ "r", "java.util", "Random" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getValues", "plume", "RandomSelector", "public List<T> getValues()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "ints", "java.util", "Random", "public IntStream ints(long arg0)" ], [ "nextInt", "java.util", "Random", "public int nextInt(int arg0)" ], [ "ints", "java.util", "Random", "public IntStream ints(int arg0, int arg1)" ], [ "nextGaussian", "java.util", "Random", "public synchronized double nextGaussian()" ], [ "doubles", "java.util", "Random", "public DoubleStream doubles()" ], [ "ints", "java.util", "Random", "public IntStream ints(long arg0, int arg1, int arg2)" ], [ "nextBoolean", "java.util", "Random", "public boolean nextBoolean()" ], [ "longs", "java.util", "Random", "public LongStream longs()" ], [ "longs", "java.util", "Random", "public LongStream longs(long arg0, long arg1)" ], [ "doubles", "java.util", "Random", "public DoubleStream doubles(long arg0, double arg1, double arg2)" ], [ "ints", "java.util", "Random", "public IntStream ints()" ], [ "nextInt", "java.util", "Random", "public int nextInt()" ], [ "nextFloat", "java.util", "Random", "public float nextFloat()" ], [ "nextLong", "java.util", "Random", "public long nextLong()" ], [ "longs", "java.util", "Random", "public LongStream longs(long arg0, long arg1, long arg2)" ], [ "doubles", "java.util", "Random", "public DoubleStream doubles(double arg0, double arg1)" ], [ "nextDouble", "java.util", "Random", "public double nextDouble()" ], [ "doubles", "java.util", "Random", "public DoubleStream doubles(long arg0)" ], [ "next", "java.util", "Random", "protected int next(int arg0)" ], [ "longs", "java.util", "Random", "public LongStream longs(long arg0)" ], [ "nextDouble", "java.util.random", "RandomGenerator", "public default double nextDouble(double arg0)" ], [ "nextDouble", "java.util.random", "RandomGenerator", "public default double nextDouble()" ], [ "longs", "java.util.random", "RandomGenerator", "public default LongStream longs(long arg0, long arg1, long arg2)" ], [ "longs", "java.util.random", "RandomGenerator", "public default LongStream longs(long arg0, long arg1)" ], [ "nextExponential", "java.util.random", "RandomGenerator", "public default double nextExponential()" ], [ "nextInt", "java.util.random", "RandomGenerator", "public default int nextInt(int arg0, int arg1)" ], [ "nextFloat", "java.util.random", "RandomGenerator", "public default float nextFloat()" ], [ "ints", "java.util.random", "RandomGenerator", "public default IntStream ints()" ], [ "doubles", "java.util.random", "RandomGenerator", "public default DoubleStream doubles(long arg0)" ], [ "nextLong", "java.util.random", "RandomGenerator", "public default long nextLong(long arg0, long arg1)" ], [ "doubles", "java.util.random", "RandomGenerator", "public default DoubleStream doubles()" ], [ "nextDouble", "java.util.random", "RandomGenerator", "public default double nextDouble(double arg0, double arg1)" ], [ "nextLong", "java.util.random", "RandomGenerator", "public abstract long nextLong()" ], [ "nextInt", "java.util.random", "RandomGenerator", "public default int nextInt()" ], [ "longs", "java.util.random", "RandomGenerator", "public default LongStream longs(long arg0)" ], [ "nextGaussian", "java.util.random", "RandomGenerator", "public default double nextGaussian()" ], [ "nextFloat", "java.util.random", "RandomGenerator", "public default float nextFloat(float arg0, float arg1)" ], [ "ints", "java.util.random", "RandomGenerator", "public default IntStream ints(long arg0)" ], [ "longs", "java.util.random", "RandomGenerator", "public default LongStream longs()" ], [ "nextFloat", "java.util.random", "RandomGenerator", "public default float nextFloat(float arg0)" ], [ "ints", "java.util.random", "RandomGenerator", "public default IntStream ints(long arg0, int arg1, int arg2)" ], [ "isDeprecated", "java.util.random", "RandomGenerator", "public default boolean isDeprecated()" ], [ "nextInt", "java.util.random", "RandomGenerator", "public default int nextInt(int arg0)" ], [ "nextGaussian", "java.util.random", "RandomGenerator", "public default double nextGaussian(double arg0, double arg1)" ], [ "doubles", "java.util.random", "RandomGenerator", "public default DoubleStream doubles(double arg0, double arg1)" ], [ "nextLong", "java.util.random", "RandomGenerator", "public default long nextLong(long arg0)" ], [ "doubles", "java.util.random", "RandomGenerator", "public default DoubleStream doubles(long arg0, double arg1, double arg2)" ], [ "nextBoolean", "java.util.random", "RandomGenerator", "public default boolean nextBoolean()" ], [ "ints", "java.util.random", "RandomGenerator", "public default IntStream ints(int arg0, int arg1)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10371,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "BCELUtil",
  "javadocTag" : "@return true iff the class is part of the JDK (rt.jar)",
  "methodJavadoc" : "    /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param classname the class to test, in internal form\n   * @return true iff the class is part of the JDK (rt.jar)\n   */",
  "methodSourceCode" : "public static boolean in_jdk_internalform(/*@InternalForm*/\nString classname){\n    return classname.startsWith(\"java/\") || classname.startsWith(\"com/\") || classname.startsWith(\"javax/\") || classname.startsWith(\"org/\") || classname.startsWith(\"sun/\") || classname.startsWith(\"sunw/\");\n}",
  "classJavadoc" : "/**\n * Static utility methods for working with BCEL.\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.PrintStream;\nimport java.util.Formatter;\nimport java.util.Iterator;\nimport org.apache.commons.bcel6.Const;\nimport org.apache.commons.bcel6.classfile.Attribute;\nimport org.apache.commons.bcel6.classfile.Code;\nimport org.apache.commons.bcel6.classfile.Constant;\nimport org.apache.commons.bcel6.classfile.ConstantClass;\nimport org.apache.commons.bcel6.classfile.ConstantPool;\nimport org.apache.commons.bcel6.classfile.ConstantUtf8;\nimport org.apache.commons.bcel6.classfile.Field;\nimport org.apache.commons.bcel6.classfile.JavaClass;\nimport org.apache.commons.bcel6.classfile.Method;\nimport org.apache.commons.bcel6.generic.ArrayType;\nimport org.apache.commons.bcel6.generic.ClassGen;\nimport org.apache.commons.bcel6.generic.CodeExceptionGen;\nimport org.apache.commons.bcel6.generic.ConstantPoolGen;\nimport org.apache.commons.bcel6.generic.InstructionHandle;\nimport org.apache.commons.bcel6.generic.InstructionList;\nimport org.apache.commons.bcel6.generic.InstructionTargeter;\nimport org.apache.commons.bcel6.generic.LineNumberGen;\nimport org.apache.commons.bcel6.generic.LocalVariableGen;\nimport org.apache.commons.bcel6.generic.MethodGen;\nimport org.apache.commons.bcel6.generic.ObjectType;\nimport org.apache.commons.bcel6.generic.RETURN;\nimport org.apache.commons.bcel6.generic.Type;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\n*/\n\n/**\n * Static utility methods for working with BCEL.\n */\npublic final class BCELUtil {\n  /** This class is a collection of methods; it does not represent anything. */\n  private BCELUtil() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  /** Controls whether the checks in checkMgen are actually performed. */\n  public static boolean skip_checks = false;\n\n  /** The type that represents String[]. */\n  private static final Type string_array = Type.getType(\"[Ljava.lang.String;\");\n\n  /** Prints method declarations to System.out.\n   * @param gen class whose methods to print\n   */\n  static void dump_method_declarations(ClassGen gen) {\n    System.out.printf(\"method signatures for class %s%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n      System.out.printf(\"  %s%n\", get_method_declaration(m));\n    }\n  }\n\n  /**\n   * Returns a string describing a method declaration. It contains the access\n   * flags (public, private, static, etc), the return type, the method name, and\n   * the types of each of its arguments.\n   * @param m the method\n   * @return a string describing the method declaration\n   */\n  public static String get_method_declaration(Method m) {\n\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n      f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n  }\n\n  /** Return a string representation of the access flags of method m.\n   * @param m the method whose access flags to retrieve\n   * @return a string representation of the access flags of method m\n   */\n  static String get_access_flags(Method m) {\n\n    int flags = m.getAccessFlags();\n\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n      if ((flags & pow) != 0) {\n        if (buf.length() > 0) {\n          buf.append(\" \");\n        }\n        if (i < Const.ACCESS_NAMES_LENGTH) {\n          buf.append(Const.getAccessName(i));\n        } else {\n          buf.append(String.format(\"ACC_BIT %x\", pow));\n        }\n      }\n      pow <<= 1;\n    }\n\n    return (buf.toString());\n  }\n\n  /**\n   * Return the attribute name for the specified attribute.\n   * @param a the attribute\n   * @return the attribute name for the specified attribute\n   */\n  public static String get_attribute_name(Attribute a) {\n\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n  }\n\n  /**\n   * Returns the constant string at the specified offset.\n   * @param pool the constant pool\n   * @param index the index in the constant pool\n   * @return the constant string at the specified offset in the constant pool\n   */\n  public static String get_constant_str(ConstantPool pool, int index) {\n\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n      return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n      ConstantClass cc = (ConstantClass) c;\n      return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n      throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n  }\n\n  /** Returns whether or not the method is a constructor.\n   * @param mg the method to test\n   * @return true iff the method is a constructor\n   */\n  public static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n  }\n\n  /** Returns whether or not the method is a constructor.\n   * @param m the method to test\n   * @return true iff the method is a constructor\n   */\n  public static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n  }\n\n  /** Returns whether or not the method is a class initializer.\n   * @param mg the method to test\n   * @return true iff the method is a class initializer\n   */\n  public static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n  }\n\n  /** Returns whether or not the method is a class initializer.\n   * @param m the method to test\n   * @return true iff the method is a class initializer\n   */\n  public static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n  }\n\n  /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param gen the class to test\n   * @return true iff the class is part of the JDK (rt.jar)\n   */\n  public static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n  }\n\n  /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param classname the class to test, in the format of Class.getName();\n   *   the class should not be an array\n   * @return true iff the class is part of the JDK (rt.jar)\n   */\n  public static boolean in_jdk(/*@ClassGetName*/ String classname) {\n    return classname.startsWith(\"java.\")\n        || classname.startsWith(\"com.\")\n        || classname.startsWith(\"javax.\")\n        || classname.startsWith(\"org.\")\n        || classname.startsWith(\"sun.\")\n        || classname.startsWith(\"sunw.\");\n  }\n\n  /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param classname the class to test, in internal form\n   * @return true iff the class is part of the JDK (rt.jar)\n   */\n  public static boolean in_jdk_internalform(/*@InternalForm*/ String classname) {\n    return classname.startsWith(\"java/\")\n        || classname.startsWith(\"com/\")\n        || classname.startsWith(\"javax/\")\n        || classname.startsWith(\"org/\")\n        || classname.startsWith(\"sun/\")\n        || classname.startsWith(\"sunw/\");\n  }\n\n  /**\n   * Print the methods in the class, to standard output.\n   * @param gen the class whose methods to print\n   */\n  static void dump_methods(ClassGen gen) {\n\n    System.out.printf(\"Class %s methods:%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n      System.out.printf(\"  %s%n\", m);\n    }\n  }\n\n  /**\n   * Checks the specific method for consistency.\n   * @param mgen the class to check\n   */\n  public static void checkMgen(MethodGen mgen) {\n\n    if (skip_checks) {\n      return;\n    }\n\n    try {\n      mgen.toString(); // ensure it can be formatted without exceptions\n      mgen.getLineNumberTable(mgen.getConstantPool());\n\n      InstructionList ilist = mgen.getInstructionList();\n      if (ilist == null || ilist.getStart() == null) {\n        return;\n      }\n      CodeExceptionGen[] exceptionHandlers = mgen.getExceptionHandlers();\n      for (CodeExceptionGen gen : exceptionHandlers) {\n        assert ilist.contains(gen.getStartPC())\n            : \"exception handler \"\n                + gen\n                + \" has been forgotten in \"\n                + mgen.getClassName()\n                + \".\"\n                + mgen.getName();\n      }\n      MethodGen nmg = new MethodGen(mgen.getMethod(), mgen.getClassName(), mgen.getConstantPool());\n      nmg.getLineNumberTable(mgen.getConstantPool());\n    } catch (Throwable t) {\n      System.out.printf(\"failure in method %s.%s%n\", mgen.getClassName(), mgen.getName());\n      t.printStackTrace();\n      throw new Error(t);\n    }\n  }\n\n  /**\n   * Checks all of the methods in gen for consistency.\n   * @param gen the class to check\n   */\n  public static void checkMgens(final ClassGen gen) {\n\n    if (skip_checks) {\n      return;\n    }\n\n    Method[] methods = gen.getMethods();\n    for (int i = 0; i < methods.length; i++) {\n      Method method = methods[i];\n      // System.out.println (\"Checking method \" + method + \" in class \"\n      // + gen.getClassName());\n      checkMgen(new MethodGen(method, gen.getClassName(), gen.getConstantPool()));\n    }\n\n    if (false) {\n      Throwable t = new Throwable();\n      t.fillInStackTrace();\n      StackTraceElement[] ste = t.getStackTrace();\n      StackTraceElement caller = ste[1];\n      System.out.printf(\n          \"%s.%s (%s line %d)\",\n          caller.getClassName(),\n          caller.getMethodName(),\n          caller.getFileName(),\n          caller.getLineNumber());\n      for (int ii = 2; ii < ste.length; ii++) {\n        System.out.printf(\" [%s line %d]\", ste[ii].getFileName(), ste[ii].getLineNumber());\n      }\n      System.out.printf(\"%n\");\n      dump_methods(gen);\n    }\n  }\n\n  /** Adds code in nl to start of method mg.\n   * @param mg method to be augmented\n   * @param nl instructions to prepend to the method\n   */\n  public static void add_to_start(MethodGen mg, InstructionList nl) {\n\n    // Add the code before the first instruction\n    InstructionList il = mg.getInstructionList();\n    InstructionHandle old_start = il.getStart();\n    InstructionHandle new_start = il.insert(nl);\n\n    // Move any LineNumbers and local variable that currently point to\n    // the first instruction to include the new instructions. Other\n    // targeters (branches, exceptions) should not include the new\n    // code\n    if (old_start.hasTargeters()) {\n      // getTargeters() returns non-null because hasTargeters => true\n      for (InstructionTargeter it : old_start.getTargeters()) {\n        if ((it instanceof LineNumberGen) || (it instanceof LocalVariableGen)) {\n          it.updateTarget(old_start, new_start);\n        }\n      }\n    }\n    mg.setMaxStack();\n    mg.setMaxLocals();\n  }\n\n  /**\n   * Dumps the contents of the specified class to the specified directory.\n   * The file is named dump_dir/[class].bcel.  It contains a synopsis\n   * of the fields and methods followed by the jvm code for each method.\n   * @param jc javaclass to dump\n   * @param dump_dir directory in which to write the file\n   * @see #dump(JavaClass, File)\n   */\n  public static void dump(JavaClass jc, String dump_dir) {\n\n    dump(jc, new File(dump_dir));\n  }\n\n  /**\n   * Dumps the contents of the specified class to the specified directory.\n   * The file is named dump_dir/[class].bcel.  It contains a synopsis\n   * of the fields and methods followed by the jvm code for each method.\n   *\n   * @param jc javaclass to dump\n   * @param dump_dir directory in which to write the file\n   */\n  public static void dump(JavaClass jc, File dump_dir) {\n\n    try {\n      dump_dir.mkdir();\n      File path = new File(dump_dir, jc.getClassName() + \".bcel\");\n      PrintStream p = new PrintStream(path);\n\n      // Print the class, super class and interfaces\n      p.printf(\"class %s extends %s%n\", jc.getClassName(), jc.getSuperclassName());\n      String[] inames = jc.getInterfaceNames();\n      if ((inames != null) && (inames.length > 0)) {\n        p.printf(\"   \");\n        for (String iname : inames) {\n          p.printf(\"implements %s \", iname);\n        }\n        p.printf(\"%n\");\n      }\n\n      // Print each field\n      p.printf(\"%nFields%n\");\n      for (Field f : jc.getFields()) {\n        p.printf(\"  %s%n\", f);\n      }\n\n      // Print the signature of each method\n      p.printf(\"%nMethods%n\");\n      for (Method m : jc.getMethods()) {\n        p.printf(\"  %s%n\", m);\n      }\n\n      // If this is not an interface, print the code for each method\n      if (!jc.isInterface()) {\n        for (Method m : jc.getMethods()) {\n          p.printf(\"%nMethod %s%n\", m);\n          Code code = m.getCode();\n          if (code != null) {\n            p.printf(\"  %s%n\", code.toString().replace(\"\\n\", \"\\n  \"));\n          }\n        }\n      }\n\n      // Print the details of the constant pool.\n      p.printf(\"Constant Pool:%n\");\n      ConstantPool cp = jc.getConstantPool();\n      Constant[] constants = cp.getConstantPool();\n      for (int ii = 0; ii < constants.length; ii++) {\n        p.printf(\"  %d %s%n\", ii, constants[ii]);\n      }\n\n      p.close();\n\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error dumping javaclass\", e);\n    }\n  }\n\n  // TODO: write Javadoc\n  @SuppressWarnings(\"rawtypes\")\n  public static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n      @SuppressWarnings(\n          \"nullness\") // BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n      /*@NonNull*/ InstructionHandle handle = (InstructionHandle) i.next();\n      out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n  }\n\n  /**\n   * Return a description of the local variables (one per line).\n   * @param mg the method whose local variables to describe\n   * @return a description of the local variables (one per line)\n   */\n  public static String local_var_descr(MethodGen mg) {\n\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n      for (LocalVariableGen lvg : lvgs) {\n        out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n      }\n    }\n    return (out.toString());\n  }\n\n  /**\n   * Builds an array of line numbers for the specified instruction list. Each\n   * opcode is assigned the next source line number starting at 1000.\n   * @param mg the method whose line numbers to extract\n   * @param il the instruction list to augment with line numbers\n   */\n  public static void add_line_numbers(MethodGen mg, InstructionList il) {\n\n    il.setPositions(true);\n    for (InstructionHandle ih : il.getInstructionHandles()) {\n      mg.addLineNumber(ih, 1000 + ih.getPosition());\n    }\n  }\n\n  /**\n   * Sets the locals to 'this' and each of the arguments. Any other locals are\n   * removed. An instruction list with at least one instruction must exist.\n   * @param mg the method whose locals to set\n   */\n  @SuppressWarnings(\"nullness\")\n  public static void setup_init_locals(MethodGen mg) {\n\n    // Get the parameter types and names.\n    Type[] arg_types = mg.getArgumentTypes();\n    String[] arg_names = mg.getArgumentNames();\n\n    // Remove any existing locals\n    mg.setMaxLocals(0);\n    mg.removeLocalVariables();\n\n    // Add a local for the instance variable (this)\n    if (!mg.isStatic()) {\n      mg.addLocalVariable(\"this\", new ObjectType(mg.getClassName()), null, null);\n    }\n\n    // Add a local for each parameter\n    for (int ii = 0; ii < arg_names.length; ii++) {\n      mg.addLocalVariable(arg_names[ii], arg_types[ii], null, null);\n    }\n\n    // Reset the current number of locals so that when other locals\n    // are added they get added at the correct offset\n    mg.setMaxLocals();\n\n    return;\n  }\n\n  /**\n   * Empties the method of all code (except for a return).  This\n   * includes line numbers, exceptions, local variables, etc.\n   * @param mg the method to clear out\n   */\n  public static void empty_method(MethodGen mg) {\n\n    mg.setInstructionList(new InstructionList(new RETURN()));\n    mg.removeExceptionHandlers();\n    mg.removeLineNumbers();\n    mg.removeLocalVariables();\n    mg.setMaxLocals();\n  }\n\n  /**\n   * Remove the local variable type table attribute (LVTT) from mg.\n   * Evidently some changes require this to be updated, but without\n   * BCEL support that would be hard to do.  It should be safe to just delete\n   * it since it is optional and really only of use to a debugger.\n   * @param mg the method to clear out\n   */\n  public static void remove_local_variable_type_tables(MethodGen mg) {\n\n    for (Attribute a : mg.getCodeAttributes()) {\n      if (is_local_variable_type_table(a, mg.getConstantPool())) {\n        mg.removeCodeAttribute(a);\n      }\n    }\n  }\n\n  /**\n   * Returns whether or not the specified attribute is a local variable type\n   * table.\n   * @param a the attribute\n   * @param pool the constant pool\n   * @return true iff the attribute is a local variable type table\n   */\n  public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n  }\n\n  /**\n   * Return the attribute name for the specified attribute.\n   * @param a the attribute\n   * @param pool the constant pool\n   * @return the attribute name for the specified attribute\n   */\n  public static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n  }\n\n  /**\n   * Returns whether or not this is a standard main method (static,\n   * name is 'main', and one argument of string array).\n   * @param mg the method to check\n   * @return true iff the method is a main method\n   */\n  public static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic()\n        && mg.getName().equals(\"main\")\n        && (arg_types.length == 1)\n        && arg_types[0].equals(string_array));\n  }\n\n  /**\n   * Returns the Java class name, in the format of {@link Class#getName()},\n   * that corresponds to type.\n   * @param type the type\n   * @return the Java classname that corresponds to type\n   */\n  public static /*@ClassGetName*/ String type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n  }\n\n  /**\n   * Returns the class that corresponds to type.\n   * @param type the type\n   * @return the Java class that corresponds to type\n   */\n  public static Class<?> type_to_class(Type type) {\n\n    String classname = type_to_classgetname(type);\n    try {\n      Class<?> c = UtilMDE.classForName(classname);\n      return c;\n    } catch (Exception e) {\n      throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n  }\n\n  /**\n   * Returns a type array with new_type added to the end of types.\n   * @param types the array to extend\n   * @param new_type the element to add to the end of the types array\n   * @return the array (or a new one), with new_type at the end\n   */\n  public static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n  }\n\n  /**\n   * Returns a type array with new_type inserted at the beginning.\n   * @param types the array to extend\n   * @param new_type the element to add to the beginning of the types array\n   * @return the array (or a new one), with new_type at the beginning\n   */\n  public static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n  }\n\n  /**\n   * Return the type corresponding to a given class name.\n   * @param classname the class to convert to a type\n   * @return the type corresponding to the given class name\n   */\n  public static Type classname_to_type(String classname) {\n\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n      classname = classname.substring(0, classname.length() - 2);\n      array_depth++;\n    }\n    classname = classname.intern();\n\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") { // interned\n      t = Type.INT;\n    } else if (classname == \"boolean\") { // interned\n      t = Type.BOOLEAN;\n    } else if (classname == \"byte\") { // interned\n      t = Type.BYTE;\n    } else if (classname == \"char\") { // interned\n      t = Type.CHAR;\n    } else if (classname == \"double\") { // interned\n      t = Type.DOUBLE;\n    } else if (classname == \"float\") { // interned\n      t = Type.FLOAT;\n    } else if (classname == \"long\") { // interned\n      t = Type.LONG;\n    } else if (classname == \"short\") { // interned\n      t = Type.SHORT;\n    } else { // must be a non-primitive\n      t = new ObjectType(classname);\n    }\n\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n      t = new ArrayType(t, array_depth);\n    }\n\n    return t;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "classname", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10381,
  "oracle" : "(mg == null) == false;",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "BCELUtil",
  "javadocTag" : "@param mg the method whose local variables to describe",
  "methodJavadoc" : "    /**\n   * Return a description of the local variables (one per line).\n   * @param mg the method whose local variables to describe\n   * @return a description of the local variables (one per line)\n   */",
  "methodSourceCode" : "public static String local_var_descr(MethodGen mg){\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n        for (LocalVariableGen lvg : lvgs) {\n            out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n        }\n    }\n    return (out.toString());\n}",
  "classJavadoc" : "/**\n * Static utility methods for working with BCEL.\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.PrintStream;\nimport java.util.Formatter;\nimport java.util.Iterator;\nimport org.apache.commons.bcel6.Const;\nimport org.apache.commons.bcel6.classfile.Attribute;\nimport org.apache.commons.bcel6.classfile.Code;\nimport org.apache.commons.bcel6.classfile.Constant;\nimport org.apache.commons.bcel6.classfile.ConstantClass;\nimport org.apache.commons.bcel6.classfile.ConstantPool;\nimport org.apache.commons.bcel6.classfile.ConstantUtf8;\nimport org.apache.commons.bcel6.classfile.Field;\nimport org.apache.commons.bcel6.classfile.JavaClass;\nimport org.apache.commons.bcel6.classfile.Method;\nimport org.apache.commons.bcel6.generic.ArrayType;\nimport org.apache.commons.bcel6.generic.ClassGen;\nimport org.apache.commons.bcel6.generic.CodeExceptionGen;\nimport org.apache.commons.bcel6.generic.ConstantPoolGen;\nimport org.apache.commons.bcel6.generic.InstructionHandle;\nimport org.apache.commons.bcel6.generic.InstructionList;\nimport org.apache.commons.bcel6.generic.InstructionTargeter;\nimport org.apache.commons.bcel6.generic.LineNumberGen;\nimport org.apache.commons.bcel6.generic.LocalVariableGen;\nimport org.apache.commons.bcel6.generic.MethodGen;\nimport org.apache.commons.bcel6.generic.ObjectType;\nimport org.apache.commons.bcel6.generic.RETURN;\nimport org.apache.commons.bcel6.generic.Type;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\n*/\n\n/**\n * Static utility methods for working with BCEL.\n */\npublic final class BCELUtil {\n  /** This class is a collection of methods; it does not represent anything. */\n  private BCELUtil() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  /** Controls whether the checks in checkMgen are actually performed. */\n  public static boolean skip_checks = false;\n\n  /** The type that represents String[]. */\n  private static final Type string_array = Type.getType(\"[Ljava.lang.String;\");\n\n  /** Prints method declarations to System.out.\n   * @param gen class whose methods to print\n   */\n  static void dump_method_declarations(ClassGen gen) {\n    System.out.printf(\"method signatures for class %s%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n      System.out.printf(\"  %s%n\", get_method_declaration(m));\n    }\n  }\n\n  /**\n   * Returns a string describing a method declaration. It contains the access\n   * flags (public, private, static, etc), the return type, the method name, and\n   * the types of each of its arguments.\n   * @param m the method\n   * @return a string describing the method declaration\n   */\n  public static String get_method_declaration(Method m) {\n\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n      f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n  }\n\n  /** Return a string representation of the access flags of method m.\n   * @param m the method whose access flags to retrieve\n   * @return a string representation of the access flags of method m\n   */\n  static String get_access_flags(Method m) {\n\n    int flags = m.getAccessFlags();\n\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n      if ((flags & pow) != 0) {\n        if (buf.length() > 0) {\n          buf.append(\" \");\n        }\n        if (i < Const.ACCESS_NAMES_LENGTH) {\n          buf.append(Const.getAccessName(i));\n        } else {\n          buf.append(String.format(\"ACC_BIT %x\", pow));\n        }\n      }\n      pow <<= 1;\n    }\n\n    return (buf.toString());\n  }\n\n  /**\n   * Return the attribute name for the specified attribute.\n   * @param a the attribute\n   * @return the attribute name for the specified attribute\n   */\n  public static String get_attribute_name(Attribute a) {\n\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n  }\n\n  /**\n   * Returns the constant string at the specified offset.\n   * @param pool the constant pool\n   * @param index the index in the constant pool\n   * @return the constant string at the specified offset in the constant pool\n   */\n  public static String get_constant_str(ConstantPool pool, int index) {\n\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n      return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n      ConstantClass cc = (ConstantClass) c;\n      return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n      throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n  }\n\n  /** Returns whether or not the method is a constructor.\n   * @param mg the method to test\n   * @return true iff the method is a constructor\n   */\n  public static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n  }\n\n  /** Returns whether or not the method is a constructor.\n   * @param m the method to test\n   * @return true iff the method is a constructor\n   */\n  public static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n  }\n\n  /** Returns whether or not the method is a class initializer.\n   * @param mg the method to test\n   * @return true iff the method is a class initializer\n   */\n  public static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n  }\n\n  /** Returns whether or not the method is a class initializer.\n   * @param m the method to test\n   * @return true iff the method is a class initializer\n   */\n  public static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n  }\n\n  /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param gen the class to test\n   * @return true iff the class is part of the JDK (rt.jar)\n   */\n  public static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n  }\n\n  /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param classname the class to test, in the format of Class.getName();\n   *   the class should not be an array\n   * @return true iff the class is part of the JDK (rt.jar)\n   */\n  public static boolean in_jdk(/*@ClassGetName*/ String classname) {\n    return classname.startsWith(\"java.\")\n        || classname.startsWith(\"com.\")\n        || classname.startsWith(\"javax.\")\n        || classname.startsWith(\"org.\")\n        || classname.startsWith(\"sun.\")\n        || classname.startsWith(\"sunw.\");\n  }\n\n  /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param classname the class to test, in internal form\n   * @return true iff the class is part of the JDK (rt.jar)\n   */\n  public static boolean in_jdk_internalform(/*@InternalForm*/ String classname) {\n    return classname.startsWith(\"java/\")\n        || classname.startsWith(\"com/\")\n        || classname.startsWith(\"javax/\")\n        || classname.startsWith(\"org/\")\n        || classname.startsWith(\"sun/\")\n        || classname.startsWith(\"sunw/\");\n  }\n\n  /**\n   * Print the methods in the class, to standard output.\n   * @param gen the class whose methods to print\n   */\n  static void dump_methods(ClassGen gen) {\n\n    System.out.printf(\"Class %s methods:%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n      System.out.printf(\"  %s%n\", m);\n    }\n  }\n\n  /**\n   * Checks the specific method for consistency.\n   * @param mgen the class to check\n   */\n  public static void checkMgen(MethodGen mgen) {\n\n    if (skip_checks) {\n      return;\n    }\n\n    try {\n      mgen.toString(); // ensure it can be formatted without exceptions\n      mgen.getLineNumberTable(mgen.getConstantPool());\n\n      InstructionList ilist = mgen.getInstructionList();\n      if (ilist == null || ilist.getStart() == null) {\n        return;\n      }\n      CodeExceptionGen[] exceptionHandlers = mgen.getExceptionHandlers();\n      for (CodeExceptionGen gen : exceptionHandlers) {\n        assert ilist.contains(gen.getStartPC())\n            : \"exception handler \"\n                + gen\n                + \" has been forgotten in \"\n                + mgen.getClassName()\n                + \".\"\n                + mgen.getName();\n      }\n      MethodGen nmg = new MethodGen(mgen.getMethod(), mgen.getClassName(), mgen.getConstantPool());\n      nmg.getLineNumberTable(mgen.getConstantPool());\n    } catch (Throwable t) {\n      System.out.printf(\"failure in method %s.%s%n\", mgen.getClassName(), mgen.getName());\n      t.printStackTrace();\n      throw new Error(t);\n    }\n  }\n\n  /**\n   * Checks all of the methods in gen for consistency.\n   * @param gen the class to check\n   */\n  public static void checkMgens(final ClassGen gen) {\n\n    if (skip_checks) {\n      return;\n    }\n\n    Method[] methods = gen.getMethods();\n    for (int i = 0; i < methods.length; i++) {\n      Method method = methods[i];\n      // System.out.println (\"Checking method \" + method + \" in class \"\n      // + gen.getClassName());\n      checkMgen(new MethodGen(method, gen.getClassName(), gen.getConstantPool()));\n    }\n\n    if (false) {\n      Throwable t = new Throwable();\n      t.fillInStackTrace();\n      StackTraceElement[] ste = t.getStackTrace();\n      StackTraceElement caller = ste[1];\n      System.out.printf(\n          \"%s.%s (%s line %d)\",\n          caller.getClassName(),\n          caller.getMethodName(),\n          caller.getFileName(),\n          caller.getLineNumber());\n      for (int ii = 2; ii < ste.length; ii++) {\n        System.out.printf(\" [%s line %d]\", ste[ii].getFileName(), ste[ii].getLineNumber());\n      }\n      System.out.printf(\"%n\");\n      dump_methods(gen);\n    }\n  }\n\n  /** Adds code in nl to start of method mg.\n   * @param mg method to be augmented\n   * @param nl instructions to prepend to the method\n   */\n  public static void add_to_start(MethodGen mg, InstructionList nl) {\n\n    // Add the code before the first instruction\n    InstructionList il = mg.getInstructionList();\n    InstructionHandle old_start = il.getStart();\n    InstructionHandle new_start = il.insert(nl);\n\n    // Move any LineNumbers and local variable that currently point to\n    // the first instruction to include the new instructions. Other\n    // targeters (branches, exceptions) should not include the new\n    // code\n    if (old_start.hasTargeters()) {\n      // getTargeters() returns non-null because hasTargeters => true\n      for (InstructionTargeter it : old_start.getTargeters()) {\n        if ((it instanceof LineNumberGen) || (it instanceof LocalVariableGen)) {\n          it.updateTarget(old_start, new_start);\n        }\n      }\n    }\n    mg.setMaxStack();\n    mg.setMaxLocals();\n  }\n\n  /**\n   * Dumps the contents of the specified class to the specified directory.\n   * The file is named dump_dir/[class].bcel.  It contains a synopsis\n   * of the fields and methods followed by the jvm code for each method.\n   * @param jc javaclass to dump\n   * @param dump_dir directory in which to write the file\n   * @see #dump(JavaClass, File)\n   */\n  public static void dump(JavaClass jc, String dump_dir) {\n\n    dump(jc, new File(dump_dir));\n  }\n\n  /**\n   * Dumps the contents of the specified class to the specified directory.\n   * The file is named dump_dir/[class].bcel.  It contains a synopsis\n   * of the fields and methods followed by the jvm code for each method.\n   *\n   * @param jc javaclass to dump\n   * @param dump_dir directory in which to write the file\n   */\n  public static void dump(JavaClass jc, File dump_dir) {\n\n    try {\n      dump_dir.mkdir();\n      File path = new File(dump_dir, jc.getClassName() + \".bcel\");\n      PrintStream p = new PrintStream(path);\n\n      // Print the class, super class and interfaces\n      p.printf(\"class %s extends %s%n\", jc.getClassName(), jc.getSuperclassName());\n      String[] inames = jc.getInterfaceNames();\n      if ((inames != null) && (inames.length > 0)) {\n        p.printf(\"   \");\n        for (String iname : inames) {\n          p.printf(\"implements %s \", iname);\n        }\n        p.printf(\"%n\");\n      }\n\n      // Print each field\n      p.printf(\"%nFields%n\");\n      for (Field f : jc.getFields()) {\n        p.printf(\"  %s%n\", f);\n      }\n\n      // Print the signature of each method\n      p.printf(\"%nMethods%n\");\n      for (Method m : jc.getMethods()) {\n        p.printf(\"  %s%n\", m);\n      }\n\n      // If this is not an interface, print the code for each method\n      if (!jc.isInterface()) {\n        for (Method m : jc.getMethods()) {\n          p.printf(\"%nMethod %s%n\", m);\n          Code code = m.getCode();\n          if (code != null) {\n            p.printf(\"  %s%n\", code.toString().replace(\"\\n\", \"\\n  \"));\n          }\n        }\n      }\n\n      // Print the details of the constant pool.\n      p.printf(\"Constant Pool:%n\");\n      ConstantPool cp = jc.getConstantPool();\n      Constant[] constants = cp.getConstantPool();\n      for (int ii = 0; ii < constants.length; ii++) {\n        p.printf(\"  %d %s%n\", ii, constants[ii]);\n      }\n\n      p.close();\n\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error dumping javaclass\", e);\n    }\n  }\n\n  // TODO: write Javadoc\n  @SuppressWarnings(\"rawtypes\")\n  public static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n      @SuppressWarnings(\n          \"nullness\") // BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n      /*@NonNull*/ InstructionHandle handle = (InstructionHandle) i.next();\n      out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n  }\n\n  /**\n   * Return a description of the local variables (one per line).\n   * @param mg the method whose local variables to describe\n   * @return a description of the local variables (one per line)\n   */\n  public static String local_var_descr(MethodGen mg) {\n\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n      for (LocalVariableGen lvg : lvgs) {\n        out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n      }\n    }\n    return (out.toString());\n  }\n\n  /**\n   * Builds an array of line numbers for the specified instruction list. Each\n   * opcode is assigned the next source line number starting at 1000.\n   * @param mg the method whose line numbers to extract\n   * @param il the instruction list to augment with line numbers\n   */\n  public static void add_line_numbers(MethodGen mg, InstructionList il) {\n\n    il.setPositions(true);\n    for (InstructionHandle ih : il.getInstructionHandles()) {\n      mg.addLineNumber(ih, 1000 + ih.getPosition());\n    }\n  }\n\n  /**\n   * Sets the locals to 'this' and each of the arguments. Any other locals are\n   * removed. An instruction list with at least one instruction must exist.\n   * @param mg the method whose locals to set\n   */\n  @SuppressWarnings(\"nullness\")\n  public static void setup_init_locals(MethodGen mg) {\n\n    // Get the parameter types and names.\n    Type[] arg_types = mg.getArgumentTypes();\n    String[] arg_names = mg.getArgumentNames();\n\n    // Remove any existing locals\n    mg.setMaxLocals(0);\n    mg.removeLocalVariables();\n\n    // Add a local for the instance variable (this)\n    if (!mg.isStatic()) {\n      mg.addLocalVariable(\"this\", new ObjectType(mg.getClassName()), null, null);\n    }\n\n    // Add a local for each parameter\n    for (int ii = 0; ii < arg_names.length; ii++) {\n      mg.addLocalVariable(arg_names[ii], arg_types[ii], null, null);\n    }\n\n    // Reset the current number of locals so that when other locals\n    // are added they get added at the correct offset\n    mg.setMaxLocals();\n\n    return;\n  }\n\n  /**\n   * Empties the method of all code (except for a return).  This\n   * includes line numbers, exceptions, local variables, etc.\n   * @param mg the method to clear out\n   */\n  public static void empty_method(MethodGen mg) {\n\n    mg.setInstructionList(new InstructionList(new RETURN()));\n    mg.removeExceptionHandlers();\n    mg.removeLineNumbers();\n    mg.removeLocalVariables();\n    mg.setMaxLocals();\n  }\n\n  /**\n   * Remove the local variable type table attribute (LVTT) from mg.\n   * Evidently some changes require this to be updated, but without\n   * BCEL support that would be hard to do.  It should be safe to just delete\n   * it since it is optional and really only of use to a debugger.\n   * @param mg the method to clear out\n   */\n  public static void remove_local_variable_type_tables(MethodGen mg) {\n\n    for (Attribute a : mg.getCodeAttributes()) {\n      if (is_local_variable_type_table(a, mg.getConstantPool())) {\n        mg.removeCodeAttribute(a);\n      }\n    }\n  }\n\n  /**\n   * Returns whether or not the specified attribute is a local variable type\n   * table.\n   * @param a the attribute\n   * @param pool the constant pool\n   * @return true iff the attribute is a local variable type table\n   */\n  public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n  }\n\n  /**\n   * Return the attribute name for the specified attribute.\n   * @param a the attribute\n   * @param pool the constant pool\n   * @return the attribute name for the specified attribute\n   */\n  public static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n  }\n\n  /**\n   * Returns whether or not this is a standard main method (static,\n   * name is 'main', and one argument of string array).\n   * @param mg the method to check\n   * @return true iff the method is a main method\n   */\n  public static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic()\n        && mg.getName().equals(\"main\")\n        && (arg_types.length == 1)\n        && arg_types[0].equals(string_array));\n  }\n\n  /**\n   * Returns the Java class name, in the format of {@link Class#getName()},\n   * that corresponds to type.\n   * @param type the type\n   * @return the Java classname that corresponds to type\n   */\n  public static /*@ClassGetName*/ String type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n  }\n\n  /**\n   * Returns the class that corresponds to type.\n   * @param type the type\n   * @return the Java class that corresponds to type\n   */\n  public static Class<?> type_to_class(Type type) {\n\n    String classname = type_to_classgetname(type);\n    try {\n      Class<?> c = UtilMDE.classForName(classname);\n      return c;\n    } catch (Exception e) {\n      throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n  }\n\n  /**\n   * Returns a type array with new_type added to the end of types.\n   * @param types the array to extend\n   * @param new_type the element to add to the end of the types array\n   * @return the array (or a new one), with new_type at the end\n   */\n  public static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n  }\n\n  /**\n   * Returns a type array with new_type inserted at the beginning.\n   * @param types the array to extend\n   * @param new_type the element to add to the beginning of the types array\n   * @return the array (or a new one), with new_type at the beginning\n   */\n  public static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n  }\n\n  /**\n   * Return the type corresponding to a given class name.\n   * @param classname the class to convert to a type\n   * @return the type corresponding to the given class name\n   */\n  public static Type classname_to_type(String classname) {\n\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n      classname = classname.substring(0, classname.length() - 2);\n      array_depth++;\n    }\n    classname = classname.intern();\n\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") { // interned\n      t = Type.INT;\n    } else if (classname == \"boolean\") { // interned\n      t = Type.BOOLEAN;\n    } else if (classname == \"byte\") { // interned\n      t = Type.BYTE;\n    } else if (classname == \"char\") { // interned\n      t = Type.CHAR;\n    } else if (classname == \"double\") { // interned\n      t = Type.DOUBLE;\n    } else if (classname == \"float\") { // interned\n      t = Type.FLOAT;\n    } else if (classname == \"long\") { // interned\n      t = Type.LONG;\n    } else if (classname == \"short\") { // interned\n      t = Type.SHORT;\n    } else { // must be a non-primitive\n      t = new ObjectType(classname);\n    }\n\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n      t = new ArrayType(t, array_depth);\n    }\n\n    return t;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "mg", "org.apache.commons.bcel6.generic", "MethodGen" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getInstructionList", "org.apache.commons.bcel6.generic", "MethodGen", "public InstructionList getInstructionList()" ], [ "addLineNumber", "org.apache.commons.bcel6.generic", "MethodGen", "public LineNumberGen addLineNumber(InstructionHandle arg0, int arg1)" ], [ "getArgumentTypes", "org.apache.commons.bcel6.generic", "MethodGen", "public Type[] getArgumentTypes()" ], [ "equals", "org.apache.commons.bcel6.generic", "MethodGen", "public boolean equals(Object arg0)" ], [ "getMaxLocals", "org.apache.commons.bcel6.generic", "MethodGen", "public int getMaxLocals()" ], [ "getArgumentName", "org.apache.commons.bcel6.generic", "MethodGen", "public String getArgumentName(int arg0)" ], [ "addExceptionHandler", "org.apache.commons.bcel6.generic", "MethodGen", "public CodeExceptionGen addExceptionHandler(InstructionHandle arg0, InstructionHandle arg1, InstructionHandle arg2, ObjectType arg3)" ], [ "getExceptionHandlers", "org.apache.commons.bcel6.generic", "MethodGen", "public CodeExceptionGen[] getExceptionHandlers()" ], [ "getAnnotationsOnParameter", "org.apache.commons.bcel6.generic", "MethodGen", "public List<AnnotationEntryGen> getAnnotationsOnParameter(int arg0)" ], [ "getArgumentNames", "org.apache.commons.bcel6.generic", "MethodGen", "public String[] getArgumentNames()" ], [ "copy", "org.apache.commons.bcel6.generic", "MethodGen", "public MethodGen copy(String arg0, ConstantPoolGen arg1)" ], [ "getExceptions", "org.apache.commons.bcel6.generic", "MethodGen", "public String[] getExceptions()" ], [ "toString", "org.apache.commons.bcel6.generic", "MethodGen", "public final String toString()" ], [ "getLineNumbers", "org.apache.commons.bcel6.generic", "MethodGen", "public LineNumberGen[] getLineNumbers()" ], [ "getLocalVariableTable", "org.apache.commons.bcel6.generic", "MethodGen", "public LocalVariableTable getLocalVariableTable(ConstantPoolGen arg0)" ], [ "getMaxStack", "org.apache.commons.bcel6.generic", "MethodGen", "public int getMaxStack()" ], [ "getClassName", "org.apache.commons.bcel6.generic", "MethodGen", "public String getClassName()" ], [ "getSignature", "org.apache.commons.bcel6.generic", "MethodGen", "public String getSignature()" ], [ "getReturnType", "org.apache.commons.bcel6.generic", "MethodGen", "public Type getReturnType()" ], [ "addLocalVariable", "org.apache.commons.bcel6.generic", "MethodGen", "public LocalVariableGen addLocalVariable(String arg0, Type arg1, int arg2, InstructionHandle arg3, InstructionHandle arg4)" ], [ "getLineNumberTable", "org.apache.commons.bcel6.generic", "MethodGen", "public LineNumberTable getLineNumberTable(ConstantPoolGen arg0)" ], [ "getMethod", "org.apache.commons.bcel6.generic", "MethodGen", "public Method getMethod()" ], [ "addLocalVariable", "org.apache.commons.bcel6.generic", "MethodGen", "public LocalVariableGen addLocalVariable(String arg0, Type arg1, InstructionHandle arg2, InstructionHandle arg3)" ], [ "getArgumentType", "org.apache.commons.bcel6.generic", "MethodGen", "public Type getArgumentType(int arg0)" ], [ "getCodeAttributes", "org.apache.commons.bcel6.generic", "MethodGen", "public Attribute[] getCodeAttributes()" ], [ "getLocalVariables", "org.apache.commons.bcel6.generic", "MethodGen", "public LocalVariableGen[] getLocalVariables()" ], [ "hashCode", "org.apache.commons.bcel6.generic", "MethodGen", "public int hashCode()" ], [ "getAttributes", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public Attribute[] getAttributes()" ], [ "getName", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public String getName()" ], [ "clone", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public Object clone()" ], [ "getSignature", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public abstract String getSignature()" ], [ "getConstantPool", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public ConstantPoolGen getConstantPool()" ], [ "getType", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public Type getType()" ], [ "getAnnotationEntries", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public AnnotationEntryGen[] getAnnotationEntries()" ], [ "isPrivate", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isPrivate()" ], [ "getAccessFlags", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final int getAccessFlags()" ], [ "isSynchronized", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isSynchronized()" ], [ "isTransient", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isTransient()" ], [ "isStatic", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isStatic()" ], [ "isAnnotation", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isAnnotation()" ], [ "getModifiers", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final int getModifiers()" ], [ "isPublic", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isPublic()" ], [ "isProtected", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isProtected()" ], [ "isSynthetic", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isSynthetic()" ], [ "isEnum", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isEnum()" ], [ "isVolatile", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isVolatile()" ], [ "isStrictfp", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isStrictfp()" ], [ "isInterface", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isInterface()" ], [ "isFinal", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isFinal()" ], [ "isNative", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isNative()" ], [ "isAbstract", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isAbstract()" ], [ "getName", "org.apache.commons.bcel6.generic", "NamedAndTyped", "public abstract String getName()" ], [ "getType", "org.apache.commons.bcel6.generic", "NamedAndTyped", "public abstract Type getType()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "name", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "protected String name;" ], [ "type", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "protected Type type;" ], [ "cp", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "protected ConstantPoolGen cp;" ], [ "access_flags", "org.apache.commons.bcel6.classfile", "AccessFlags", "protected int access_flags;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10384,
  "oracle" : "(il == null) == false;",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "BCELUtil",
  "javadocTag" : "@param il the instruction list to augment with line numbers",
  "methodJavadoc" : "    /**\n   * Builds an array of line numbers for the specified instruction list. Each\n   * opcode is assigned the next source line number starting at 1000.\n   * @param mg the method whose line numbers to extract\n   * @param il the instruction list to augment with line numbers\n   */",
  "methodSourceCode" : "public static void add_line_numbers(MethodGen mg, InstructionList il){\n    il.setPositions(true);\n    for (InstructionHandle ih : il.getInstructionHandles()) {\n        mg.addLineNumber(ih, 1000 + ih.getPosition());\n    }\n}",
  "classJavadoc" : "/**\n * Static utility methods for working with BCEL.\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.File;\nimport java.io.PrintStream;\nimport java.util.Formatter;\nimport java.util.Iterator;\nimport org.apache.commons.bcel6.Const;\nimport org.apache.commons.bcel6.classfile.Attribute;\nimport org.apache.commons.bcel6.classfile.Code;\nimport org.apache.commons.bcel6.classfile.Constant;\nimport org.apache.commons.bcel6.classfile.ConstantClass;\nimport org.apache.commons.bcel6.classfile.ConstantPool;\nimport org.apache.commons.bcel6.classfile.ConstantUtf8;\nimport org.apache.commons.bcel6.classfile.Field;\nimport org.apache.commons.bcel6.classfile.JavaClass;\nimport org.apache.commons.bcel6.classfile.Method;\nimport org.apache.commons.bcel6.generic.ArrayType;\nimport org.apache.commons.bcel6.generic.ClassGen;\nimport org.apache.commons.bcel6.generic.CodeExceptionGen;\nimport org.apache.commons.bcel6.generic.ConstantPoolGen;\nimport org.apache.commons.bcel6.generic.InstructionHandle;\nimport org.apache.commons.bcel6.generic.InstructionList;\nimport org.apache.commons.bcel6.generic.InstructionTargeter;\nimport org.apache.commons.bcel6.generic.LineNumberGen;\nimport org.apache.commons.bcel6.generic.LocalVariableGen;\nimport org.apache.commons.bcel6.generic.MethodGen;\nimport org.apache.commons.bcel6.generic.ObjectType;\nimport org.apache.commons.bcel6.generic.RETURN;\nimport org.apache.commons.bcel6.generic.Type;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\n*/\n\n/**\n * Static utility methods for working with BCEL.\n */\npublic final class BCELUtil {\n  /** This class is a collection of methods; it does not represent anything. */\n  private BCELUtil() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  /** Controls whether the checks in checkMgen are actually performed. */\n  public static boolean skip_checks = false;\n\n  /** The type that represents String[]. */\n  private static final Type string_array = Type.getType(\"[Ljava.lang.String;\");\n\n  /** Prints method declarations to System.out.\n   * @param gen class whose methods to print\n   */\n  static void dump_method_declarations(ClassGen gen) {\n    System.out.printf(\"method signatures for class %s%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n      System.out.printf(\"  %s%n\", get_method_declaration(m));\n    }\n  }\n\n  /**\n   * Returns a string describing a method declaration. It contains the access\n   * flags (public, private, static, etc), the return type, the method name, and\n   * the types of each of its arguments.\n   * @param m the method\n   * @return a string describing the method declaration\n   */\n  public static String get_method_declaration(Method m) {\n\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n      f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n  }\n\n  /** Return a string representation of the access flags of method m.\n   * @param m the method whose access flags to retrieve\n   * @return a string representation of the access flags of method m\n   */\n  static String get_access_flags(Method m) {\n\n    int flags = m.getAccessFlags();\n\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n      if ((flags & pow) != 0) {\n        if (buf.length() > 0) {\n          buf.append(\" \");\n        }\n        if (i < Const.ACCESS_NAMES_LENGTH) {\n          buf.append(Const.getAccessName(i));\n        } else {\n          buf.append(String.format(\"ACC_BIT %x\", pow));\n        }\n      }\n      pow <<= 1;\n    }\n\n    return (buf.toString());\n  }\n\n  /**\n   * Return the attribute name for the specified attribute.\n   * @param a the attribute\n   * @return the attribute name for the specified attribute\n   */\n  public static String get_attribute_name(Attribute a) {\n\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n  }\n\n  /**\n   * Returns the constant string at the specified offset.\n   * @param pool the constant pool\n   * @param index the index in the constant pool\n   * @return the constant string at the specified offset in the constant pool\n   */\n  public static String get_constant_str(ConstantPool pool, int index) {\n\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n      return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n      ConstantClass cc = (ConstantClass) c;\n      return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n      throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n  }\n\n  /** Returns whether or not the method is a constructor.\n   * @param mg the method to test\n   * @return true iff the method is a constructor\n   */\n  public static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n  }\n\n  /** Returns whether or not the method is a constructor.\n   * @param m the method to test\n   * @return true iff the method is a constructor\n   */\n  public static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n  }\n\n  /** Returns whether or not the method is a class initializer.\n   * @param mg the method to test\n   * @return true iff the method is a class initializer\n   */\n  public static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n  }\n\n  /** Returns whether or not the method is a class initializer.\n   * @param m the method to test\n   * @return true iff the method is a class initializer\n   */\n  public static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n  }\n\n  /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param gen the class to test\n   * @return true iff the class is part of the JDK (rt.jar)\n   */\n  public static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n  }\n\n  /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param classname the class to test, in the format of Class.getName();\n   *   the class should not be an array\n   * @return true iff the class is part of the JDK (rt.jar)\n   */\n  public static boolean in_jdk(/*@ClassGetName*/ String classname) {\n    return classname.startsWith(\"java.\")\n        || classname.startsWith(\"com.\")\n        || classname.startsWith(\"javax.\")\n        || classname.startsWith(\"org.\")\n        || classname.startsWith(\"sun.\")\n        || classname.startsWith(\"sunw.\");\n  }\n\n  /** Returns whether or not the class is part of the JDK (rt.jar).\n   * @param classname the class to test, in internal form\n   * @return true iff the class is part of the JDK (rt.jar)\n   */\n  public static boolean in_jdk_internalform(/*@InternalForm*/ String classname) {\n    return classname.startsWith(\"java/\")\n        || classname.startsWith(\"com/\")\n        || classname.startsWith(\"javax/\")\n        || classname.startsWith(\"org/\")\n        || classname.startsWith(\"sun/\")\n        || classname.startsWith(\"sunw/\");\n  }\n\n  /**\n   * Print the methods in the class, to standard output.\n   * @param gen the class whose methods to print\n   */\n  static void dump_methods(ClassGen gen) {\n\n    System.out.printf(\"Class %s methods:%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n      System.out.printf(\"  %s%n\", m);\n    }\n  }\n\n  /**\n   * Checks the specific method for consistency.\n   * @param mgen the class to check\n   */\n  public static void checkMgen(MethodGen mgen) {\n\n    if (skip_checks) {\n      return;\n    }\n\n    try {\n      mgen.toString(); // ensure it can be formatted without exceptions\n      mgen.getLineNumberTable(mgen.getConstantPool());\n\n      InstructionList ilist = mgen.getInstructionList();\n      if (ilist == null || ilist.getStart() == null) {\n        return;\n      }\n      CodeExceptionGen[] exceptionHandlers = mgen.getExceptionHandlers();\n      for (CodeExceptionGen gen : exceptionHandlers) {\n        assert ilist.contains(gen.getStartPC())\n            : \"exception handler \"\n                + gen\n                + \" has been forgotten in \"\n                + mgen.getClassName()\n                + \".\"\n                + mgen.getName();\n      }\n      MethodGen nmg = new MethodGen(mgen.getMethod(), mgen.getClassName(), mgen.getConstantPool());\n      nmg.getLineNumberTable(mgen.getConstantPool());\n    } catch (Throwable t) {\n      System.out.printf(\"failure in method %s.%s%n\", mgen.getClassName(), mgen.getName());\n      t.printStackTrace();\n      throw new Error(t);\n    }\n  }\n\n  /**\n   * Checks all of the methods in gen for consistency.\n   * @param gen the class to check\n   */\n  public static void checkMgens(final ClassGen gen) {\n\n    if (skip_checks) {\n      return;\n    }\n\n    Method[] methods = gen.getMethods();\n    for (int i = 0; i < methods.length; i++) {\n      Method method = methods[i];\n      // System.out.println (\"Checking method \" + method + \" in class \"\n      // + gen.getClassName());\n      checkMgen(new MethodGen(method, gen.getClassName(), gen.getConstantPool()));\n    }\n\n    if (false) {\n      Throwable t = new Throwable();\n      t.fillInStackTrace();\n      StackTraceElement[] ste = t.getStackTrace();\n      StackTraceElement caller = ste[1];\n      System.out.printf(\n          \"%s.%s (%s line %d)\",\n          caller.getClassName(),\n          caller.getMethodName(),\n          caller.getFileName(),\n          caller.getLineNumber());\n      for (int ii = 2; ii < ste.length; ii++) {\n        System.out.printf(\" [%s line %d]\", ste[ii].getFileName(), ste[ii].getLineNumber());\n      }\n      System.out.printf(\"%n\");\n      dump_methods(gen);\n    }\n  }\n\n  /** Adds code in nl to start of method mg.\n   * @param mg method to be augmented\n   * @param nl instructions to prepend to the method\n   */\n  public static void add_to_start(MethodGen mg, InstructionList nl) {\n\n    // Add the code before the first instruction\n    InstructionList il = mg.getInstructionList();\n    InstructionHandle old_start = il.getStart();\n    InstructionHandle new_start = il.insert(nl);\n\n    // Move any LineNumbers and local variable that currently point to\n    // the first instruction to include the new instructions. Other\n    // targeters (branches, exceptions) should not include the new\n    // code\n    if (old_start.hasTargeters()) {\n      // getTargeters() returns non-null because hasTargeters => true\n      for (InstructionTargeter it : old_start.getTargeters()) {\n        if ((it instanceof LineNumberGen) || (it instanceof LocalVariableGen)) {\n          it.updateTarget(old_start, new_start);\n        }\n      }\n    }\n    mg.setMaxStack();\n    mg.setMaxLocals();\n  }\n\n  /**\n   * Dumps the contents of the specified class to the specified directory.\n   * The file is named dump_dir/[class].bcel.  It contains a synopsis\n   * of the fields and methods followed by the jvm code for each method.\n   * @param jc javaclass to dump\n   * @param dump_dir directory in which to write the file\n   * @see #dump(JavaClass, File)\n   */\n  public static void dump(JavaClass jc, String dump_dir) {\n\n    dump(jc, new File(dump_dir));\n  }\n\n  /**\n   * Dumps the contents of the specified class to the specified directory.\n   * The file is named dump_dir/[class].bcel.  It contains a synopsis\n   * of the fields and methods followed by the jvm code for each method.\n   *\n   * @param jc javaclass to dump\n   * @param dump_dir directory in which to write the file\n   */\n  public static void dump(JavaClass jc, File dump_dir) {\n\n    try {\n      dump_dir.mkdir();\n      File path = new File(dump_dir, jc.getClassName() + \".bcel\");\n      PrintStream p = new PrintStream(path);\n\n      // Print the class, super class and interfaces\n      p.printf(\"class %s extends %s%n\", jc.getClassName(), jc.getSuperclassName());\n      String[] inames = jc.getInterfaceNames();\n      if ((inames != null) && (inames.length > 0)) {\n        p.printf(\"   \");\n        for (String iname : inames) {\n          p.printf(\"implements %s \", iname);\n        }\n        p.printf(\"%n\");\n      }\n\n      // Print each field\n      p.printf(\"%nFields%n\");\n      for (Field f : jc.getFields()) {\n        p.printf(\"  %s%n\", f);\n      }\n\n      // Print the signature of each method\n      p.printf(\"%nMethods%n\");\n      for (Method m : jc.getMethods()) {\n        p.printf(\"  %s%n\", m);\n      }\n\n      // If this is not an interface, print the code for each method\n      if (!jc.isInterface()) {\n        for (Method m : jc.getMethods()) {\n          p.printf(\"%nMethod %s%n\", m);\n          Code code = m.getCode();\n          if (code != null) {\n            p.printf(\"  %s%n\", code.toString().replace(\"\\n\", \"\\n  \"));\n          }\n        }\n      }\n\n      // Print the details of the constant pool.\n      p.printf(\"Constant Pool:%n\");\n      ConstantPool cp = jc.getConstantPool();\n      Constant[] constants = cp.getConstantPool();\n      for (int ii = 0; ii < constants.length; ii++) {\n        p.printf(\"  %d %s%n\", ii, constants[ii]);\n      }\n\n      p.close();\n\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error dumping javaclass\", e);\n    }\n  }\n\n  // TODO: write Javadoc\n  @SuppressWarnings(\"rawtypes\")\n  public static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n\n    StringBuilder out = new StringBuilder();\n    // not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n      @SuppressWarnings(\n          \"nullness\") // BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n      /*@NonNull*/ InstructionHandle handle = (InstructionHandle) i.next();\n      out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n  }\n\n  /**\n   * Return a description of the local variables (one per line).\n   * @param mg the method whose local variables to describe\n   * @return a description of the local variables (one per line)\n   */\n  public static String local_var_descr(MethodGen mg) {\n\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n      for (LocalVariableGen lvg : lvgs) {\n        out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n      }\n    }\n    return (out.toString());\n  }\n\n  /**\n   * Builds an array of line numbers for the specified instruction list. Each\n   * opcode is assigned the next source line number starting at 1000.\n   * @param mg the method whose line numbers to extract\n   * @param il the instruction list to augment with line numbers\n   */\n  public static void add_line_numbers(MethodGen mg, InstructionList il) {\n\n    il.setPositions(true);\n    for (InstructionHandle ih : il.getInstructionHandles()) {\n      mg.addLineNumber(ih, 1000 + ih.getPosition());\n    }\n  }\n\n  /**\n   * Sets the locals to 'this' and each of the arguments. Any other locals are\n   * removed. An instruction list with at least one instruction must exist.\n   * @param mg the method whose locals to set\n   */\n  @SuppressWarnings(\"nullness\")\n  public static void setup_init_locals(MethodGen mg) {\n\n    // Get the parameter types and names.\n    Type[] arg_types = mg.getArgumentTypes();\n    String[] arg_names = mg.getArgumentNames();\n\n    // Remove any existing locals\n    mg.setMaxLocals(0);\n    mg.removeLocalVariables();\n\n    // Add a local for the instance variable (this)\n    if (!mg.isStatic()) {\n      mg.addLocalVariable(\"this\", new ObjectType(mg.getClassName()), null, null);\n    }\n\n    // Add a local for each parameter\n    for (int ii = 0; ii < arg_names.length; ii++) {\n      mg.addLocalVariable(arg_names[ii], arg_types[ii], null, null);\n    }\n\n    // Reset the current number of locals so that when other locals\n    // are added they get added at the correct offset\n    mg.setMaxLocals();\n\n    return;\n  }\n\n  /**\n   * Empties the method of all code (except for a return).  This\n   * includes line numbers, exceptions, local variables, etc.\n   * @param mg the method to clear out\n   */\n  public static void empty_method(MethodGen mg) {\n\n    mg.setInstructionList(new InstructionList(new RETURN()));\n    mg.removeExceptionHandlers();\n    mg.removeLineNumbers();\n    mg.removeLocalVariables();\n    mg.setMaxLocals();\n  }\n\n  /**\n   * Remove the local variable type table attribute (LVTT) from mg.\n   * Evidently some changes require this to be updated, but without\n   * BCEL support that would be hard to do.  It should be safe to just delete\n   * it since it is optional and really only of use to a debugger.\n   * @param mg the method to clear out\n   */\n  public static void remove_local_variable_type_tables(MethodGen mg) {\n\n    for (Attribute a : mg.getCodeAttributes()) {\n      if (is_local_variable_type_table(a, mg.getConstantPool())) {\n        mg.removeCodeAttribute(a);\n      }\n    }\n  }\n\n  /**\n   * Returns whether or not the specified attribute is a local variable type\n   * table.\n   * @param a the attribute\n   * @param pool the constant pool\n   * @return true iff the attribute is a local variable type table\n   */\n  public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n  }\n\n  /**\n   * Return the attribute name for the specified attribute.\n   * @param a the attribute\n   * @param pool the constant pool\n   * @return the attribute name for the specified attribute\n   */\n  public static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n  }\n\n  /**\n   * Returns whether or not this is a standard main method (static,\n   * name is 'main', and one argument of string array).\n   * @param mg the method to check\n   * @return true iff the method is a main method\n   */\n  public static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic()\n        && mg.getName().equals(\"main\")\n        && (arg_types.length == 1)\n        && arg_types[0].equals(string_array));\n  }\n\n  /**\n   * Returns the Java class name, in the format of {@link Class#getName()},\n   * that corresponds to type.\n   * @param type the type\n   * @return the Java classname that corresponds to type\n   */\n  public static /*@ClassGetName*/ String type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n  }\n\n  /**\n   * Returns the class that corresponds to type.\n   * @param type the type\n   * @return the Java class that corresponds to type\n   */\n  public static Class<?> type_to_class(Type type) {\n\n    String classname = type_to_classgetname(type);\n    try {\n      Class<?> c = UtilMDE.classForName(classname);\n      return c;\n    } catch (Exception e) {\n      throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n  }\n\n  /**\n   * Returns a type array with new_type added to the end of types.\n   * @param types the array to extend\n   * @param new_type the element to add to the end of the types array\n   * @return the array (or a new one), with new_type at the end\n   */\n  public static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n  }\n\n  /**\n   * Returns a type array with new_type inserted at the beginning.\n   * @param types the array to extend\n   * @param new_type the element to add to the beginning of the types array\n   * @return the array (or a new one), with new_type at the beginning\n   */\n  public static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n  }\n\n  /**\n   * Return the type corresponding to a given class name.\n   * @param classname the class to convert to a type\n   * @return the type corresponding to the given class name\n   */\n  public static Type classname_to_type(String classname) {\n\n    // Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n      classname = classname.substring(0, classname.length() - 2);\n      array_depth++;\n    }\n    classname = classname.intern();\n\n    // Get the base type\n    Type t = null;\n    if (classname == \"int\") { // interned\n      t = Type.INT;\n    } else if (classname == \"boolean\") { // interned\n      t = Type.BOOLEAN;\n    } else if (classname == \"byte\") { // interned\n      t = Type.BYTE;\n    } else if (classname == \"char\") { // interned\n      t = Type.CHAR;\n    } else if (classname == \"double\") { // interned\n      t = Type.DOUBLE;\n    } else if (classname == \"float\") { // interned\n      t = Type.FLOAT;\n    } else if (classname == \"long\") { // interned\n      t = Type.LONG;\n    } else if (classname == \"short\") { // interned\n      t = Type.SHORT;\n    } else { // must be a non-primitive\n      t = new ObjectType(classname);\n    }\n\n    // If there was an array, build the array type\n    if (array_depth > 0) {\n      t = new ArrayType(t, array_depth);\n    }\n\n    return t;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "1000", "int" ] ],
  "tokensMethodArguments" : [ [ "mg", "org.apache.commons.bcel6.generic", "MethodGen" ], [ "il", "org.apache.commons.bcel6.generic", "InstructionList" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "org.apache.commons.bcel6.generic", "MethodGen", "public boolean equals(Object arg0)" ], [ "getArgumentType", "org.apache.commons.bcel6.generic", "MethodGen", "public Type getArgumentType(int arg0)" ], [ "getClassName", "org.apache.commons.bcel6.generic", "MethodGen", "public String getClassName()" ], [ "getExceptionHandlers", "org.apache.commons.bcel6.generic", "MethodGen", "public CodeExceptionGen[] getExceptionHandlers()" ], [ "getMaxLocals", "org.apache.commons.bcel6.generic", "MethodGen", "public int getMaxLocals()" ], [ "getCodeAttributes", "org.apache.commons.bcel6.generic", "MethodGen", "public Attribute[] getCodeAttributes()" ], [ "getInstructionList", "org.apache.commons.bcel6.generic", "MethodGen", "public InstructionList getInstructionList()" ], [ "hashCode", "org.apache.commons.bcel6.generic", "MethodGen", "public int hashCode()" ], [ "getArgumentNames", "org.apache.commons.bcel6.generic", "MethodGen", "public String[] getArgumentNames()" ], [ "getMaxStack", "org.apache.commons.bcel6.generic", "MethodGen", "public int getMaxStack()" ], [ "getSignature", "org.apache.commons.bcel6.generic", "MethodGen", "public String getSignature()" ], [ "copy", "org.apache.commons.bcel6.generic", "MethodGen", "public MethodGen copy(String arg0, ConstantPoolGen arg1)" ], [ "getAnnotationsOnParameter", "org.apache.commons.bcel6.generic", "MethodGen", "public List<AnnotationEntryGen> getAnnotationsOnParameter(int arg0)" ], [ "getArgumentName", "org.apache.commons.bcel6.generic", "MethodGen", "public String getArgumentName(int arg0)" ], [ "getExceptions", "org.apache.commons.bcel6.generic", "MethodGen", "public String[] getExceptions()" ], [ "getArgumentTypes", "org.apache.commons.bcel6.generic", "MethodGen", "public Type[] getArgumentTypes()" ], [ "addLocalVariable", "org.apache.commons.bcel6.generic", "MethodGen", "public LocalVariableGen addLocalVariable(String arg0, Type arg1, InstructionHandle arg2, InstructionHandle arg3)" ], [ "getLineNumbers", "org.apache.commons.bcel6.generic", "MethodGen", "public LineNumberGen[] getLineNumbers()" ], [ "getLocalVariables", "org.apache.commons.bcel6.generic", "MethodGen", "public LocalVariableGen[] getLocalVariables()" ], [ "addExceptionHandler", "org.apache.commons.bcel6.generic", "MethodGen", "public CodeExceptionGen addExceptionHandler(InstructionHandle arg0, InstructionHandle arg1, InstructionHandle arg2, ObjectType arg3)" ], [ "toString", "org.apache.commons.bcel6.generic", "MethodGen", "public final String toString()" ], [ "getReturnType", "org.apache.commons.bcel6.generic", "MethodGen", "public Type getReturnType()" ], [ "addLocalVariable", "org.apache.commons.bcel6.generic", "MethodGen", "public LocalVariableGen addLocalVariable(String arg0, Type arg1, int arg2, InstructionHandle arg3, InstructionHandle arg4)" ], [ "addLineNumber", "org.apache.commons.bcel6.generic", "MethodGen", "public LineNumberGen addLineNumber(InstructionHandle arg0, int arg1)" ], [ "getLineNumberTable", "org.apache.commons.bcel6.generic", "MethodGen", "public LineNumberTable getLineNumberTable(ConstantPoolGen arg0)" ], [ "getMethod", "org.apache.commons.bcel6.generic", "MethodGen", "public Method getMethod()" ], [ "getLocalVariableTable", "org.apache.commons.bcel6.generic", "MethodGen", "public LocalVariableTable getLocalVariableTable(ConstantPoolGen arg0)" ], [ "getName", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public String getName()" ], [ "getSignature", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public abstract String getSignature()" ], [ "getAttributes", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public Attribute[] getAttributes()" ], [ "getConstantPool", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public ConstantPoolGen getConstantPool()" ], [ "getAnnotationEntries", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public AnnotationEntryGen[] getAnnotationEntries()" ], [ "clone", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public Object clone()" ], [ "getType", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "public Type getType()" ], [ "isInterface", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isInterface()" ], [ "isEnum", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isEnum()" ], [ "isPublic", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isPublic()" ], [ "isTransient", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isTransient()" ], [ "isProtected", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isProtected()" ], [ "isFinal", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isFinal()" ], [ "getAccessFlags", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final int getAccessFlags()" ], [ "getModifiers", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final int getModifiers()" ], [ "isAnnotation", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isAnnotation()" ], [ "isVolatile", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isVolatile()" ], [ "isPrivate", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isPrivate()" ], [ "isStatic", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isStatic()" ], [ "isSynthetic", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isSynthetic()" ], [ "isStrictfp", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isStrictfp()" ], [ "isSynchronized", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isSynchronized()" ], [ "isNative", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isNative()" ], [ "isAbstract", "org.apache.commons.bcel6.classfile", "AccessFlags", "public final boolean isAbstract()" ], [ "getType", "org.apache.commons.bcel6.generic", "NamedAndTyped", "public abstract Type getType()" ], [ "getName", "org.apache.commons.bcel6.generic", "NamedAndTyped", "public abstract String getName()" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle insert(Instruction arg0, Instruction arg1)" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle append(Instruction arg0)" ], [ "getEnd", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle getEnd()" ], [ "iterator", "org.apache.commons.bcel6.generic", "InstructionList", "public Iterator<InstructionHandle> iterator()" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle append(InstructionHandle arg0, InstructionList arg1)" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle append(InstructionHandle arg0, Instruction arg1)" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public BranchHandle append(InstructionHandle arg0, BranchInstruction arg1)" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public BranchHandle insert(BranchInstruction arg0)" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public BranchHandle insert(InstructionHandle arg0, BranchInstruction arg1)" ], [ "getStart", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle getStart()" ], [ "findHandle", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle findHandle(int arg0)" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle insert(InstructionHandle arg0, CompoundInstruction arg1)" ], [ "size", "org.apache.commons.bcel6.generic", "InstructionList", "public int size()" ], [ "getByteCode", "org.apache.commons.bcel6.generic", "InstructionList", "public byte[] getByteCode()" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle append(Instruction arg0, InstructionList arg1)" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle append(InstructionList arg0)" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle insert(InstructionHandle arg0, InstructionList arg1)" ], [ "contains", "org.apache.commons.bcel6.generic", "InstructionList", "public boolean contains(InstructionHandle arg0)" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle insert(Instruction arg0)" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle insert(Instruction arg0, CompoundInstruction arg1)" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle insert(Instruction arg0, InstructionList arg1)" ], [ "toString", "org.apache.commons.bcel6.generic", "InstructionList", "public String toString(boolean arg0)" ], [ "getLength", "org.apache.commons.bcel6.generic", "InstructionList", "public int getLength()" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle append(InstructionHandle arg0, CompoundInstruction arg1)" ], [ "isEmpty", "org.apache.commons.bcel6.generic", "InstructionList", "public boolean isEmpty()" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle append(Instruction arg0, CompoundInstruction arg1)" ], [ "getInstructions", "org.apache.commons.bcel6.generic", "InstructionList", "public Instruction[] getInstructions()" ], [ "toString", "org.apache.commons.bcel6.generic", "InstructionList", "public String toString()" ], [ "copy", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionList copy()" ], [ "getInstructionHandles", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle[] getInstructionHandles()" ], [ "contains", "org.apache.commons.bcel6.generic", "InstructionList", "public boolean contains(Instruction arg0)" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle insert(InstructionHandle arg0, Instruction arg1)" ], [ "getInstructionPositions", "org.apache.commons.bcel6.generic", "InstructionList", "public int[] getInstructionPositions()" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle insert(InstructionList arg0)" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public BranchHandle append(BranchInstruction arg0)" ], [ "insert", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle insert(CompoundInstruction arg0)" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle append(CompoundInstruction arg0)" ], [ "append", "org.apache.commons.bcel6.generic", "InstructionList", "public InstructionHandle append(Instruction arg0, Instruction arg1)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "name", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "protected String name;" ], [ "type", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "protected Type type;" ], [ "cp", "org.apache.commons.bcel6.generic", "FieldGenOrMethodGen", "protected ConstantPoolGen cp;" ], [ "access_flags", "org.apache.commons.bcel6.classfile", "AccessFlags", "protected int access_flags;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]