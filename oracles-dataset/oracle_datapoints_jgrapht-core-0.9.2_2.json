[
    {
        "id": 25926,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "Pseudograph",
        "javadocTag": "@param edgeClass class on which to base factory for edges",
        "methodJavadoc": "    /**\n     * Creates a new pseudograph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */",
        "methodSourceCode": "public Pseudograph(Class<? extends E> edgeClass){\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}",
        "classJavadoc": "/**\n * A pseudograph. A pseudograph is a non-simple undirected graph in which both\n * graph loops and multiple edges are permitted. If you're unsure about\n * pseudographs, see: <a href=\"http://mathworld.wolfram.com/Pseudograph.html\">\n * http://mathworld.wolfram.com/Pseudograph.html</a>.\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Pseudograph.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.builder.*;\n\n\n/**\n * A pseudograph. A pseudograph is a non-simple undirected graph in which both\n * graph loops and multiple edges are permitted. If you're unsure about\n * pseudographs, see: <a href=\"http://mathworld.wolfram.com/Pseudograph.html\">\n * http://mathworld.wolfram.com/Pseudograph.html</a>.\n */\npublic class Pseudograph<V, E>\n    extends AbstractBaseGraph<V, E>\n    implements UndirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 3833183614484755253L;\n\n    /**\n     * Creates a new pseudograph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public Pseudograph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }\n\n    /**\n     * Creates a new pseudograph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */\n    public Pseudograph(EdgeFactory<V, E> ef)\n    {\n        super(ef, true, true);\n    }\n\n    public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)\n    {\n        return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(\n            new Pseudograph<V, E>(edgeClass));\n    }\n\n    public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(\n            new Pseudograph<V, E>(ef));\n    }\n}\n\n// End Pseudograph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "edgeClass",
                "java.lang.Class",
                "Class<? extends E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "edgeSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgeSet()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeVertex(V arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addVertex(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "inDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int inDegreeOf(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "outDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int outDegreeOf(V arg0)"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeTarget(E arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public String toString()"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E removeEdge(V arg0, V arg1)"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E getEdge(V arg0, V arg1)"
            ],
            [
                "clone",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Object clone()"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "isAllowingMultipleEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingMultipleEdges()"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E addEdge(V arg0, V arg1)"
            ],
            [
                "isAllowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingLoops()"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "createUndirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeSource(E arg0)"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsVertex(V arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsEdge(E arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgesOf(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeEdge(E arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public double getEdgeWeight(E arg0)"
            ],
            [
                "createDirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<V> vertexSet()"
            ],
            [
                "degreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int degreeOf(V arg0)"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "getPackageName",
                "java.lang",
                "Class",
                "public String getPackageName()"
            ],
            [
                "cast",
                "java.lang",
                "Class",
                "public T cast(Object arg0)"
            ],
            [
                "getPermittedSubclasses",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getPermittedSubclasses()"
            ],
            [
                "getMethod",
                "java.lang",
                "Class",
                "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException"
            ],
            [
                "getInterfaces",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getInterfaces()"
            ],
            [
                "getDeclaredAnnotation",
                "java.lang",
                "Class",
                "public <A> A getDeclaredAnnotation(Class<A> arg0)"
            ],
            [
                "getDeclaredConstructor",
                "java.lang",
                "Class",
                "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException"
            ],
            [
                "getModifiers",
                "java.lang",
                "Class",
                "public native int getModifiers()"
            ],
            [
                "isSealed",
                "java.lang",
                "Class",
                "public boolean isSealed()"
            ],
            [
                "isHidden",
                "java.lang",
                "Class",
                "public native boolean isHidden()"
            ],
            [
                "getMethods",
                "java.lang",
                "Class",
                "public Method[] getMethods() throws SecurityException"
            ],
            [
                "getModule",
                "java.lang",
                "Class",
                "public Module getModule()"
            ],
            [
                "isAnonymousClass",
                "java.lang",
                "Class",
                "public boolean isAnonymousClass()"
            ],
            [
                "getEnclosingClass",
                "java.lang",
                "Class",
                "public Class<? extends Object> getEnclosingClass() throws SecurityException"
            ],
            [
                "isMemberClass",
                "java.lang",
                "Class",
                "public boolean isMemberClass()"
            ],
            [
                "getTypeParameters",
                "java.lang",
                "Class",
                "public TypeVariable<Class<T>>[] getTypeParameters()"
            ],
            [
                "enumConstantDirectory",
                "java.lang",
                "Class",
                "Map<String, T> enumConstantDirectory()"
            ],
            [
                "getDeclaredAnnotationsByType",
                "java.lang",
                "Class",
                "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)"
            ],
            [
                "getEnclosingMethod",
                "java.lang",
                "Class",
                "public Method getEnclosingMethod() throws SecurityException"
            ],
            [
                "describeConstable",
                "java.lang",
                "Class",
                "public Optional<ClassDesc> describeConstable()"
            ],
            [
                "isLocalClass",
                "java.lang",
                "Class",
                "public boolean isLocalClass()"
            ],
            [
                "getClassData",
                "java.lang",
                "Class",
                "Object getClassData()"
            ],
            [
                "getEnumConstants",
                "java.lang",
                "Class",
                "public T[] getEnumConstants()"
            ],
            [
                "getName",
                "java.lang",
                "Class",
                "public String getName()"
            ],
            [
                "getProtectionDomain",
                "java.lang",
                "Class",
                "public ProtectionDomain getProtectionDomain()"
            ],
            [
                "getPackage",
                "java.lang",
                "Class",
                "public Package getPackage()"
            ],
            [
                "isAnnotation",
                "java.lang",
                "Class",
                "public boolean isAnnotation()"
            ],
            [
                "asSubclass",
                "java.lang",
                "Class",
                "public <U> Class<? extends U> asSubclass(Class<U> arg0)"
            ],
            [
                "getRecordComponents",
                "java.lang",
                "Class",
                "public RecordComponent[] getRecordComponents()"
            ],
            [
                "isInterface",
                "java.lang",
                "Class",
                "public native boolean isInterface()"
            ],
            [
                "getDeclaredClasses",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException"
            ],
            [
                "getAnnotatedInterfaces",
                "java.lang",
                "Class",
                "public AnnotatedType[] getAnnotatedInterfaces()"
            ],
            [
                "getGenericSuperclass",
                "java.lang",
                "Class",
                "public Type getGenericSuperclass()"
            ],
            [
                "getConstantPool",
                "java.lang",
                "Class",
                "native ConstantPool getConstantPool()"
            ],
            [
                "getFields",
                "java.lang",
                "Class",
                "public Field[] getFields() throws SecurityException"
            ],
            [
                "getDeclaredFields",
                "java.lang",
                "Class",
                "public Field[] getDeclaredFields() throws SecurityException"
            ],
            [
                "getEnumConstantsShared",
                "java.lang",
                "Class",
                "T[] getEnumConstantsShared()"
            ],
            [
                "isNestmateOf",
                "java.lang",
                "Class",
                "public boolean isNestmateOf(Class<? extends Object> arg0)"
            ],
            [
                "getClassLoader",
                "java.lang",
                "Class",
                "public ClassLoader getClassLoader()"
            ],
            [
                "protectionDomain",
                "java.lang",
                "Class",
                "ProtectionDomain protectionDomain()"
            ],
            [
                "getTypeName",
                "java.lang",
                "Class",
                "public String getTypeName()"
            ],
            [
                "getNestMembers",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getNestMembers()"
            ],
            [
                "getDeclaredAnnotations",
                "java.lang",
                "Class",
                "public Annotation[] getDeclaredAnnotations()"
            ],
            [
                "getAnnotationsByType",
                "java.lang",
                "Class",
                "public <A> A[] getAnnotationsByType(Class<A> arg0)"
            ],
            [
                "getAnnotation",
                "java.lang",
                "Class",
                "public <A> A getAnnotation(Class<A> arg0)"
            ],
            [
                "getSigners",
                "java.lang",
                "Class",
                "public native Object[] getSigners()"
            ],
            [
                "isAnnotationPresent",
                "java.lang",
                "Class",
                "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)"
            ],
            [
                "isArray",
                "java.lang",
                "Class",
                "public native boolean isArray()"
            ],
            [
                "getNestHost",
                "java.lang",
                "Class",
                "public Class<? extends Object> getNestHost()"
            ],
            [
                "getClasses",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getClasses()"
            ],
            [
                "getDeclaredPublicMethods",
                "java.lang",
                "Class",
                "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)"
            ],
            [
                "isEnum",
                "java.lang",
                "Class",
                "public boolean isEnum()"
            ],
            [
                "getEnclosingConstructor",
                "java.lang",
                "Class",
                "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException"
            ],
            [
                "getConstructor",
                "java.lang",
                "Class",
                "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException"
            ],
            [
                "getResourceAsStream",
                "java.lang",
                "Class",
                "public InputStream getResourceAsStream(String arg0)"
            ],
            [
                "getCanonicalName",
                "java.lang",
                "Class",
                "public String getCanonicalName()"
            ],
            [
                "getDeclaredMethod",
                "java.lang",
                "Class",
                "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException"
            ],
            [
                "isInstance",
                "java.lang",
                "Class",
                "public native boolean isInstance(Object arg0)"
            ],
            [
                "desiredAssertionStatus",
                "java.lang",
                "Class",
                "public boolean desiredAssertionStatus()"
            ],
            [
                "descriptorString",
                "java.lang",
                "Class",
                "public String descriptorString()"
            ],
            [
                "getComponentType",
                "java.lang",
                "Class",
                "public Class<? extends Object> getComponentType()"
            ],
            [
                "getDeclaringClass",
                "java.lang",
                "Class",
                "public Class<? extends Object> getDeclaringClass() throws SecurityException"
            ],
            [
                "isPrimitive",
                "java.lang",
                "Class",
                "public native boolean isPrimitive()"
            ],
            [
                "getGenericInterfaces",
                "java.lang",
                "Class",
                "public Type[] getGenericInterfaces()"
            ],
            [
                "casAnnotationType",
                "java.lang",
                "Class",
                "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)"
            ],
            [
                "getDeclaredConstructors",
                "java.lang",
                "Class",
                "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException"
            ],
            [
                "toGenericString",
                "java.lang",
                "Class",
                "public String toGenericString()"
            ],
            [
                "getRawAnnotations",
                "java.lang",
                "Class",
                "native byte[] getRawAnnotations()"
            ],
            [
                "getAnnotations",
                "java.lang",
                "Class",
                "public Annotation[] getAnnotations()"
            ],
            [
                "isSynthetic",
                "java.lang",
                "Class",
                "public boolean isSynthetic()"
            ],
            [
                "getConstructors",
                "java.lang",
                "Class",
                "public Constructor<? extends Object>[] getConstructors() throws SecurityException"
            ],
            [
                "toString",
                "java.lang",
                "Class",
                "public String toString()"
            ],
            [
                "isAssignableFrom",
                "java.lang",
                "Class",
                "public native boolean isAssignableFrom(Class<? extends Object> arg0)"
            ],
            [
                "getAnnotationType",
                "java.lang",
                "Class",
                "AnnotationType getAnnotationType()"
            ],
            [
                "newInstance",
                "java.lang",
                "Class",
                "public T newInstance() throws InstantiationException, IllegalAccessException"
            ],
            [
                "componentType",
                "java.lang",
                "Class",
                "public Class<? extends Object> componentType()"
            ],
            [
                "getClassLoader0",
                "java.lang",
                "Class",
                "ClassLoader getClassLoader0()"
            ],
            [
                "getRawTypeAnnotations",
                "java.lang",
                "Class",
                "native byte[] getRawTypeAnnotations()"
            ],
            [
                "arrayType",
                "java.lang",
                "Class",
                "public Class<? extends Object> arrayType()"
            ],
            [
                "getSuperclass",
                "java.lang",
                "Class",
                "public native Class<? super T> getSuperclass()"
            ],
            [
                "getSimpleName",
                "java.lang",
                "Class",
                "public String getSimpleName()"
            ],
            [
                "getDeclaredAnnotationMap",
                "java.lang",
                "Class",
                "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()"
            ],
            [
                "getAnnotatedSuperclass",
                "java.lang",
                "Class",
                "public AnnotatedType getAnnotatedSuperclass()"
            ],
            [
                "getResource",
                "java.lang",
                "Class",
                "public URL getResource(String arg0)"
            ],
            [
                "getDeclaredMethods",
                "java.lang",
                "Class",
                "public Method[] getDeclaredMethods() throws SecurityException"
            ],
            [
                "getDeclaredField",
                "java.lang",
                "Class",
                "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException"
            ],
            [
                "getField",
                "java.lang",
                "Class",
                "public Field getField(String arg0) throws NoSuchFieldException, SecurityException"
            ],
            [
                "isRecord",
                "java.lang",
                "Class",
                "public boolean isRecord()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getTypeParameters",
                "java.lang.reflect",
                "GenericDeclaration",
                "public abstract TypeVariable<? extends Object>[] getTypeParameters()"
            ],
            [
                "getDeclaredAnnotationsByType",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)"
            ],
            [
                "getAnnotations",
                "java.lang.reflect",
                "AnnotatedElement",
                "public abstract Annotation[] getAnnotations()"
            ],
            [
                "getDeclaredAnnotations",
                "java.lang.reflect",
                "AnnotatedElement",
                "public abstract Annotation[] getDeclaredAnnotations()"
            ],
            [
                "getAnnotation",
                "java.lang.reflect",
                "AnnotatedElement",
                "public abstract <T> T getAnnotation(Class<T> arg0)"
            ],
            [
                "getDeclaredAnnotation",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default <T> T getDeclaredAnnotation(Class<T> arg0)"
            ],
            [
                "isAnnotationPresent",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)"
            ],
            [
                "getAnnotationsByType",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default <T> T[] getAnnotationsByType(Class<T> arg0)"
            ],
            [
                "getTypeName",
                "java.lang.reflect",
                "Type",
                "public default String getTypeName()"
            ],
            [
                "isPrimitive",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract boolean isPrimitive()"
            ],
            [
                "arrayType",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract F arrayType()"
            ],
            [
                "componentType",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract F componentType()"
            ],
            [
                "isArray",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract boolean isArray()"
            ],
            [
                "descriptorString",
                "java.lang.invoke",
                "TypeDescriptor",
                "public abstract String descriptorString()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "allowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "boolean allowingLoops;"
            ],
            [
                "classValueMap",
                "java.lang",
                "Class",
                "transient ClassValue.ClassValueMap classValueMap;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 25939,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "AbstractBaseGraph",
        "javadocTag": "@throws RuntimeException",
        "methodJavadoc": "    /**\n     * Returns a shallow copy of this graph instance. Neither edges nor vertices\n     * are cloned.\n     *\n     * @return a shallow copy of this set.\n     *\n     * @throws RuntimeException\n     *\n     * @see java.lang.Object#clone()\n     */",
        "methodSourceCode": "public Object clone(){\n    try {\n        TypeUtil<AbstractBaseGraph<V, E>> typeDecl = null;\n        AbstractBaseGraph<V, E> newGraph = TypeUtil.uncheckedCast(super.clone(), typeDecl);\n        newGraph.edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n        newGraph.edgeFactory = this.edgeFactory;\n        newGraph.unmodifiableEdgeSet = null;\n        newGraph.unmodifiableVertexSet = null;\n        // NOTE:  it's important for this to happen in an object\n        // method so that the new inner class instance gets associated with\n        // the right outer class instance\n        newGraph.specifics = newGraph.createSpecifics();\n        Graphs.addGraph(newGraph, this);\n        return newGraph;\n    } catch (CloneNotSupportedException e) {\n        e.printStackTrace();\n        throw new RuntimeException();\n    }\n}",
        "classJavadoc": "/**\n * The most general implementation of the {@link org.jgrapht.Graph} interface.\n * Its subclasses add various restrictions to get more specific graphs. The\n * decision whether it is directed or undirected is decided at construction time\n * and cannot be later modified (see constructor for details).\n *\n * <p>This graph implementation guarantees deterministic vertex and edge set\n * ordering (via {@link LinkedHashMap} and {@link LinkedHashSet}).</p>\n *\n * @author Barak Naveh\n * @since Jul 24, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------------\n * AbstractBaseGraph.java\n * ----------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 10-Aug-2003 : General edge refactoring (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 07-Feb-2004 : Enabled serialization (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 01-Jun-2005 : Added EdgeListFactory (JVS);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * The most general implementation of the {@link org.jgrapht.Graph} interface.\n * Its subclasses add various restrictions to get more specific graphs. The\n * decision whether it is directed or undirected is decided at construction time\n * and cannot be later modified (see constructor for details).\n *\n * <p>This graph implementation guarantees deterministic vertex and edge set\n * ordering (via {@link LinkedHashMap} and {@link LinkedHashSet}).</p>\n *\n * @author Barak Naveh\n * @since Jul 24, 2003\n */\npublic abstract class AbstractBaseGraph<V, E>\n    extends AbstractGraph<V, E>\n    implements Graph<V, E>,\n        Cloneable,\n        Serializable\n{\n    private static final long serialVersionUID = -1263088497616142427L;\n\n    private static final String LOOPS_NOT_ALLOWED = \"loops not allowed\";\n\n    boolean allowingLoops;\n\n    private EdgeFactory<V, E> edgeFactory;\n    private EdgeSetFactory<V, E> edgeSetFactory;\n    private Map<E, IntrusiveEdge> edgeMap;\n    private transient Set<E> unmodifiableEdgeSet = null;\n    private transient Set<V> unmodifiableVertexSet = null;\n    private Specifics specifics;\n    private boolean allowingMultipleEdges;\n\n    private transient TypeUtil<V> vertexTypeDecl = null;\n\n    /**\n     * Construct a new graph. The graph can either be directed or undirected,\n     * depending on the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     * @param allowMultipleEdges whether to allow multiple edges or not.\n     * @param allowLoops whether to allow edges that are self-loops or not.\n     *\n     * @throws NullPointerException if the specified edge factory is <code>\n     * null</code>.\n     */\n    protected AbstractBaseGraph(\n        EdgeFactory<V, E> ef,\n        boolean allowMultipleEdges,\n        boolean allowLoops)\n    {\n        if (ef == null) {\n            throw new NullPointerException();\n        }\n\n        edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n        edgeFactory = ef;\n        allowingLoops = allowLoops;\n        allowingMultipleEdges = allowMultipleEdges;\n\n        specifics = createSpecifics();\n\n        this.edgeSetFactory = new ArrayListFactory<V, E>();\n    }\n\n    /**\n     * @see Graph#getAllEdges(Object, Object)\n     */\n    @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        return specifics.getAllEdges(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Returns <code>true</code> if and only if self-loops are allowed in this\n     * graph. A self loop is an edge that its source and target vertices are the\n     * same.\n     *\n     * @return <code>true</code> if and only if graph loops are allowed.\n     */\n    public boolean isAllowingLoops()\n    {\n        return allowingLoops;\n    }\n\n    /**\n     * Returns <code>true</code> if and only if multiple edges are allowed in\n     * this graph. The meaning of multiple edges is that there can be many edges\n     * going from vertex v1 to vertex v2.\n     *\n     * @return <code>true</code> if and only if multiple edges are allowed.\n     */\n    public boolean isAllowingMultipleEdges()\n    {\n        return allowingMultipleEdges;\n    }\n\n    /**\n     * @see Graph#getEdge(Object, Object)\n     */\n    @Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        return specifics.getEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * @see Graph#getEdgeFactory()\n     */\n    @Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        return edgeFactory;\n    }\n\n    /**\n     * Set the {@link EdgeSetFactory} to use for this graph. Initially, a graph\n     * is created with a default implementation which always supplies an {@link\n     * java.util.ArrayList} with capacity 1.\n     *\n     * @param edgeSetFactory factory to use for subsequently created edge sets\n     * (this call has no effect on existing edge sets)\n     */\n    public void setEdgeSetFactory(EdgeSetFactory<V, E> edgeSetFactory)\n    {\n        this.edgeSetFactory = edgeSetFactory;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object)\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        if (!allowingMultipleEdges\n            && containsEdge(sourceVertex, targetVertex))\n        {\n            return null;\n        }\n\n        if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n            throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n        }\n\n        E e = edgeFactory.createEdge(sourceVertex, targetVertex);\n\n        if (containsEdge(e)) { // this restriction should stay!\n\n            return null;\n        } else {\n            IntrusiveEdge intrusiveEdge =\n                createIntrusiveEdge(e, sourceVertex, targetVertex);\n\n            edgeMap.put(e, intrusiveEdge);\n            specifics.addEdgeToTouchingVertices(e);\n\n            return e;\n        }\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        } else if (containsEdge(e)) {\n            return false;\n        }\n\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        if (!allowingMultipleEdges\n            && containsEdge(sourceVertex, targetVertex))\n        {\n            return false;\n        }\n\n        if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n            throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n        }\n\n        IntrusiveEdge intrusiveEdge =\n            createIntrusiveEdge(e, sourceVertex, targetVertex);\n\n        edgeMap.put(e, intrusiveEdge);\n        specifics.addEdgeToTouchingVertices(e);\n\n        return true;\n    }\n\n    private IntrusiveEdge createIntrusiveEdge(\n        E e,\n        V sourceVertex,\n        V targetVertex)\n    {\n        IntrusiveEdge intrusiveEdge;\n        if (e instanceof IntrusiveEdge) {\n            intrusiveEdge = (IntrusiveEdge) e;\n        } else {\n            intrusiveEdge = new IntrusiveEdge();\n        }\n        intrusiveEdge.source = sourceVertex;\n        intrusiveEdge.target = targetVertex;\n        return intrusiveEdge;\n    }\n\n    /**\n     * @see Graph#addVertex(Object)\n     */\n    @Override public boolean addVertex(V v)\n    {\n        if (v == null) {\n            throw new NullPointerException();\n        } else if (containsVertex(v)) {\n            return false;\n        } else {\n            specifics.addVertex(v);\n\n            return true;\n        }\n    }\n\n    /**\n     * @see Graph#getEdgeSource(Object)\n     */\n    @Override public V getEdgeSource(E e)\n    {\n        return TypeUtil.uncheckedCast(\n            getIntrusiveEdge(e).source,\n            vertexTypeDecl);\n    }\n\n    /**\n     * @see Graph#getEdgeTarget(Object)\n     */\n    @Override public V getEdgeTarget(E e)\n    {\n        return TypeUtil.uncheckedCast(\n            getIntrusiveEdge(e).target,\n            vertexTypeDecl);\n    }\n\n    private IntrusiveEdge getIntrusiveEdge(E e)\n    {\n        if (e instanceof IntrusiveEdge) {\n            return (IntrusiveEdge) e;\n        }\n\n        return edgeMap.get(e);\n    }\n\n    /**\n     * Returns a shallow copy of this graph instance. Neither edges nor vertices\n     * are cloned.\n     *\n     * @return a shallow copy of this set.\n     *\n     * @throws RuntimeException\n     *\n     * @see java.lang.Object#clone()\n     */\n    @Override public Object clone()\n    {\n        try {\n            TypeUtil<AbstractBaseGraph<V, E>> typeDecl = null;\n\n            AbstractBaseGraph<V, E> newGraph =\n                TypeUtil.uncheckedCast(super.clone(), typeDecl);\n\n            newGraph.edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n\n            newGraph.edgeFactory = this.edgeFactory;\n            newGraph.unmodifiableEdgeSet = null;\n            newGraph.unmodifiableVertexSet = null;\n\n            // NOTE:  it's important for this to happen in an object\n            // method so that the new inner class instance gets associated with\n            // the right outer class instance\n            newGraph.specifics = newGraph.createSpecifics();\n\n            Graphs.addGraph(newGraph, this);\n\n            return newGraph;\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n            throw new RuntimeException();\n        }\n    }\n\n    /**\n     * @see Graph#containsEdge(Object)\n     */\n    @Override public boolean containsEdge(E e)\n    {\n        return edgeMap.containsKey(e);\n    }\n\n    /**\n     * @see Graph#containsVertex(Object)\n     */\n    @Override public boolean containsVertex(V v)\n    {\n        return specifics.getVertexSet().contains(v);\n    }\n\n    /**\n     * @see UndirectedGraph#degreeOf(Object)\n     */\n    public int degreeOf(V vertex)\n    {\n        return specifics.degreeOf(vertex);\n    }\n\n    /**\n     * @see Graph#edgeSet()\n     */\n    @Override public Set<E> edgeSet()\n    {\n        if (unmodifiableEdgeSet == null) {\n            unmodifiableEdgeSet = Collections.unmodifiableSet(edgeMap.keySet());\n        }\n\n        return unmodifiableEdgeSet;\n    }\n\n    /**\n     * @see Graph#edgesOf(Object)\n     */\n    @Override public Set<E> edgesOf(V vertex)\n    {\n        return specifics.edgesOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#inDegreeOf(Object)\n     */\n    public int inDegreeOf(V vertex)\n    {\n        return specifics.inDegreeOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     */\n    public Set<E> incomingEdgesOf(V vertex)\n    {\n        return specifics.incomingEdgesOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#outDegreeOf(Object)\n     */\n    public int outDegreeOf(V vertex)\n    {\n        return specifics.outDegreeOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     */\n    public Set<E> outgoingEdgesOf(V vertex)\n    {\n        return specifics.outgoingEdgesOf(vertex);\n    }\n\n    /**\n     * @see Graph#removeEdge(Object, Object)\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = getEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            specifics.removeEdgeFromTouchingVertices(e);\n            edgeMap.remove(e);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#removeEdge(Object)\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        if (containsEdge(e)) {\n            specifics.removeEdgeFromTouchingVertices(e);\n            edgeMap.remove(e);\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @see Graph#removeVertex(Object)\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        if (containsVertex(v)) {\n            Set<E> touchingEdgesList = edgesOf(v);\n\n            // cannot iterate over list - will cause\n            // ConcurrentModificationException\n            removeAllEdges(new ArrayList<E>(touchingEdgesList));\n\n            specifics.getVertexSet().remove(v); // remove the vertex itself\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @see Graph#vertexSet()\n     */\n    @Override public Set<V> vertexSet()\n    {\n        if (unmodifiableVertexSet == null) {\n            unmodifiableVertexSet =\n                Collections.unmodifiableSet(specifics.getVertexSet());\n        }\n\n        return unmodifiableVertexSet;\n    }\n\n    /**\n     * @see Graph#getEdgeWeight(Object)\n     */\n    @Override public double getEdgeWeight(E e)\n    {\n        if (e instanceof DefaultWeightedEdge) {\n            return ((DefaultWeightedEdge) e).getWeight();\n        } else if (e == null) {\n            throw new NullPointerException();\n        } else {\n            return WeightedGraph.DEFAULT_EDGE_WEIGHT;\n        }\n    }\n\n    /**\n     * @see WeightedGraph#setEdgeWeight(Object, double)\n     */\n    public void setEdgeWeight(E e, double weight)\n    {\n        assert (e instanceof DefaultWeightedEdge) : e.getClass();\n        ((DefaultWeightedEdge) e).weight = weight;\n    }\n\n    private Specifics createSpecifics()\n    {\n        if (this instanceof DirectedGraph<?, ?>) {\n            return createDirectedSpecifics();\n        } else if (this instanceof UndirectedGraph<?, ?>) {\n            return createUndirectedSpecifics();\n        } else {\n            throw new IllegalArgumentException(\n                \"must be instance of either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    protected UndirectedSpecifics createUndirectedSpecifics()\n    {\n        return new UndirectedSpecifics();\n    }\n\n    protected DirectedSpecifics createDirectedSpecifics()\n    {\n        return new DirectedSpecifics();\n    }\n\n    /**\n     * .\n     *\n     * @author Barak Naveh\n     */\n    private abstract class Specifics\n        implements Serializable\n    {\n        private static final long serialVersionUID = 785196247314761183L;\n\n        public abstract void addVertex(V vertex);\n\n        public abstract Set<V> getVertexSet();\n\n        /**\n         * .\n         *\n         * @param sourceVertex\n         * @param targetVertex\n         *\n         * @return\n         */\n        public abstract Set<E> getAllEdges(V sourceVertex,\n            V targetVertex);\n\n        /**\n         * .\n         *\n         * @param sourceVertex\n         * @param targetVertex\n         *\n         * @return\n         */\n        public abstract E getEdge(V sourceVertex, V targetVertex);\n\n        /**\n         * Adds the specified edge to the edge containers of its source and\n         * target vertices.\n         *\n         * @param e\n         */\n        public abstract void addEdgeToTouchingVertices(E e);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract int degreeOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract Set<E> edgesOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract int inDegreeOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract Set<E> incomingEdgesOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract int outDegreeOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract Set<E> outgoingEdgesOf(V vertex);\n\n        /**\n         * Removes the specified edge from the edge containers of its source and\n         * target vertices.\n         *\n         * @param e\n         */\n        public abstract void removeEdgeFromTouchingVertices(E e);\n    }\n\n    private static class ArrayListFactory<VV, EE>\n        implements EdgeSetFactory<VV, EE>,\n            Serializable\n    {\n        private static final long serialVersionUID = 5936902837403445985L;\n\n        /**\n         * @see EdgeSetFactory.createEdgeSet\n         */\n        @Override public Set<EE> createEdgeSet(VV vertex)\n        {\n            // NOTE:  use size 1 to keep memory usage under control\n            // for the common case of vertices with low degree\n            return new ArrayUnenforcedSet<EE>(1);\n        }\n    }\n\n    /**\n     * A container for vertex edges.\n     *\n     * <p>In this edge container we use array lists to minimize memory toll.\n     * However, for high-degree vertices we replace the entire edge container\n     * with a direct access subclass (to be implemented).</p>\n     *\n     * @author Barak Naveh\n     */\n    protected static class DirectedEdgeContainer<VV, EE>\n        implements Serializable\n    {\n        private static final long serialVersionUID = 7494242245729767106L;\n        Set<EE> incoming;\n        Set<EE> outgoing;\n        private transient Set<EE> unmodifiableIncoming = null;\n        private transient Set<EE> unmodifiableOutgoing = null;\n\n        DirectedEdgeContainer(EdgeSetFactory<VV, EE> edgeSetFactory,\n            VV vertex)\n        {\n            incoming = edgeSetFactory.createEdgeSet(vertex);\n            outgoing = edgeSetFactory.createEdgeSet(vertex);\n        }\n\n        /**\n         * A lazy build of unmodifiable incoming edge set.\n         *\n         * @return\n         */\n        public Set<EE> getUnmodifiableIncomingEdges()\n        {\n            if (unmodifiableIncoming == null) {\n                unmodifiableIncoming = Collections.unmodifiableSet(incoming);\n            }\n\n            return unmodifiableIncoming;\n        }\n\n        /**\n         * A lazy build of unmodifiable outgoing edge set.\n         *\n         * @return\n         */\n        public Set<EE> getUnmodifiableOutgoingEdges()\n        {\n            if (unmodifiableOutgoing == null) {\n                unmodifiableOutgoing = Collections.unmodifiableSet(outgoing);\n            }\n\n            return unmodifiableOutgoing;\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void addIncomingEdge(EE e)\n        {\n            incoming.add(e);\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void addOutgoingEdge(EE e)\n        {\n            outgoing.add(e);\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void removeIncomingEdge(EE e)\n        {\n            incoming.remove(e);\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void removeOutgoingEdge(EE e)\n        {\n            outgoing.remove(e);\n        }\n    }\n\n    /**\n     * .\n     *\n     * @author Barak Naveh\n     */\n    protected class DirectedSpecifics\n        extends Specifics\n        implements Serializable\n    {\n        private static final long serialVersionUID = 8971725103718958232L;\n        private static final String NOT_IN_DIRECTED_GRAPH =\n            \"no such operation in a directed graph\";\n\n        protected Map<V, DirectedEdgeContainer<V, E>> vertexMapDirected;\n\n        public DirectedSpecifics()\n        {\n            this(new LinkedHashMap<V, DirectedEdgeContainer<V, E>>());\n        }\n\n        public DirectedSpecifics(Map<V, DirectedEdgeContainer<V, E>> vertexMap)\n        {\n            this.vertexMapDirected = vertexMap;\n        }\n\n        @Override public void addVertex(V v)\n        {\n            // add with a lazy edge container entry\n            vertexMapDirected.put(v, null);\n        }\n\n        @Override public Set<V> getVertexSet()\n        {\n            return vertexMapDirected.keySet();\n        }\n\n        /**\n         * @see Graph#getAllEdges(Object, Object)\n         */\n        @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n        {\n            Set<E> edges = null;\n\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                edges = new ArrayUnenforcedSet<E>();\n\n                DirectedEdgeContainer<V, E> ec = getEdgeContainer(sourceVertex);\n\n                Iterator<E> iter = ec.outgoing.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    if (getEdgeTarget(e).equals(targetVertex)) {\n                        edges.add(e);\n                    }\n                }\n            }\n\n            return edges;\n        }\n\n        /**\n         * @see Graph#getEdge(Object, Object)\n         */\n        @Override public E getEdge(V sourceVertex, V targetVertex)\n        {\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                DirectedEdgeContainer<V, E> ec = getEdgeContainer(sourceVertex);\n\n                Iterator<E> iter = ec.outgoing.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    if (getEdgeTarget(e).equals(targetVertex)) {\n                        return e;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        @Override public void addEdgeToTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).addOutgoingEdge(e);\n            getEdgeContainer(target).addIncomingEdge(e);\n        }\n\n        /**\n         * @see UndirectedGraph#degreeOf(Object)\n         */\n        @Override public int degreeOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_DIRECTED_GRAPH);\n        }\n\n        /**\n         * @see Graph#edgesOf(Object)\n         */\n        @Override public Set<E> edgesOf(V vertex)\n        {\n            ArrayUnenforcedSet<E> inAndOut =\n                new ArrayUnenforcedSet<E>(getEdgeContainer(vertex).incoming);\n            inAndOut.addAll(getEdgeContainer(vertex).outgoing);\n\n            // we have two copies for each self-loop - remove one of them.\n            if (allowingLoops) {\n                Set<E> loops = getAllEdges(vertex, vertex);\n\n                for (int i = 0; i < inAndOut.size();) {\n                    Object e = inAndOut.get(i);\n\n                    if (loops.contains(e)) {\n                        inAndOut.remove(i);\n                        loops.remove(e); // so we remove it only once\n                    } else {\n                        i++;\n                    }\n                }\n            }\n\n            return Collections.unmodifiableSet(inAndOut);\n        }\n\n        /**\n         * @see DirectedGraph#inDegreeOf(Object)\n         */\n        @Override public int inDegreeOf(V vertex)\n        {\n            return getEdgeContainer(vertex).incoming.size();\n        }\n\n        /**\n         * @see DirectedGraph#incomingEdgesOf(Object)\n         */\n        @Override public Set<E> incomingEdgesOf(V vertex)\n        {\n            return getEdgeContainer(vertex).getUnmodifiableIncomingEdges();\n        }\n\n        /**\n         * @see DirectedGraph#outDegreeOf(Object)\n         */\n        @Override public int outDegreeOf(V vertex)\n        {\n            return getEdgeContainer(vertex).outgoing.size();\n        }\n\n        /**\n         * @see DirectedGraph#outgoingEdgesOf(Object)\n         */\n        @Override public Set<E> outgoingEdgesOf(V vertex)\n        {\n            return getEdgeContainer(vertex).getUnmodifiableOutgoingEdges();\n        }\n\n        @Override public void removeEdgeFromTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).removeOutgoingEdge(e);\n            getEdgeContainer(target).removeIncomingEdge(e);\n        }\n\n        /**\n         * A lazy build of edge container for specified vertex.\n         *\n         * @param vertex a vertex in this graph.\n         *\n         * @return EdgeContainer\n         */\n        private DirectedEdgeContainer<V, E> getEdgeContainer(V vertex)\n        {\n            assertVertexExist(vertex);\n\n            DirectedEdgeContainer<V, E> ec = vertexMapDirected.get(vertex);\n\n            if (ec == null) {\n                ec = new DirectedEdgeContainer<V, E>(edgeSetFactory, vertex);\n                vertexMapDirected.put(vertex, ec);\n            }\n\n            return ec;\n        }\n    }\n\n    /**\n     * A container of for vertex edges.\n     *\n     * <p>In this edge container we use array lists to minimize memory toll.\n     * However, for high-degree vertices we replace the entire edge container\n     * with a direct access subclass (to be implemented).</p>\n     *\n     * @author Barak Naveh\n     */\n    private static class UndirectedEdgeContainer<VV, EE>\n        implements Serializable\n    {\n        private static final long serialVersionUID = -6623207588411170010L;\n        Set<EE> vertexEdges;\n        private transient Set<EE> unmodifiableVertexEdges = null;\n\n        UndirectedEdgeContainer(\n            EdgeSetFactory<VV, EE> edgeSetFactory,\n            VV vertex)\n        {\n            vertexEdges = edgeSetFactory.createEdgeSet(vertex);\n        }\n\n        /**\n         * A lazy build of unmodifiable list of vertex edges\n         *\n         * @return\n         */\n        public Set<EE> getUnmodifiableVertexEdges()\n        {\n            if (unmodifiableVertexEdges == null) {\n                unmodifiableVertexEdges =\n                    Collections.unmodifiableSet(vertexEdges);\n            }\n\n            return unmodifiableVertexEdges;\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void addEdge(EE e)\n        {\n            vertexEdges.add(e);\n        }\n\n        /**\n         * .\n         *\n         * @return\n         */\n        public int edgeCount()\n        {\n            return vertexEdges.size();\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void removeEdge(EE e)\n        {\n            vertexEdges.remove(e);\n        }\n    }\n\n    /**\n     * .\n     *\n     * @author Barak Naveh\n     */\n    protected class UndirectedSpecifics\n        extends Specifics\n        implements Serializable\n    {\n        private static final long serialVersionUID = 6494588405178655873L;\n        private static final String NOT_IN_UNDIRECTED_GRAPH =\n            \"no such operation in an undirected graph\";\n\n        private Map<V, UndirectedEdgeContainer<V, E>> vertexMapUndirected;\n\n        public UndirectedSpecifics()\n        {\n            this(new LinkedHashMap<V, UndirectedEdgeContainer<V, E>>());\n        }\n\n        public UndirectedSpecifics(\n            Map<V, UndirectedEdgeContainer<V, E>> vertexMap)\n        {\n            this.vertexMapUndirected = vertexMap;\n        }\n\n        @Override public void addVertex(V v)\n        {\n            // add with a lazy edge container entry\n            vertexMapUndirected.put(v, null);\n        }\n\n        @Override public Set<V> getVertexSet()\n        {\n            return vertexMapUndirected.keySet();\n        }\n\n        /**\n         * @see Graph#getAllEdges(Object, Object)\n         */\n        @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n        {\n            Set<E> edges = null;\n\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                edges = new ArrayUnenforcedSet<E>();\n\n                Iterator<E> iter =\n                    getEdgeContainer(sourceVertex).vertexEdges.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    boolean equal =\n                        isEqualsStraightOrInverted(\n                            sourceVertex,\n                            targetVertex,\n                            e);\n\n                    if (equal) {\n                        edges.add(e);\n                    }\n                }\n            }\n\n            return edges;\n        }\n\n        /**\n         * @see Graph#getEdge(Object, Object)\n         */\n        @Override public E getEdge(V sourceVertex, V targetVertex)\n        {\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                Iterator<E> iter =\n                    getEdgeContainer(sourceVertex).vertexEdges.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    boolean equal =\n                        isEqualsStraightOrInverted(\n                            sourceVertex,\n                            targetVertex,\n                            e);\n\n                    if (equal) {\n                        return e;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        private boolean isEqualsStraightOrInverted(\n            Object sourceVertex,\n            Object targetVertex,\n            E e)\n        {\n            boolean equalStraight =\n                sourceVertex.equals(getEdgeSource(e))\n                && targetVertex.equals(getEdgeTarget(e));\n\n            boolean equalInverted =\n                sourceVertex.equals(getEdgeTarget(e))\n                && targetVertex.equals(getEdgeSource(e));\n            return equalStraight || equalInverted;\n        }\n\n        @Override public void addEdgeToTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).addEdge(e);\n\n            if (!source.equals(target)) {\n                getEdgeContainer(target).addEdge(e);\n            }\n        }\n\n        @Override public int degreeOf(V vertex)\n        {\n            if (allowingLoops) { // then we must count, and add loops twice\n\n                int degree = 0;\n                Set<E> edges = getEdgeContainer(vertex).vertexEdges;\n\n                for (E e : edges) {\n                    if (getEdgeSource(e).equals(getEdgeTarget(e))) {\n                        degree += 2;\n                    } else {\n                        degree += 1;\n                    }\n                }\n\n                return degree;\n            } else {\n                return getEdgeContainer(vertex).edgeCount();\n            }\n        }\n\n        /**\n         * @see Graph#edgesOf(Object)\n         */\n        @Override public Set<E> edgesOf(V vertex)\n        {\n            return getEdgeContainer(vertex).getUnmodifiableVertexEdges();\n        }\n\n        /**\n         * @see DirectedGraph#inDegreeOf(Object)\n         */\n        @Override public int inDegreeOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        /**\n         * @see DirectedGraph#incomingEdgesOf(Object)\n         */\n        @Override public Set<E> incomingEdgesOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        /**\n         * @see DirectedGraph#outDegreeOf(Object)\n         */\n        @Override public int outDegreeOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        /**\n         * @see DirectedGraph#outgoingEdgesOf(Object)\n         */\n        @Override public Set<E> outgoingEdgesOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        @Override public void removeEdgeFromTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).removeEdge(e);\n\n            if (!source.equals(target)) {\n                getEdgeContainer(target).removeEdge(e);\n            }\n        }\n\n        /**\n         * A lazy build of edge container for specified vertex.\n         *\n         * @param vertex a vertex in this graph.\n         *\n         * @return EdgeContainer\n         */\n        private UndirectedEdgeContainer<V, E> getEdgeContainer(V vertex)\n        {\n            assertVertexExist(vertex);\n\n            UndirectedEdgeContainer<V, E> ec = vertexMapUndirected.get(vertex);\n\n            if (ec == null) {\n                ec = new UndirectedEdgeContainer<V, E>(\n                    edgeSetFactory,\n                    vertex);\n                vertexMapUndirected.put(vertex, ec);\n            }\n\n            return ec;\n        }\n    }\n}\n\n// End AbstractBaseGraph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "isAllowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * Returns <code>true</code> if and only if self-loops are allowed in this\n * graph. A self loop is an edge that its source and target vertices are the\n * same.\n *\n * @return <code>true</code> if and only if graph loops are allowed.\n */\npublic boolean isAllowingLoops() {\n    return allowingLoops;\n}"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#containsVertex(Object)\n */\n@Override\npublic boolean containsVertex(V v) {\n    return specifics.getVertexSet().contains(v);\n}"
            ],
            [
                "clone",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * Returns a shallow copy of this graph instance. Neither edges nor vertices\n * are cloned.\n *\n * @return a shallow copy of this set.\n *\n * @throws RuntimeException\n *\n * @see java.lang.Object#clone()\n */\n@Override\npublic Object clone() {\n    try {\n        TypeUtil<AbstractBaseGraph<V, E>> typeDecl = null;\n        AbstractBaseGraph<V, E> newGraph = TypeUtil.uncheckedCast(super.clone(), typeDecl);\n        newGraph.edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n        newGraph.edgeFactory = this.edgeFactory;\n        newGraph.unmodifiableEdgeSet = null;\n        newGraph.unmodifiableVertexSet = null;\n        // NOTE:  it's important for this to happen in an object\n        // method so that the new inner class instance gets associated with\n        // the right outer class instance\n        newGraph.specifics = newGraph.createSpecifics();\n        Graphs.addGraph(newGraph, this);\n        return newGraph;\n    } catch (CloneNotSupportedException e) {\n        e.printStackTrace();\n        throw new RuntimeException();\n    }\n}"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#edgesOf(Object)\n */\n@Override\npublic Set<E> edgesOf(V vertex) {\n    return specifics.edgesOf(vertex);\n}"
            ],
            [
                "createDirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected DirectedSpecifics createDirectedSpecifics() {\n    return new DirectedSpecifics();\n}"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#removeEdge(Object)\n */\n@Override\npublic boolean removeEdge(E e) {\n    if (containsEdge(e)) {\n        specifics.removeEdgeFromTouchingVertices(e);\n        edgeMap.remove(e);\n        return true;\n    } else {\n        return false;\n    }\n}"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#addEdge(Object, Object, Object)\n */\n@Override\npublic boolean addEdge(V sourceVertex, V targetVertex, E e) {\n    if (e == null) {\n        throw new NullPointerException();\n    } else if (containsEdge(e)) {\n        return false;\n    }\n    assertVertexExist(sourceVertex);\n    assertVertexExist(targetVertex);\n    if (!allowingMultipleEdges && containsEdge(sourceVertex, targetVertex)) {\n        return false;\n    }\n    if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n        throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n    }\n    IntrusiveEdge intrusiveEdge = createIntrusiveEdge(e, sourceVertex, targetVertex);\n    edgeMap.put(e, intrusiveEdge);\n    specifics.addEdgeToTouchingVertices(e);\n    return true;\n}"
            ],
            [
                "outDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see DirectedGraph#outDegreeOf(Object)\n */\npublic int outDegreeOf(V vertex) {\n    return specifics.outDegreeOf(vertex);\n}"
            ],
            [
                "inDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see DirectedGraph#inDegreeOf(Object)\n */\npublic int inDegreeOf(V vertex) {\n    return specifics.inDegreeOf(vertex);\n}"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#containsEdge(Object)\n */\n@Override\npublic boolean containsEdge(E e) {\n    return edgeMap.containsKey(e);\n}"
            ],
            [
                "createUndirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected UndirectedSpecifics createUndirectedSpecifics() {\n    return new UndirectedSpecifics();\n}"
            ],
            [
                "isAllowingMultipleEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * Returns <code>true</code> if and only if multiple edges are allowed in\n * this graph. The meaning of multiple edges is that there can be many edges\n * going from vertex v1 to vertex v2.\n *\n * @return <code>true</code> if and only if multiple edges are allowed.\n */\npublic boolean isAllowingMultipleEdges() {\n    return allowingMultipleEdges;\n}"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#addEdge(Object, Object)\n */\n@Override\npublic E addEdge(V sourceVertex, V targetVertex) {\n    assertVertexExist(sourceVertex);\n    assertVertexExist(targetVertex);\n    if (!allowingMultipleEdges && containsEdge(sourceVertex, targetVertex)) {\n        return null;\n    }\n    if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n        throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n    }\n    E e = edgeFactory.createEdge(sourceVertex, targetVertex);\n    if (containsEdge(e)) {\n        // this restriction should stay!\n        return null;\n    } else {\n        IntrusiveEdge intrusiveEdge = createIntrusiveEdge(e, sourceVertex, targetVertex);\n        edgeMap.put(e, intrusiveEdge);\n        specifics.addEdgeToTouchingVertices(e);\n        return e;\n    }\n}"
            ],
            [
                "degreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see UndirectedGraph#degreeOf(Object)\n */\npublic int degreeOf(V vertex) {\n    return specifics.degreeOf(vertex);\n}"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#getEdgeFactory()\n */\n@Override\npublic EdgeFactory<V, E> getEdgeFactory() {\n    return edgeFactory;\n}"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#addVertex(Object)\n */\n@Override\npublic boolean addVertex(V v) {\n    if (v == null) {\n        throw new NullPointerException();\n    } else if (containsVertex(v)) {\n        return false;\n    } else {\n        specifics.addVertex(v);\n        return true;\n    }\n}"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public String toString()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#getEdgeSource(Object)\n */\n@Override\npublic V getEdgeSource(E e) {\n    return TypeUtil.uncheckedCast(getIntrusiveEdge(e).source, vertexTypeDecl);\n}"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#removeEdge(Object, Object)\n */\n@Override\npublic E removeEdge(V sourceVertex, V targetVertex) {\n    E e = getEdge(sourceVertex, targetVertex);\n    if (e != null) {\n        specifics.removeEdgeFromTouchingVertices(e);\n        edgeMap.remove(e);\n    }\n    return e;\n}"
            ],
            [
                "edgeSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#edgeSet()\n */\n@Override\npublic Set<E> edgeSet() {\n    if (unmodifiableEdgeSet == null) {\n        unmodifiableEdgeSet = Collections.unmodifiableSet(edgeMap.keySet());\n    }\n    return unmodifiableEdgeSet;\n}"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#vertexSet()\n */\n@Override\npublic Set<V> vertexSet() {\n    if (unmodifiableVertexSet == null) {\n        unmodifiableVertexSet = Collections.unmodifiableSet(specifics.getVertexSet());\n    }\n    return unmodifiableVertexSet;\n}"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#getAllEdges(Object, Object)\n */\n@Override\npublic Set<E> getAllEdges(V sourceVertex, V targetVertex) {\n    return specifics.getAllEdges(sourceVertex, targetVertex);\n}"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see DirectedGraph#outgoingEdgesOf(Object)\n */\npublic Set<E> outgoingEdgesOf(V vertex) {\n    return specifics.outgoingEdgesOf(vertex);\n}"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see DirectedGraph#incomingEdgesOf(Object)\n */\npublic Set<E> incomingEdgesOf(V vertex) {\n    return specifics.incomingEdgesOf(vertex);\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#getEdge(Object, Object)\n */\n@Override\npublic E getEdge(V sourceVertex, V targetVertex) {\n    return specifics.getEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#getEdgeTarget(Object)\n */\n@Override\npublic V getEdgeTarget(E e) {\n    return TypeUtil.uncheckedCast(getIntrusiveEdge(e).target, vertexTypeDecl);\n}"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#getEdgeWeight(Object)\n */\n@Override\npublic double getEdgeWeight(E e) {\n    if (e instanceof DefaultWeightedEdge) {\n        return ((DefaultWeightedEdge) e).getWeight();\n    } else if (e == null) {\n        throw new NullPointerException();\n    } else {\n        return WeightedGraph.DEFAULT_EDGE_WEIGHT;\n    }\n}"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "/**\n * @see Graph#removeVertex(Object)\n */\n@Override\npublic boolean removeVertex(V v) {\n    if (containsVertex(v)) {\n        Set<E> touchingEdgesList = edgesOf(v);\n        // cannot iterate over list - will cause\n        // ConcurrentModificationException\n        removeAllEdges(new ArrayList<E>(touchingEdgesList));\n        // remove the vertex itself\n        specifics.getVertexSet().remove(v);\n        return true;\n    } else {\n        return false;\n    }\n}"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "allowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "boolean allowingLoops;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 25965,
        "oracle": "g instanceof ListenableGraph;",
        "oracleType": "EXCEPT_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "DefaultListenableGraph",
        "javadocTag": "@throws IllegalArgumentException if the backing graph is already a\nlistenable graph.",
        "methodJavadoc": "    /**\n     * Creates a new listenable graph. If the <code>reuseEvents</code> flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @param g the backing graph.\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     *\n     * @throws IllegalArgumentException if the backing graph is already a\n     * listenable graph.\n     */",
        "methodSourceCode": "public DefaultListenableGraph(Graph<V, E> g, boolean reuseEvents){\n    super(g);\n    this.reuseEvents = reuseEvents;\n    reuseableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, -1, null);\n    reuseableVertexEvent = new FlyweightVertexEvent<V>(this, -1, null);\n    // the following restriction could be probably relaxed in the future.\n    if (g instanceof ListenableGraph<?, ?>) {\n        throw new IllegalArgumentException(\"base graph cannot be listenable\");\n    }\n}",
        "classJavadoc": "/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * DefaultListenableGraph.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 04-Aug-2003 : Strong refs to listeners instead of weak refs (BN);\n * 10-Aug-2003 : Adaptation to new event model (BN);\n * 07-Mar-2004 : Fixed unnecessary clone bug #819075 (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.DirectedGraph;\nimport org.jgrapht.EdgeFactory;\nimport org.jgrapht.Graph;\nimport org.jgrapht.GraphHelper;\nimport org.jgrapht.GraphMapping;\nimport org.jgrapht.GraphPath;\nimport org.jgrapht.Graphs;\nimport org.jgrapht.ListenableGraph;\nimport org.jgrapht.UndirectedGraph;\nimport org.jgrapht.VertexFactory;\nimport org.jgrapht.WeightedGraph;\nimport org.jgrapht.event.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */\npublic class DefaultListenableGraph<V, E>\n    extends GraphDelegator<V, E>\n    implements ListenableGraph<V, E>,\n        Cloneable\n{\n    private static final long serialVersionUID = 3977575900898471984L;\n\n    private List<GraphListener<V, E>> graphListeners =\n        new ArrayList<GraphListener<V, E>>();\n    private List<VertexSetListener<V>> vertexSetListeners =\n        new ArrayList<VertexSetListener<V>>();\n    private FlyweightEdgeEvent<V, E> reuseableEdgeEvent;\n    private FlyweightVertexEvent<V> reuseableVertexEvent;\n    private boolean reuseEvents;\n\n    /**\n     * Creates a new listenable graph.\n     *\n     * @param g the backing graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g)\n    {\n        this(g, false);\n    }\n\n    /**\n     * Creates a new listenable graph. If the <code>reuseEvents</code> flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @param g the backing graph.\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     *\n     * @throws IllegalArgumentException if the backing graph is already a\n     * listenable graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g, boolean reuseEvents)\n    {\n        super(g);\n        this.reuseEvents = reuseEvents;\n        reuseableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, -1, null);\n        reuseableVertexEvent = new FlyweightVertexEvent<V>(this, -1, null);\n\n        // the following restriction could be probably relaxed in the future.\n        if (g instanceof ListenableGraph<?, ?>) {\n            throw new IllegalArgumentException(\n                \"base graph cannot be listenable\");\n        }\n    }\n\n    /**\n     * If the <code>reuseEvents</code> flag is set to <code>true</code> this\n     * class will reuse previously fired events and will not create a new object\n     * for each event. This option increases performance but should be used with\n     * care, especially in multithreaded environment.\n     *\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     */\n    public void setReuseEvents(boolean reuseEvents)\n    {\n        this.reuseEvents = reuseEvents;\n    }\n\n    /**\n     * Tests whether the <code>reuseEvents</code> flag is set. If the flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @return the value of the <code>reuseEvents</code> flag.\n     */\n    public boolean isReuseEvents()\n    {\n        return reuseEvents;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object)\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.addEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        boolean added = super.addEdge(sourceVertex, targetVertex, e);\n\n        if (added) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return added;\n    }\n\n    /**\n     * @see ListenableGraph#addGraphListener(GraphListener)\n     */\n    @Override public void addGraphListener(GraphListener<V, E> l)\n    {\n        addToListenerList(graphListeners, l);\n    }\n\n    /**\n     * @see Graph#addVertex(Object)\n     */\n    @Override public boolean addVertex(V v)\n    {\n        boolean modified = super.addVertex(v);\n\n        if (modified) {\n            fireVertexAdded(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#addVertexSetListener(VertexSetListener)\n     */\n    @Override public void addVertexSetListener(VertexSetListener<V> l)\n    {\n        addToListenerList(vertexSetListeners, l);\n    }\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override public Object clone()\n    {\n        try {\n            TypeUtil<DefaultListenableGraph<V, E>> typeDecl = null;\n\n            DefaultListenableGraph<V, E> g =\n                TypeUtil.uncheckedCast(super.clone(), typeDecl);\n            g.graphListeners = new ArrayList<GraphListener<V, E>>();\n            g.vertexSetListeners = new ArrayList<VertexSetListener<V>>();\n\n            return g;\n        } catch (CloneNotSupportedException e) {\n            // should never get here since we're Cloneable\n            e.printStackTrace();\n            throw new RuntimeException(\"internal error\");\n        }\n    }\n\n    /**\n     * @see Graph#removeEdge(Object, Object)\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.removeEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#removeEdge(Object)\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        V sourceVertex = getEdgeSource(e);\n        V targetVertex = getEdgeTarget(e);\n\n        boolean modified = super.removeEdge(e);\n\n        if (modified) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#removeGraphListener(GraphListener)\n     */\n    @Override public void removeGraphListener(GraphListener<V, E> l)\n    {\n        graphListeners.remove(l);\n    }\n\n    /**\n     * @see Graph#removeVertex(Object)\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        if (containsVertex(v)) {\n            Set<E> touchingEdgesList = edgesOf(v);\n\n            // copy set to avoid ConcurrentModificationException\n            removeAllEdges(new ArrayList<E>(touchingEdgesList));\n\n            super.removeVertex(v); // remove the vertex itself\n\n            fireVertexRemoved(v);\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @see ListenableGraph#removeVertexSetListener(VertexSetListener)\n     */\n    @Override public void removeVertexSetListener(VertexSetListener<V> l)\n    {\n        vertexSetListeners.remove(l);\n    }\n\n    /**\n     * Notify listeners that the specified edge was added.\n     *\n     * @param edge the edge that was added.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeAdded(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_ADDED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified edge was removed.\n     *\n     * @param edge the edge that was removed.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeRemoved(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_REMOVED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeRemoved(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was added.\n     *\n     * @param vertex the vertex that was added.\n     */\n    protected void fireVertexAdded(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_ADDED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexAdded(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was removed.\n     *\n     * @param vertex the vertex that was removed.\n     */\n    protected void fireVertexRemoved(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_REMOVED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexRemoved(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexRemoved(e);\n        }\n    }\n\n    private static <L extends EventListener> void addToListenerList(\n        List<L> list,\n        L l)\n    {\n        if (!list.contains(l)) {\n            list.add(l);\n        }\n    }\n\n    private GraphEdgeChangeEvent<V, E> createGraphEdgeChangeEvent(\n        int eventType,\n        E edge,\n        V source,\n        V target)\n    {\n        if (reuseEvents) {\n            reuseableEdgeEvent.setType(eventType);\n            reuseableEdgeEvent.setEdge(edge);\n            reuseableEdgeEvent.setEdgeSource(source);\n            reuseableEdgeEvent.setEdgeTarget(target);\n\n            return reuseableEdgeEvent;\n        } else {\n            return new GraphEdgeChangeEvent<V, E>(\n                this,\n                eventType,\n                edge,\n                source,\n                target);\n        }\n    }\n\n    private GraphVertexChangeEvent<V> createGraphVertexChangeEvent(\n        int eventType,\n        V vertex)\n    {\n        if (reuseEvents) {\n            reuseableVertexEvent.setType(eventType);\n            reuseableVertexEvent.setVertex(vertex);\n\n            return reuseableVertexEvent;\n        } else {\n            return new GraphVertexChangeEvent<V>(this, eventType, vertex);\n        }\n    }\n\n    /**\n     * A reuseable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightEdgeEvent<VV, EE>\n        extends GraphEdgeChangeEvent<VV, EE>\n    {\n        private static final long serialVersionUID = 3907207152526636089L;\n\n        /**\n         * @see GraphEdgeChangeEvent#GraphEdgeChangeEvent(Object, int, Edge)\n         */\n        public FlyweightEdgeEvent(Object eventSource, int type, EE e)\n        {\n            super(eventSource, type, e);\n        }\n\n        /**\n         * Sets the edge of this event.\n         *\n         * @param e the edge to be set.\n         */\n        protected void setEdge(EE e)\n        {\n            this.edge = e;\n        }\n\n        protected void setEdgeSource(VV v)\n        {\n            this.edgeSource = v;\n        }\n\n        protected void setEdgeTarget(VV v)\n        {\n            this.edgeTarget = v;\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type the type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n    }\n\n    /**\n     * A reuseable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightVertexEvent<VV>\n        extends GraphVertexChangeEvent<VV>\n    {\n        private static final long serialVersionUID = 3257848787857585716L;\n\n        /**\n         * @see GraphVertexChangeEvent#GraphVertexChangeEvent(Object, int,\n         * Object)\n         */\n        public FlyweightVertexEvent(Object eventSource, int type, VV vertex)\n        {\n            super(eventSource, type, vertex);\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n\n        /**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         */\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }\n}\n\n// End DefaultListenableGraph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "g",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "reuseEvents",
                "",
                "boolean"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "vertexSet",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<V> vertexSet()"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public double getEdgeWeight(E arg0)"
            ],
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "DefaultListenableGraph",
                "/**\n * @see Graph#removeEdge(Object)\n */\n@Override\npublic boolean removeEdge(E e) {\n    V sourceVertex = getEdgeSource(e);\n    V targetVertex = getEdgeTarget(e);\n    boolean modified = super.removeEdge(e);\n    if (modified) {\n        fireEdgeRemoved(e, sourceVertex, targetVertex);\n    }\n    return modified;\n}"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public boolean containsVertex(V arg0)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public V getEdgeSource(E arg0)"
            ],
            [
                "isReuseEvents",
                "org.jgrapht.graph",
                "DefaultListenableGraph",
                "/**\n * Tests whether the <code>reuseEvents</code> flag is set. If the flag is\n * set to <code>true</code> this class will reuse previously fired events\n * and will not create a new object for each event. This option increases\n * performance but should be used with care, especially in multithreaded\n * environment.\n *\n * @return the value of the <code>reuseEvents</code> flag.\n */\npublic boolean isReuseEvents() {\n    return reuseEvents;\n}"
            ],
            [
                "degreeOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public int degreeOf(V arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> edgesOf(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "DefaultListenableGraph",
                "/**\n * @see Graph#addEdge(Object, Object, Object)\n */\n@Override\npublic boolean addEdge(V sourceVertex, V targetVertex, E e) {\n    boolean added = super.addEdge(sourceVertex, targetVertex, e);\n    if (added) {\n        fireEdgeAdded(e, sourceVertex, targetVertex);\n    }\n    return added;\n}"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "DefaultListenableGraph",
                "/**\n * @see Graph#removeEdge(Object, Object)\n */\n@Override\npublic E removeEdge(V sourceVertex, V targetVertex) {\n    E e = super.removeEdge(sourceVertex, targetVertex);\n    if (e != null) {\n        fireEdgeRemoved(e, sourceVertex, targetVertex);\n    }\n    return e;\n}"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public V getEdgeTarget(E arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public E getEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "inDegreeOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public int inDegreeOf(V arg0)"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "clone",
                "org.jgrapht.graph",
                "DefaultListenableGraph",
                "/**\n * @see java.lang.Object#clone()\n */\n@Override\npublic Object clone() {\n    try {\n        TypeUtil<DefaultListenableGraph<V, E>> typeDecl = null;\n        DefaultListenableGraph<V, E> g = TypeUtil.uncheckedCast(super.clone(), typeDecl);\n        g.graphListeners = new ArrayList<GraphListener<V, E>>();\n        g.vertexSetListeners = new ArrayList<VertexSetListener<V>>();\n        return g;\n    } catch (CloneNotSupportedException e) {\n        // should never get here since we're Cloneable\n        e.printStackTrace();\n        throw new RuntimeException(\"internal error\");\n    }\n}"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public boolean containsEdge(E arg0)"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public String toString()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "DefaultListenableGraph",
                "/**\n * @see Graph#addVertex(Object)\n */\n@Override\npublic boolean addVertex(V v) {\n    boolean modified = super.addVertex(v);\n    if (modified) {\n        fireVertexAdded(v);\n    }\n    return modified;\n}"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "DefaultListenableGraph",
                "/**\n * @see Graph#removeVertex(Object)\n */\n@Override\npublic boolean removeVertex(V v) {\n    if (containsVertex(v)) {\n        Set<E> touchingEdgesList = edgesOf(v);\n        // copy set to avoid ConcurrentModificationException\n        removeAllEdges(new ArrayList<E>(touchingEdgesList));\n        // remove the vertex itself\n        super.removeVertex(v);\n        fireVertexRemoved(v);\n        return true;\n    } else {\n        return false;\n    }\n}"
            ],
            [
                "edgeSet",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> edgeSet()"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "outDegreeOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public int outDegreeOf(V arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "DefaultListenableGraph",
                "/**\n * @see Graph#addEdge(Object, Object)\n */\n@Override\npublic E addEdge(V sourceVertex, V targetVertex) {\n    E e = super.addEdge(sourceVertex, targetVertex);\n    if (e != null) {\n        fireEdgeAdded(e, sourceVertex, targetVertex);\n    }\n    return e;\n}"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 25982,
        "oracle": "v == null;",
        "oracleType": "EXCEPT_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "Subgraph",
        "javadocTag": "@throws NullPointerException",
        "methodJavadoc": "    /**\n     * Adds the specified vertex to this subgraph.\n     *\n     * @param v the vertex to be added.\n     *\n     * @return <code>true</code> if the vertex was added, otherwise <code>\n     * false</code>.\n     *\n     * @throws NullPointerException\n     * @throws IllegalArgumentException\n     *\n     * @see Subgraph\n     * @see Graph#addVertex(Object)\n     */",
        "methodSourceCode": "public boolean addVertex(V v){\n    if (v == null) {\n        throw new NullPointerException();\n    }\n    if (!base.containsVertex(v)) {\n        throw new IllegalArgumentException(NO_SUCH_VERTEX_IN_BASE);\n    }\n    if (containsVertex(v)) {\n        return false;\n    } else {\n        vertexSet.add(v);\n        return true;\n    }\n}",
        "classJavadoc": "/**\n * A subgraph is a graph that has a subset of vertices and a subset of edges\n * with respect to some base graph. More formally, a subgraph G(V,E) that is\n * based on a base graph Gb(Vb,Eb) satisfies the following <b><i>subgraph\n * property</i></b>: V is a subset of Vb and E is a subset of Eb. Other than\n * this property, a subgraph is a graph with any respect and fully complies with\n * the <code>Graph</code> interface.\n *\n * <p>If the base graph is a {@link org.jgrapht.ListenableGraph}, the subgraph\n * listens on the base graph and guarantees the subgraph property. If an edge or\n * a vertex is removed from the base graph, it is automatically removed from the\n * subgraph. Subgraph listeners are informed on such removal only if it results\n * in a cascaded removal from the subgraph. If the subgraph has been created as\n * an induced subgraph it also keeps track of edges being added to its vertices.\n * If vertices are added to the base graph, the subgraph remains unaffected.</p>\n *\n * <p>If the base graph is <i>not</i> a ListenableGraph, then the subgraph\n * property cannot be guaranteed. If edges or vertices are removed from the base\n * graph, they are <i>not</i> removed from the subgraph.</p>\n *\n * <p>Modifications to Subgraph are allowed as long as the subgraph property is\n * maintained. Addition of vertices or edges are allowed as long as they also\n * exist in the base graph. Removal of vertices or edges is always allowed. The\n * base graph is <i>never</i> affected by any modification made to the\n * subgraph.</p>\n *\n * <p>A subgraph may provide a \"live-window\" on a base graph, so that changes\n * made to its vertices or edges are immediately reflected in the base graph,\n * and vice versa. For that to happen, vertices and edges added to the subgraph\n * must be <i>identical</i> (that is, reference-equal and not only value-equal)\n * to their respective ones in the base graph. Previous versions of this class\n * enforced such identity, at a severe performance cost. Currently it is no\n * longer enforced. If you want to achieve a \"live-window\"functionality, your\n * safest tactics would be to NOT override the <code>equals()</code> methods of\n * your vertices and edges. If you use a class that has already overridden the\n * <code>equals()</code> method, such as <code>String</code>, than you can use a\n * wrapper around it, or else use it directly but exercise a great care to avoid\n * having different-but-equal instances in the subgraph and the base graph.</p>\n *\n * <p>This graph implementation guarantees deterministic vertex and edge set\n * ordering (via {@link LinkedHashSet}).</p>\n *\n * @author Barak Naveh\n * @see Graph\n * @see Set\n * @since Jul 18, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------\n * Subgraph.java\n * -------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 26-Jul-2003 : Accurate constructors to avoid casting problems (BN);\n * 10-Aug-2003 : Adaptation to new event model (BN);\n * 23-Oct-2003 : Allowed non-listenable graph as base (BN);\n * 07-Feb-2004 : Enabled serialization (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 15-Mar-2004 : Integrity is now checked using Maps (CH);\n * 20-Mar-2004 : Cancelled verification of element identity to base graph (BN);\n * 21-Sep-2004 : Added induced subgraph (who?)\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.event.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A subgraph is a graph that has a subset of vertices and a subset of edges\n * with respect to some base graph. More formally, a subgraph G(V,E) that is\n * based on a base graph Gb(Vb,Eb) satisfies the following <b><i>subgraph\n * property</i></b>: V is a subset of Vb and E is a subset of Eb. Other than\n * this property, a subgraph is a graph with any respect and fully complies with\n * the <code>Graph</code> interface.\n *\n * <p>If the base graph is a {@link org.jgrapht.ListenableGraph}, the subgraph\n * listens on the base graph and guarantees the subgraph property. If an edge or\n * a vertex is removed from the base graph, it is automatically removed from the\n * subgraph. Subgraph listeners are informed on such removal only if it results\n * in a cascaded removal from the subgraph. If the subgraph has been created as\n * an induced subgraph it also keeps track of edges being added to its vertices.\n * If vertices are added to the base graph, the subgraph remains unaffected.</p>\n *\n * <p>If the base graph is <i>not</i> a ListenableGraph, then the subgraph\n * property cannot be guaranteed. If edges or vertices are removed from the base\n * graph, they are <i>not</i> removed from the subgraph.</p>\n *\n * <p>Modifications to Subgraph are allowed as long as the subgraph property is\n * maintained. Addition of vertices or edges are allowed as long as they also\n * exist in the base graph. Removal of vertices or edges is always allowed. The\n * base graph is <i>never</i> affected by any modification made to the\n * subgraph.</p>\n *\n * <p>A subgraph may provide a \"live-window\" on a base graph, so that changes\n * made to its vertices or edges are immediately reflected in the base graph,\n * and vice versa. For that to happen, vertices and edges added to the subgraph\n * must be <i>identical</i> (that is, reference-equal and not only value-equal)\n * to their respective ones in the base graph. Previous versions of this class\n * enforced such identity, at a severe performance cost. Currently it is no\n * longer enforced. If you want to achieve a \"live-window\"functionality, your\n * safest tactics would be to NOT override the <code>equals()</code> methods of\n * your vertices and edges. If you use a class that has already overridden the\n * <code>equals()</code> method, such as <code>String</code>, than you can use a\n * wrapper around it, or else use it directly but exercise a great care to avoid\n * having different-but-equal instances in the subgraph and the base graph.</p>\n *\n * <p>This graph implementation guarantees deterministic vertex and edge set\n * ordering (via {@link LinkedHashSet}).</p>\n *\n * @author Barak Naveh\n * @see Graph\n * @see Set\n * @since Jul 18, 2003\n */\npublic class Subgraph<V, E, G extends Graph<V, E>>\n    extends AbstractGraph<V, E>\n    implements Serializable\n{\n    private static final long serialVersionUID = 3208313055169665387L;\n    private static final String NO_SUCH_EDGE_IN_BASE =\n        \"no such edge in base graph\";\n    private static final String NO_SUCH_VERTEX_IN_BASE =\n        \"no such vertex in base graph\";\n\n    //\n    Set<E> edgeSet = new LinkedHashSet<E>(); // friendly to improve performance\n    Set<V> vertexSet = new LinkedHashSet<V>(); // friendly to improve\n\n    // performance\n\n    //\n    private transient Set<E> unmodifiableEdgeSet = null;\n    private transient Set<V> unmodifiableVertexSet = null;\n    private G base;\n    private boolean isInduced = false;\n\n    /**\n     * Creates a new Subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null</code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null</code> then all the edges whose vertices found in the graph are\n     * included.\n     */\n    public Subgraph(G base, Set<V> vertexSubset, Set<E> edgeSubset)\n    {\n        super();\n\n        this.base = base;\n\n        if (edgeSubset == null) {\n            isInduced = true;\n        }\n\n        if (base instanceof ListenableGraph<?, ?>) {\n            ((ListenableGraph<V, E>) base).addGraphListener(\n                new BaseGraphListener());\n        }\n\n        addVerticesUsingFilter(base.vertexSet(), vertexSubset);\n        addEdgesUsingFilter(base.edgeSet(), edgeSubset);\n    }\n\n    /**\n     * Creates a new induced Subgraph. The subgraph will keep track of edges\n     * being added to its vertex subset as well as deletion of edges and\n     * vertices. If base it not listenable, this is identical to the call\n     * Subgraph(base, vertexSubset, null) .\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null</code> then all vertices are included.\n     */\n    public Subgraph(G base, Set<V> vertexSubset)\n    {\n        this(base, vertexSubset, null);\n    }\n\n    /**\n     * @see Graph#getAllEdges(Object, Object)\n     */\n    @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        Set<E> edges = null;\n\n        if (containsVertex(sourceVertex) && containsVertex(targetVertex)) {\n            edges = new ArrayUnenforcedSet<E>();\n\n            Set<E> baseEdges = base.getAllEdges(sourceVertex, targetVertex);\n\n            for (Iterator<E> iter = baseEdges.iterator(); iter.hasNext();) {\n                E e = iter.next();\n\n                if (edgeSet.contains(e)) { // add if subgraph also contains\n                                           // it\n                    edges.add(e);\n                }\n            }\n        }\n\n        return edges;\n    }\n\n    /**\n     * @see Graph#getEdge(Object, Object)\n     */\n    @Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        Set<E> edges = getAllEdges(sourceVertex, targetVertex);\n\n        if ((edges == null) || edges.isEmpty()) {\n            return null;\n        } else {\n            return edges.iterator().next();\n        }\n    }\n\n    /**\n     * @see Graph#getEdgeFactory()\n     */\n    @Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        return base.getEdgeFactory();\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object)\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        if (!base.containsEdge(sourceVertex, targetVertex)) {\n            throw new IllegalArgumentException(NO_SUCH_EDGE_IN_BASE);\n        }\n\n        Set<E> edges = base.getAllEdges(sourceVertex, targetVertex);\n\n        for (Iterator<E> iter = edges.iterator(); iter.hasNext();) {\n            E e = iter.next();\n\n            if (!containsEdge(e)) {\n                edgeSet.add(e);\n\n                return e;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        }\n\n        if (!base.containsEdge(e)) {\n            throw new IllegalArgumentException(NO_SUCH_EDGE_IN_BASE);\n        }\n\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        assert (base.getEdgeSource(e) == sourceVertex);\n        assert (base.getEdgeTarget(e) == targetVertex);\n\n        if (containsEdge(e)) {\n            return false;\n        } else {\n            edgeSet.add(e);\n\n            return true;\n        }\n    }\n\n    /**\n     * Adds the specified vertex to this subgraph.\n     *\n     * @param v the vertex to be added.\n     *\n     * @return <code>true</code> if the vertex was added, otherwise <code>\n     * false</code>.\n     *\n     * @throws NullPointerException\n     * @throws IllegalArgumentException\n     *\n     * @see Subgraph\n     * @see Graph#addVertex(Object)\n     */\n    @Override public boolean addVertex(V v)\n    {\n        if (v == null) {\n            throw new NullPointerException();\n        }\n\n        if (!base.containsVertex(v)) {\n            throw new IllegalArgumentException(NO_SUCH_VERTEX_IN_BASE);\n        }\n\n        if (containsVertex(v)) {\n            return false;\n        } else {\n            vertexSet.add(v);\n\n            return true;\n        }\n    }\n\n    /**\n     * @see Graph#containsEdge(Object)\n     */\n    @Override public boolean containsEdge(E e)\n    {\n        return edgeSet.contains(e);\n    }\n\n    /**\n     * @see Graph#containsVertex(Object)\n     */\n    @Override public boolean containsVertex(V v)\n    {\n        return vertexSet.contains(v);\n    }\n\n    /**\n     * @see Graph#edgeSet()\n     */\n    @Override public Set<E> edgeSet()\n    {\n        if (unmodifiableEdgeSet == null) {\n            unmodifiableEdgeSet = Collections.unmodifiableSet(edgeSet);\n        }\n\n        return unmodifiableEdgeSet;\n    }\n\n    /**\n     * @see Graph#edgesOf(Object)\n     */\n    @Override public Set<E> edgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n        Set<E> baseEdges = base.edgesOf(vertex);\n\n        for (E e : baseEdges) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }\n\n    /**\n     * @see Graph#removeEdge(Object)\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        return edgeSet.remove(e);\n    }\n\n    /**\n     * @see Graph#removeEdge(Object, Object)\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = getEdge(sourceVertex, targetVertex);\n\n        return edgeSet.remove(e) ? e : null;\n    }\n\n    /**\n     * @see Graph#removeVertex(Object)\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        // If the base graph does NOT contain v it means we are here in\n        // response to removal of v from the base. In such case we don't need\n        // to remove all the edges of v as they were already removed.\n        if (containsVertex(v) && base.containsVertex(v)) {\n            removeAllEdges(edgesOf(v));\n        }\n\n        return vertexSet.remove(v);\n    }\n\n    /**\n     * @see Graph#vertexSet()\n     */\n    @Override public Set<V> vertexSet()\n    {\n        if (unmodifiableVertexSet == null) {\n            unmodifiableVertexSet = Collections.unmodifiableSet(vertexSet);\n        }\n\n        return unmodifiableVertexSet;\n    }\n\n    /**\n     * @see Graph#getEdgeSource(Object)\n     */\n    @Override public V getEdgeSource(E e)\n    {\n        return base.getEdgeSource(e);\n    }\n\n    /**\n     * @see Graph#getEdgeTarget(Object)\n     */\n    @Override public V getEdgeTarget(E e)\n    {\n        return base.getEdgeTarget(e);\n    }\n\n    private void addEdgesUsingFilter(Set<E> edgeSet, Set<E> filter)\n    {\n        E e;\n        boolean containsVertices;\n        boolean edgeIncluded;\n\n        for (Iterator<E> iter = edgeSet.iterator(); iter.hasNext();) {\n            e = iter.next();\n\n            V sourceVertex = base.getEdgeSource(e);\n            V targetVertex = base.getEdgeTarget(e);\n            containsVertices =\n                containsVertex(sourceVertex)\n                && containsVertex(targetVertex);\n\n            // note the use of short circuit evaluation\n            edgeIncluded = (filter == null) || filter.contains(e);\n\n            if (containsVertices && edgeIncluded) {\n                addEdge(sourceVertex, targetVertex, e);\n            }\n        }\n    }\n\n    private void addVerticesUsingFilter(Set<V> vertexSet, Set<V> filter)\n    {\n        V v;\n\n        for (Iterator<V> iter = vertexSet.iterator(); iter.hasNext();) {\n            v = iter.next();\n\n            // note the use of short circuit evaluation\n            if ((filter == null) || filter.contains(v)) {\n                addVertex(v);\n            }\n        }\n    }\n\n    public G getBase()\n    {\n        return base;\n    }\n\n    /**\n     * @see Graph#getEdgeWeight(Object)\n     */\n    @Override public double getEdgeWeight(E e)\n    {\n        return base.getEdgeWeight(e);\n    }\n\n    /**\n     * @see WeightedGraph#setEdgeWeight(Object, double)\n     */\n    public void setEdgeWeight(E e, double weight)\n    {\n        ((WeightedGraph<V, E>) base).setEdgeWeight(e, weight);\n    }\n\n    /**\n     * An internal listener on the base graph.\n     *\n     * @author Barak Naveh\n     * @since Jul 20, 2003\n     */\n    private class BaseGraphListener\n        implements GraphListener<V, E>,\n            Serializable\n    {\n        private static final long serialVersionUID = 4343535244243546391L;\n\n        /**\n         * @see GraphListener#edgeAdded(GraphEdgeChangeEvent)\n         */\n        @Override public void edgeAdded(GraphEdgeChangeEvent<V, E> e)\n        {\n            if (isInduced) {\n                E edge = e.getEdge();\n                V source = e.getEdgeSource();\n                V target = e.getEdgeTarget();\n                if (containsVertex(source) && containsVertex(target)) {\n                    addEdge(\n                        source,\n                        target,\n                        edge);\n                }\n            }\n        }\n\n        /**\n         * @see GraphListener#edgeRemoved(GraphEdgeChangeEvent)\n         */\n        @Override public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)\n        {\n            E edge = e.getEdge();\n\n            removeEdge(edge);\n        }\n\n        /**\n         * @see VertexSetListener#vertexAdded(GraphVertexChangeEvent)\n         */\n        @Override public void vertexAdded(GraphVertexChangeEvent<V> e)\n        {\n            // we don't care\n        }\n\n        /**\n         * @see VertexSetListener#vertexRemoved(GraphVertexChangeEvent)\n         */\n        @Override public void vertexRemoved(GraphVertexChangeEvent<V> e)\n        {\n            V vertex = e.getVertex();\n\n            removeVertex(vertex);\n        }\n    }\n}\n\n// End Subgraph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "v",
                "",
                "V"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public String toString()"
            ],
            [
                "edgeSet",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#edgeSet()\n */\n@Override\npublic Set<E> edgeSet() {\n    if (unmodifiableEdgeSet == null) {\n        unmodifiableEdgeSet = Collections.unmodifiableSet(edgeSet);\n    }\n    return unmodifiableEdgeSet;\n}"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#getEdgeSource(Object)\n */\n@Override\npublic V getEdgeSource(E e) {\n    return base.getEdgeSource(e);\n}"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#containsEdge(Object)\n */\n@Override\npublic boolean containsEdge(E e) {\n    return edgeSet.contains(e);\n}"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#removeVertex(Object)\n */\n@Override\npublic boolean removeVertex(V v) {\n    // If the base graph does NOT contain v it means we are here in\n    // response to removal of v from the base. In such case we don't need\n    // to remove all the edges of v as they were already removed.\n    if (containsVertex(v) && base.containsVertex(v)) {\n        removeAllEdges(edgesOf(v));\n    }\n    return vertexSet.remove(v);\n}"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#getEdgeFactory()\n */\n@Override\npublic EdgeFactory<V, E> getEdgeFactory() {\n    return base.getEdgeFactory();\n}"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#removeEdge(Object)\n */\n@Override\npublic boolean removeEdge(E e) {\n    return edgeSet.remove(e);\n}"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#getEdge(Object, Object)\n */\n@Override\npublic E getEdge(V sourceVertex, V targetVertex) {\n    Set<E> edges = getAllEdges(sourceVertex, targetVertex);\n    if ((edges == null) || edges.isEmpty()) {\n        return null;\n    } else {\n        return edges.iterator().next();\n    }\n}"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#addEdge(Object, Object, Object)\n */\n@Override\npublic boolean addEdge(V sourceVertex, V targetVertex, E e) {\n    if (e == null) {\n        throw new NullPointerException();\n    }\n    if (!base.containsEdge(e)) {\n        throw new IllegalArgumentException(NO_SUCH_EDGE_IN_BASE);\n    }\n    assertVertexExist(sourceVertex);\n    assertVertexExist(targetVertex);\n    assert (base.getEdgeSource(e) == sourceVertex);\n    assert (base.getEdgeTarget(e) == targetVertex);\n    if (containsEdge(e)) {\n        return false;\n    } else {\n        edgeSet.add(e);\n        return true;\n    }\n}"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "getBase",
                "org.jgrapht.graph",
                "Subgraph",
                "public G getBase() {\n    return base;\n}"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#addEdge(Object, Object)\n */\n@Override\npublic E addEdge(V sourceVertex, V targetVertex) {\n    assertVertexExist(sourceVertex);\n    assertVertexExist(targetVertex);\n    if (!base.containsEdge(sourceVertex, targetVertex)) {\n        throw new IllegalArgumentException(NO_SUCH_EDGE_IN_BASE);\n    }\n    Set<E> edges = base.getAllEdges(sourceVertex, targetVertex);\n    for (Iterator<E> iter = edges.iterator(); iter.hasNext(); ) {\n        E e = iter.next();\n        if (!containsEdge(e)) {\n            edgeSet.add(e);\n            return e;\n        }\n    }\n    return null;\n}"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#edgesOf(Object)\n */\n@Override\npublic Set<E> edgesOf(V vertex) {\n    assertVertexExist(vertex);\n    Set<E> edges = new ArrayUnenforcedSet<E>();\n    Set<E> baseEdges = base.edgesOf(vertex);\n    for (E e : baseEdges) {\n        if (containsEdge(e)) {\n            edges.add(e);\n        }\n    }\n    return edges;\n}"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#removeEdge(Object, Object)\n */\n@Override\npublic E removeEdge(V sourceVertex, V targetVertex) {\n    E e = getEdge(sourceVertex, targetVertex);\n    return edgeSet.remove(e) ? e : null;\n}"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#containsVertex(Object)\n */\n@Override\npublic boolean containsVertex(V v) {\n    return vertexSet.contains(v);\n}"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#getAllEdges(Object, Object)\n */\n@Override\npublic Set<E> getAllEdges(V sourceVertex, V targetVertex) {\n    Set<E> edges = null;\n    if (containsVertex(sourceVertex) && containsVertex(targetVertex)) {\n        edges = new ArrayUnenforcedSet<E>();\n        Set<E> baseEdges = base.getAllEdges(sourceVertex, targetVertex);\n        for (Iterator<E> iter = baseEdges.iterator(); iter.hasNext(); ) {\n            E e = iter.next();\n            if (edgeSet.contains(e)) {\n                // add if subgraph also contains\n                // it\n                edges.add(e);\n            }\n        }\n    }\n    return edges;\n}"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * Adds the specified vertex to this subgraph.\n *\n * @param v the vertex to be added.\n *\n * @return <code>true</code> if the vertex was added, otherwise <code>\n * false</code>.\n *\n * @throws NullPointerException\n * @throws IllegalArgumentException\n *\n * @see Subgraph\n * @see Graph#addVertex(Object)\n */\n@Override\npublic boolean addVertex(V v) {\n    if (v == null) {\n        throw new NullPointerException();\n    }\n    if (!base.containsVertex(v)) {\n        throw new IllegalArgumentException(NO_SUCH_VERTEX_IN_BASE);\n    }\n    if (containsVertex(v)) {\n        return false;\n    } else {\n        vertexSet.add(v);\n        return true;\n    }\n}"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#vertexSet()\n */\n@Override\npublic Set<V> vertexSet() {\n    if (unmodifiableVertexSet == null) {\n        unmodifiableVertexSet = Collections.unmodifiableSet(vertexSet);\n    }\n    return unmodifiableVertexSet;\n}"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#getEdgeTarget(Object)\n */\n@Override\npublic V getEdgeTarget(E e) {\n    return base.getEdgeTarget(e);\n}"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "Subgraph",
                "/**\n * @see Graph#getEdgeWeight(Object)\n */\n@Override\npublic double getEdgeWeight(E e) {\n    return base.getEdgeWeight(e);\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "edgeSet",
                "org.jgrapht.graph",
                "Subgraph",
                "//\n// friendly to improve performance\nSet<E> edgeSet = new LinkedHashSet<E>();"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "Subgraph",
                "// friendly to improve\nSet<V> vertexSet = new LinkedHashSet<V>();"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26010,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "SimpleDirectedWeightedGraph",
        "javadocTag": "@param ef the edge factory of the new graph.",
        "methodJavadoc": "    /**\n     * Creates a new simple directed weighted graph with the specified edge\n     * factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */",
        "methodSourceCode": "public SimpleDirectedWeightedGraph(EdgeFactory<V, E> ef){\n    super(ef);\n}",
        "classJavadoc": "/**\n * A simple directed weighted graph. A simple directed weighted graph is a\n * simple directed graph for which edges are assigned weights.\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* --------------------------------\n * SimpleDirectedWeightedGraph.java\n * --------------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 06-Aug-2005 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.builder.*;\n\n\n/**\n * A simple directed weighted graph. A simple directed weighted graph is a\n * simple directed graph for which edges are assigned weights.\n */\npublic class SimpleDirectedWeightedGraph<V, E>\n    extends SimpleDirectedGraph<V, E>\n    implements WeightedGraph<V, E>\n{\n    private static final long serialVersionUID = 3904960841681220919L;\n\n    /**\n     * Creates a new simple directed weighted graph with the specified edge\n     * factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */\n    public SimpleDirectedWeightedGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }\n\n    /**\n     * Creates a new simple directed weighted graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public SimpleDirectedWeightedGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }\n\n    public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, SimpleDirectedWeightedGraph<V, E>>(\n                new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n    }\n\n    public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(\n        EdgeFactory<V, E> ef)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, SimpleDirectedWeightedGraph<V, E>>(\n                new SimpleDirectedWeightedGraph<V, E>(ef));\n    }\n}\n\n// End SimpleDirectedWeightedGraph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "ef",
                "org.jgrapht.EdgeFactory",
                "EdgeFactory<V, E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "degreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int degreeOf(V arg0)"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeTarget(E arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsEdge(E arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public double getEdgeWeight(E arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E addEdge(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "outDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int outDegreeOf(V arg0)"
            ],
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeVertex(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E removeEdge(V arg0, V arg1)"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E getEdge(V arg0, V arg1)"
            ],
            [
                "createDirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsVertex(V arg0)"
            ],
            [
                "inDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int inDegreeOf(V arg0)"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addVertex(V arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgeSet()"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public String toString()"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgesOf(V arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<V> vertexSet()"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeSource(E arg0)"
            ],
            [
                "isAllowingMultipleEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingMultipleEdges()"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "clone",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Object clone()"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "isAllowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingLoops()"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeEdge(E arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "createUndirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "createEdge",
                "org.jgrapht",
                "EdgeFactory",
                "public abstract E createEdge(V arg0, V arg1)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "allowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "boolean allowingLoops;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26016,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "WeightedMultigraph",
        "javadocTag": "@param ef the edge factory of the new graph.",
        "methodJavadoc": "    /**\n     * Creates a new weighted multigraph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */",
        "methodSourceCode": "public WeightedMultigraph(EdgeFactory<V, E> ef){\n    super(ef);\n}",
        "classJavadoc": "/**\n * A weighted multigraph. A weighted multigraph is a non-simple undirected graph\n * in which no loops are permitted, but multiple edges between any two vertices\n * are. The edges of a weighted multigraph have weights. If you're unsure about\n * multigraphs, see: <a href=\"http://mathworld.wolfram.com/Multigraph.html\">\n * http://mathworld.wolfram.com/Multigraph.html</a>.\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------------\n * WeightedMultigraph.java\n * -----------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 06-Aug-2005 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.builder.*;\n\n\n/**\n * A weighted multigraph. A weighted multigraph is a non-simple undirected graph\n * in which no loops are permitted, but multiple edges between any two vertices\n * are. The edges of a weighted multigraph have weights. If you're unsure about\n * multigraphs, see: <a href=\"http://mathworld.wolfram.com/Multigraph.html\">\n * http://mathworld.wolfram.com/Multigraph.html</a>.\n */\npublic class WeightedMultigraph<V, E>\n    extends Multigraph<V, E>\n    implements WeightedGraph<V, E>\n{\n    private static final long serialVersionUID = 3544671793370640696L;\n\n    /**\n     * Creates a new weighted multigraph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */\n    public WeightedMultigraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }\n\n    /**\n     * Creates a new weighted multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public WeightedMultigraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }\n\n    public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends WeightedMultigraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, WeightedMultigraph<V, E>>(\n                new WeightedMultigraph<V, E>(edgeClass));\n    }\n\n    public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, WeightedMultigraph<V, E>>(\n                new WeightedMultigraph<V, E>(ef));\n    }\n}\n\n// End WeightedMultigraph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "ef",
                "org.jgrapht.EdgeFactory",
                "EdgeFactory<V, E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "isAllowingMultipleEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingMultipleEdges()"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E getEdge(V arg0, V arg1)"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "inDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int inDegreeOf(V arg0)"
            ],
            [
                "outDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int outDegreeOf(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeEdge(E arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsVertex(V arg0)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeSource(E arg0)"
            ],
            [
                "createUndirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "degreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int degreeOf(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<V> vertexSet()"
            ],
            [
                "edgeSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgeSet()"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E addEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public double getEdgeWeight(E arg0)"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public String toString()"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeTarget(E arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E removeEdge(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsEdge(E arg0)"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addVertex(V arg0)"
            ],
            [
                "createDirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgesOf(V arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeVertex(V arg0)"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Object clone()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "isAllowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingLoops()"
            ],
            [
                "createEdge",
                "org.jgrapht",
                "EdgeFactory",
                "public abstract E createEdge(V arg0, V arg1)"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "allowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "boolean allowingLoops;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26017,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "WeightedMultigraph",
        "javadocTag": "@param edgeClass class on which to base factory for edges",
        "methodJavadoc": "    /**\n     * Creates a new weighted multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */",
        "methodSourceCode": "public WeightedMultigraph(Class<? extends E> edgeClass){\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}",
        "classJavadoc": "/**\n * A weighted multigraph. A weighted multigraph is a non-simple undirected graph\n * in which no loops are permitted, but multiple edges between any two vertices\n * are. The edges of a weighted multigraph have weights. If you're unsure about\n * multigraphs, see: <a href=\"http://mathworld.wolfram.com/Multigraph.html\">\n * http://mathworld.wolfram.com/Multigraph.html</a>.\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------------\n * WeightedMultigraph.java\n * -----------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 06-Aug-2005 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.builder.*;\n\n\n/**\n * A weighted multigraph. A weighted multigraph is a non-simple undirected graph\n * in which no loops are permitted, but multiple edges between any two vertices\n * are. The edges of a weighted multigraph have weights. If you're unsure about\n * multigraphs, see: <a href=\"http://mathworld.wolfram.com/Multigraph.html\">\n * http://mathworld.wolfram.com/Multigraph.html</a>.\n */\npublic class WeightedMultigraph<V, E>\n    extends Multigraph<V, E>\n    implements WeightedGraph<V, E>\n{\n    private static final long serialVersionUID = 3544671793370640696L;\n\n    /**\n     * Creates a new weighted multigraph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */\n    public WeightedMultigraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }\n\n    /**\n     * Creates a new weighted multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public WeightedMultigraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }\n\n    public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends WeightedMultigraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, WeightedMultigraph<V, E>>(\n                new WeightedMultigraph<V, E>(edgeClass));\n    }\n\n    public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, WeightedMultigraph<V, E>>(\n                new WeightedMultigraph<V, E>(ef));\n    }\n}\n\n// End WeightedMultigraph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "edgeClass",
                "java.lang.Class",
                "Class<? extends E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "outDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int outDegreeOf(V arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public double getEdgeWeight(E arg0)"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "isAllowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingLoops()"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E removeEdge(V arg0, V arg1)"
            ],
            [
                "createDirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<V> vertexSet()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addVertex(V arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "edgeSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgeSet()"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsEdge(E arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E getEdge(V arg0, V arg1)"
            ],
            [
                "inDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int inDegreeOf(V arg0)"
            ],
            [
                "degreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int degreeOf(V arg0)"
            ],
            [
                "isAllowingMultipleEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingMultipleEdges()"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeSource(E arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeTarget(E arg0)"
            ],
            [
                "clone",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Object clone()"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgesOf(V arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeVertex(V arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsVertex(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E addEdge(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeEdge(E arg0)"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "createUndirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public String toString()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "desiredAssertionStatus",
                "java.lang",
                "Class",
                "public boolean desiredAssertionStatus()"
            ],
            [
                "toString",
                "java.lang",
                "Class",
                "public String toString()"
            ],
            [
                "isAnnotation",
                "java.lang",
                "Class",
                "public boolean isAnnotation()"
            ],
            [
                "isInterface",
                "java.lang",
                "Class",
                "public native boolean isInterface()"
            ],
            [
                "getNestHost",
                "java.lang",
                "Class",
                "public Class<? extends Object> getNestHost()"
            ],
            [
                "isEnum",
                "java.lang",
                "Class",
                "public boolean isEnum()"
            ],
            [
                "isMemberClass",
                "java.lang",
                "Class",
                "public boolean isMemberClass()"
            ],
            [
                "getDeclaredClasses",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException"
            ],
            [
                "getNestMembers",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getNestMembers()"
            ],
            [
                "getFields",
                "java.lang",
                "Class",
                "public Field[] getFields() throws SecurityException"
            ],
            [
                "getResource",
                "java.lang",
                "Class",
                "public URL getResource(String arg0)"
            ],
            [
                "getGenericInterfaces",
                "java.lang",
                "Class",
                "public Type[] getGenericInterfaces()"
            ],
            [
                "enumConstantDirectory",
                "java.lang",
                "Class",
                "Map<String, T> enumConstantDirectory()"
            ],
            [
                "getAnnotationType",
                "java.lang",
                "Class",
                "AnnotationType getAnnotationType()"
            ],
            [
                "getDeclaredAnnotation",
                "java.lang",
                "Class",
                "public <A> A getDeclaredAnnotation(Class<A> arg0)"
            ],
            [
                "getInterfaces",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getInterfaces()"
            ],
            [
                "getEnumConstants",
                "java.lang",
                "Class",
                "public T[] getEnumConstants()"
            ],
            [
                "isNestmateOf",
                "java.lang",
                "Class",
                "public boolean isNestmateOf(Class<? extends Object> arg0)"
            ],
            [
                "getConstantPool",
                "java.lang",
                "Class",
                "native ConstantPool getConstantPool()"
            ],
            [
                "describeConstable",
                "java.lang",
                "Class",
                "public Optional<ClassDesc> describeConstable()"
            ],
            [
                "getAnnotatedSuperclass",
                "java.lang",
                "Class",
                "public AnnotatedType getAnnotatedSuperclass()"
            ],
            [
                "isPrimitive",
                "java.lang",
                "Class",
                "public native boolean isPrimitive()"
            ],
            [
                "getClasses",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getClasses()"
            ],
            [
                "getDeclaringClass",
                "java.lang",
                "Class",
                "public Class<? extends Object> getDeclaringClass() throws SecurityException"
            ],
            [
                "getGenericSuperclass",
                "java.lang",
                "Class",
                "public Type getGenericSuperclass()"
            ],
            [
                "isArray",
                "java.lang",
                "Class",
                "public native boolean isArray()"
            ],
            [
                "descriptorString",
                "java.lang",
                "Class",
                "public String descriptorString()"
            ],
            [
                "getMethods",
                "java.lang",
                "Class",
                "public Method[] getMethods() throws SecurityException"
            ],
            [
                "getEnumConstantsShared",
                "java.lang",
                "Class",
                "T[] getEnumConstantsShared()"
            ],
            [
                "casAnnotationType",
                "java.lang",
                "Class",
                "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)"
            ],
            [
                "isInstance",
                "java.lang",
                "Class",
                "public native boolean isInstance(Object arg0)"
            ],
            [
                "componentType",
                "java.lang",
                "Class",
                "public Class<? extends Object> componentType()"
            ],
            [
                "getCanonicalName",
                "java.lang",
                "Class",
                "public String getCanonicalName()"
            ],
            [
                "isAnonymousClass",
                "java.lang",
                "Class",
                "public boolean isAnonymousClass()"
            ],
            [
                "getAnnotations",
                "java.lang",
                "Class",
                "public Annotation[] getAnnotations()"
            ],
            [
                "getTypeName",
                "java.lang",
                "Class",
                "public String getTypeName()"
            ],
            [
                "isSealed",
                "java.lang",
                "Class",
                "public boolean isSealed()"
            ],
            [
                "getTypeParameters",
                "java.lang",
                "Class",
                "public TypeVariable<Class<T>>[] getTypeParameters()"
            ],
            [
                "getModule",
                "java.lang",
                "Class",
                "public Module getModule()"
            ],
            [
                "getSuperclass",
                "java.lang",
                "Class",
                "public native Class<? super T> getSuperclass()"
            ],
            [
                "isSynthetic",
                "java.lang",
                "Class",
                "public boolean isSynthetic()"
            ],
            [
                "getEnclosingConstructor",
                "java.lang",
                "Class",
                "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException"
            ],
            [
                "getField",
                "java.lang",
                "Class",
                "public Field getField(String arg0) throws NoSuchFieldException, SecurityException"
            ],
            [
                "getEnclosingMethod",
                "java.lang",
                "Class",
                "public Method getEnclosingMethod() throws SecurityException"
            ],
            [
                "getClassData",
                "java.lang",
                "Class",
                "Object getClassData()"
            ],
            [
                "getDeclaredAnnotationMap",
                "java.lang",
                "Class",
                "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()"
            ],
            [
                "asSubclass",
                "java.lang",
                "Class",
                "public <U> Class<? extends U> asSubclass(Class<U> arg0)"
            ],
            [
                "isHidden",
                "java.lang",
                "Class",
                "public native boolean isHidden()"
            ],
            [
                "getPermittedSubclasses",
                "java.lang",
                "Class",
                "public Class<? extends Object>[] getPermittedSubclasses()"
            ],
            [
                "getComponentType",
                "java.lang",
                "Class",
                "public Class<? extends Object> getComponentType()"
            ],
            [
                "getEnclosingClass",
                "java.lang",
                "Class",
                "public Class<? extends Object> getEnclosingClass() throws SecurityException"
            ],
            [
                "cast",
                "java.lang",
                "Class",
                "public T cast(Object arg0)"
            ],
            [
                "getModifiers",
                "java.lang",
                "Class",
                "public native int getModifiers()"
            ],
            [
                "isLocalClass",
                "java.lang",
                "Class",
                "public boolean isLocalClass()"
            ],
            [
                "getDeclaredFields",
                "java.lang",
                "Class",
                "public Field[] getDeclaredFields() throws SecurityException"
            ],
            [
                "getName",
                "java.lang",
                "Class",
                "public String getName()"
            ],
            [
                "getSigners",
                "java.lang",
                "Class",
                "public native Object[] getSigners()"
            ],
            [
                "getRawTypeAnnotations",
                "java.lang",
                "Class",
                "native byte[] getRawTypeAnnotations()"
            ],
            [
                "getSimpleName",
                "java.lang",
                "Class",
                "public String getSimpleName()"
            ],
            [
                "getResourceAsStream",
                "java.lang",
                "Class",
                "public InputStream getResourceAsStream(String arg0)"
            ],
            [
                "getMethod",
                "java.lang",
                "Class",
                "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException"
            ],
            [
                "isAssignableFrom",
                "java.lang",
                "Class",
                "public native boolean isAssignableFrom(Class<? extends Object> arg0)"
            ],
            [
                "getProtectionDomain",
                "java.lang",
                "Class",
                "public ProtectionDomain getProtectionDomain()"
            ],
            [
                "newInstance",
                "java.lang",
                "Class",
                "public T newInstance() throws InstantiationException, IllegalAccessException"
            ],
            [
                "getPackageName",
                "java.lang",
                "Class",
                "public String getPackageName()"
            ],
            [
                "getDeclaredMethods",
                "java.lang",
                "Class",
                "public Method[] getDeclaredMethods() throws SecurityException"
            ],
            [
                "getDeclaredAnnotations",
                "java.lang",
                "Class",
                "public Annotation[] getDeclaredAnnotations()"
            ],
            [
                "getDeclaredPublicMethods",
                "java.lang",
                "Class",
                "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)"
            ],
            [
                "getConstructor",
                "java.lang",
                "Class",
                "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException"
            ],
            [
                "protectionDomain",
                "java.lang",
                "Class",
                "ProtectionDomain protectionDomain()"
            ],
            [
                "getAnnotatedInterfaces",
                "java.lang",
                "Class",
                "public AnnotatedType[] getAnnotatedInterfaces()"
            ],
            [
                "getClassLoader0",
                "java.lang",
                "Class",
                "ClassLoader getClassLoader0()"
            ],
            [
                "toGenericString",
                "java.lang",
                "Class",
                "public String toGenericString()"
            ],
            [
                "getDeclaredConstructor",
                "java.lang",
                "Class",
                "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException"
            ],
            [
                "arrayType",
                "java.lang",
                "Class",
                "public Class<? extends Object> arrayType()"
            ],
            [
                "getDeclaredConstructors",
                "java.lang",
                "Class",
                "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException"
            ],
            [
                "getDeclaredField",
                "java.lang",
                "Class",
                "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException"
            ],
            [
                "getConstructors",
                "java.lang",
                "Class",
                "public Constructor<? extends Object>[] getConstructors() throws SecurityException"
            ],
            [
                "getRecordComponents",
                "java.lang",
                "Class",
                "public RecordComponent[] getRecordComponents()"
            ],
            [
                "getAnnotation",
                "java.lang",
                "Class",
                "public <A> A getAnnotation(Class<A> arg0)"
            ],
            [
                "getRawAnnotations",
                "java.lang",
                "Class",
                "native byte[] getRawAnnotations()"
            ],
            [
                "getDeclaredAnnotationsByType",
                "java.lang",
                "Class",
                "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)"
            ],
            [
                "isAnnotationPresent",
                "java.lang",
                "Class",
                "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)"
            ],
            [
                "isRecord",
                "java.lang",
                "Class",
                "public boolean isRecord()"
            ],
            [
                "getAnnotationsByType",
                "java.lang",
                "Class",
                "public <A> A[] getAnnotationsByType(Class<A> arg0)"
            ],
            [
                "getPackage",
                "java.lang",
                "Class",
                "public Package getPackage()"
            ],
            [
                "getClassLoader",
                "java.lang",
                "Class",
                "public ClassLoader getClassLoader()"
            ],
            [
                "getDeclaredMethod",
                "java.lang",
                "Class",
                "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getTypeParameters",
                "java.lang.reflect",
                "GenericDeclaration",
                "public abstract TypeVariable<? extends Object>[] getTypeParameters()"
            ],
            [
                "getAnnotation",
                "java.lang.reflect",
                "AnnotatedElement",
                "public abstract <T> T getAnnotation(Class<T> arg0)"
            ],
            [
                "getDeclaredAnnotations",
                "java.lang.reflect",
                "AnnotatedElement",
                "public abstract Annotation[] getDeclaredAnnotations()"
            ],
            [
                "getAnnotations",
                "java.lang.reflect",
                "AnnotatedElement",
                "public abstract Annotation[] getAnnotations()"
            ],
            [
                "getDeclaredAnnotation",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default <T> T getDeclaredAnnotation(Class<T> arg0)"
            ],
            [
                "getDeclaredAnnotationsByType",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)"
            ],
            [
                "getAnnotationsByType",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default <T> T[] getAnnotationsByType(Class<T> arg0)"
            ],
            [
                "isAnnotationPresent",
                "java.lang.reflect",
                "AnnotatedElement",
                "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)"
            ],
            [
                "getTypeName",
                "java.lang.reflect",
                "Type",
                "public default String getTypeName()"
            ],
            [
                "componentType",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract F componentType()"
            ],
            [
                "arrayType",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract F arrayType()"
            ],
            [
                "isArray",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract boolean isArray()"
            ],
            [
                "isPrimitive",
                "java.lang.invoke",
                "TypeDescriptor.OfField",
                "public abstract boolean isPrimitive()"
            ],
            [
                "descriptorString",
                "java.lang.invoke",
                "TypeDescriptor",
                "public abstract String descriptorString()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "allowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "boolean allowingLoops;"
            ],
            [
                "classValueMap",
                "java.lang",
                "Class",
                "transient ClassValue.ClassValueMap classValueMap;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 26019,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "AsWeightedGraph",
        "javadocTag": "@param g the backing graph over which a weighted view is to be created.",
        "methodJavadoc": "    /**\n     * Constructor for AsWeightedGraph.\n     *\n     * @param g the backing graph over which a weighted view is to be created.\n     * @param weightMap A mapping of edges to weights. If an edge is not present\n     * in the weight map, the edge weight for the underlying graph is returned.\n     * Note that a live reference to this map is retained, so if the caller\n     * changes the map after construction, the changes will affect the\n     * AsWeightedGraph instance as well.\n     */",
        "methodSourceCode": "public AsWeightedGraph(Graph<V, E> g, Map<E, Double> weightMap){\n    super(g);\n    assert (weightMap != null);\n    this.weightMap = weightMap;\n    // Remember whether the backing graph implements the WeightedGraph\n    // interface\n    this.isWeightedGraph = (g instanceof WeightedGraph<?, ?>);\n}",
        "classJavadoc": "/**\n * <p>A weighted view of the backing graph specified in the constructor. This\n * graph allows modules to apply algorithms designed for weighted graphs to an\n * unweighted graph by providing an explicit edge weight mapping. The\n * implementation also allows for \"masking\" weights for a subset of the edges in\n * an existing weighted graph.</p>\n *\n * <p>Query operations on this graph \"read through\" to the backing graph. Vertex\n * addition/removal and edge addition/removal are all supported (and immediately\n * reflected in the backing graph). Setting an edge weight will pass the\n * operation to the backing graph as well if the backing graph implements the\n * WeightedGraph interface. Setting an edge weight will modify the weight map in\n * order to maintain a consistent graph.</p>\n *\n * <p>Note that edges returned by this graph's accessors are really just the\n * edges of the underlying directed graph.</p>\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods. This graph will be serializable if the backing\n * graph is serializable.</p>\n *\n * @author Lucas J. Scharenbroich\n * @since Sep 10, 2007\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/*  ----------------------\n * AsWeightedGraph.java\n * ----------------------\n * (C) Copyright 2007, by Lucas J. Scharenbroich and Contributors.\n *\n * Original Author:  Lucas J. Scharenbroich\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Sep-2007 : Initial revision (LJS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * <p>A weighted view of the backing graph specified in the constructor. This\n * graph allows modules to apply algorithms designed for weighted graphs to an\n * unweighted graph by providing an explicit edge weight mapping. The\n * implementation also allows for \"masking\" weights for a subset of the edges in\n * an existing weighted graph.</p>\n *\n * <p>Query operations on this graph \"read through\" to the backing graph. Vertex\n * addition/removal and edge addition/removal are all supported (and immediately\n * reflected in the backing graph). Setting an edge weight will pass the\n * operation to the backing graph as well if the backing graph implements the\n * WeightedGraph interface. Setting an edge weight will modify the weight map in\n * order to maintain a consistent graph.</p>\n *\n * <p>Note that edges returned by this graph's accessors are really just the\n * edges of the underlying directed graph.</p>\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods. This graph will be serializable if the backing\n * graph is serializable.</p>\n *\n * @author Lucas J. Scharenbroich\n * @since Sep 10, 2007\n */\npublic class AsWeightedGraph<V, E>\n    extends GraphDelegator<V, E>\n    implements Serializable,\n        WeightedGraph<V, E>\n{\n    /**\n     */\n    private static final long serialVersionUID = -716810639338971372L;\n\n    protected final Map<E, Double> weightMap;\n    private final boolean isWeightedGraph;\n\n    /**\n     * Constructor for AsWeightedGraph.\n     *\n     * @param g the backing graph over which a weighted view is to be created.\n     * @param weightMap A mapping of edges to weights. If an edge is not present\n     * in the weight map, the edge weight for the underlying graph is returned.\n     * Note that a live reference to this map is retained, so if the caller\n     * changes the map after construction, the changes will affect the\n     * AsWeightedGraph instance as well.\n     */\n    public AsWeightedGraph(Graph<V, E> g, Map<E, Double> weightMap)\n    {\n        super(g);\n        assert (weightMap != null);\n        this.weightMap = weightMap;\n\n        // Remember whether the backing graph implements the WeightedGraph\n        // interface\n        this.isWeightedGraph = (g instanceof WeightedGraph<?, ?>);\n    }\n\n    /**\n     * @see WeightedGraph#setEdgeWeight\n     */\n    @Override public void setEdgeWeight(E e, double weight)\n    {\n        if (isWeightedGraph) {\n            super.setEdgeWeight(e, weight);\n        }\n\n        // Always modify the weight map.  It would be a terrible violation\n        // of the use contract to silently ignore changes to the weights.\n        weightMap.put(e, weight);\n    }\n\n    /**\n     * @see Graph#getEdgeWeight\n     */\n    @Override public double getEdgeWeight(E e)\n    {\n        double weight;\n\n        // Always return the value from the weight map first and\n        // only pass the call through as a backup\n        if (weightMap.containsKey(e)) {\n            weight = weightMap.get(e);\n        } else {\n            weight = super.getEdgeWeight(e);\n        }\n\n        return weight;\n    }\n}\n\n// End AsWeightedGraph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "g",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "weightMap",
                "java.util.Map",
                "Map<E, Double>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "outgoingEdgesOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public E getEdge(V arg0, V arg1)"
            ],
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<V> vertexSet()"
            ],
            [
                "outDegreeOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public int outDegreeOf(V arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public E addEdge(V arg0, V arg1)"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public boolean containsVertex(V arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> edgeSet()"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public boolean removeVertex(V arg0)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public V getEdgeSource(E arg0)"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public V getEdgeTarget(E arg0)"
            ],
            [
                "inDegreeOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public int inDegreeOf(V arg0)"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public String toString()"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "AsWeightedGraph",
                "/**\n * @see Graph#getEdgeWeight\n */\n@Override\npublic double getEdgeWeight(E e) {\n    double weight;\n    // Always return the value from the weight map first and\n    // only pass the call through as a backup\n    if (weightMap.containsKey(e)) {\n        weight = weightMap.get(e);\n    } else {\n        weight = super.getEdgeWeight(e);\n    }\n    return weight;\n}"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "degreeOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public int degreeOf(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public boolean containsEdge(E arg0)"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public boolean removeEdge(E arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> edgesOf(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public boolean addVertex(V arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "GraphDelegator",
                "public E removeEdge(V arg0, V arg1)"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "containsValue",
                "java.util",
                "Map",
                "public abstract boolean containsValue(Object arg0)"
            ],
            [
                "merge",
                "java.util",
                "Map",
                "public default V merge(K arg0, V arg1, BiFunction<? super V, ? super V, ? extends V> arg2)"
            ],
            [
                "keySet",
                "java.util",
                "Map",
                "public abstract Set<K> keySet()"
            ],
            [
                "equals",
                "java.util",
                "Map",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "put",
                "java.util",
                "Map",
                "public abstract V put(K arg0, V arg1)"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public abstract V remove(Object arg0)"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default boolean replace(K arg0, V arg1, V arg2)"
            ],
            [
                "hashCode",
                "java.util",
                "Map",
                "public abstract int hashCode()"
            ],
            [
                "entrySet",
                "java.util",
                "Map",
                "public abstract Set<Map.Entry<K, V>> entrySet()"
            ],
            [
                "isEmpty",
                "java.util",
                "Map",
                "public abstract boolean isEmpty()"
            ],
            [
                "get",
                "java.util",
                "Map",
                "public abstract V get(Object arg0)"
            ],
            [
                "computeIfPresent",
                "java.util",
                "Map",
                "public default V computeIfPresent(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "getOrDefault",
                "java.util",
                "Map",
                "public default V getOrDefault(Object arg0, V arg1)"
            ],
            [
                "values",
                "java.util",
                "Map",
                "public abstract Collection<V> values()"
            ],
            [
                "compute",
                "java.util",
                "Map",
                "public default V compute(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public default boolean remove(Object arg0, Object arg1)"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default V replace(K arg0, V arg1)"
            ],
            [
                "putIfAbsent",
                "java.util",
                "Map",
                "public default V putIfAbsent(K arg0, V arg1)"
            ],
            [
                "size",
                "java.util",
                "Map",
                "public abstract int size()"
            ],
            [
                "computeIfAbsent",
                "java.util",
                "Map",
                "public default V computeIfAbsent(K arg0, Function<? super K, ? extends V> arg1)"
            ],
            [
                "containsKey",
                "java.util",
                "Map",
                "public abstract boolean containsKey(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "weightMap",
                "org.jgrapht.graph",
                "AsWeightedGraph",
                "protected final Map<E, Double> weightMap;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]